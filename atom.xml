<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiejinpeng007.github.io</id>
    <title>xiejinpeng&apos;s blog</title>
    <updated>2022-05-16T03:56:34.118Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiejinpeng007.github.io"/>
    <link rel="self" href="https://xiejinpeng007.github.io/atom.xml"/>
    <subtitle>你觉得做什么事很痛苦，那么就需要去越过它。</subtitle>
    <logo>https://xiejinpeng007.github.io/images/avatar.png</logo>
    <icon>https://xiejinpeng007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, xiejinpeng&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[AppBundle 详解和实际效果对比]]></title>
        <id>https://xiejinpeng007.github.io/post/appbundle-introduce/</id>
        <link href="https://xiejinpeng007.github.io/post/appbundle-introduce/">
        </link>
        <updated>2021-04-30T06:07:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>从 2021 年 8 月起，新应用需要使用 Android App Bundle 才能在 Google Play 中发布。现在，Play Feature Delivery 或 Play Asset Delivery 支持大小超过 150 MB 的新应用。</p>
</blockquote>
<p>由于 Google Play 的政策要求，最近越来多的项目在调查 AppBundle 的问题，总结一下。</p>
<h3 id="app-bundle-是什么">App Bundle 是什么</h3>
<p>Android App Bundle 是一种发布格式，其中包含应用的所有经过编译的代码和资源，它会将 APK 生成及签名交由 Google Play 来完成。<br>
Google 主要想通过 App Bundle 来实现优化 APK 体积、动态分发等功能，方式就是 <code>Split APKs(拆分apk)</code>。</p>
<p>从下图可以看到, 资源被分布到了各个模块中，每个模块的组织方式都和 APK 相似，是因为最终每个模块都可以作为单独的 APK 生成。</p>
<figure data-type="image" tabindex="1"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38cfed3e911a43d89c6b9376fbd5a421~tplv-k3u1fbpfcp-watermark.image" alt="aab_format-2x.png" loading="lazy"></figure>
<p>图1 的 AppBundle 包含了一个基本模块、两个功能模块和两个资源包。</p>
<p>更详细的目录结构：</p>
<ul>
<li>
<p>base/、feature1/ 和 feature2/：其中每个顶级目录都表示一个不同的应用模块。应用的基本模块始终包含在 App Bundle 的 base 目录中。不过，为每个功能模块的目录提供的名称由模块清单中的 split 属性指定。如需了解详情，请参阅功能模块清单。</p>
</li>
<li>
<p>asset_pack_1/ 和 asset_pack_2/：对于需要大量图形处理的大型应用或游戏，您可以将资产模块化处理为资源包。资源包因体积上限较高而成为游戏的理想之选。您可以按照三种分发模式（即，安装时分发、快速跟进式分发和按需分发）自定义如何以及何时将各个资源包下载到设备上。所有资源包都在 Google Play 上托管并从 Google Play 提供。如需详细了解如何将资源包添加到您的 app bundle。</p>
</li>
<li>
<p>BUNDLE-METADATA/：此目录包含元数据文件，其中包含对工具或应用商店有用的信息。此类元数据文件可能包含 ProGuard 映射和应用的 DEX 文件的完整列表。此目录中的文件未打包到您应用的 APK 中。</p>
</li>
<li>
<p>模块协议缓冲区 (*.pb) 文件：这些文件提供了一些元数据，有助于向各个应用商店（如 Google Play）说明每个应用模块的内容。例如，BundleConfig.pb 提供了有关 bundle 本身的信息（如用于构建 app bundle 的构建工具版本），native.pb 和 resources.pb 说明了每个模块中的代码和资源，这在 Google Play 针对不同的设备配置优化 APK 时非常有用。</p>
</li>
<li>
<p>manifest/：与 APK 不同，app bundle 将每个模块的 AndroidManifest.xml 文件存储在这个单独的目录中。</p>
</li>
<li>
<p>dex/：与 APK 不同，app bundle 将每个模块的 DEX 文件存储在这个单独的目录中。</p>
</li>
<li>
<p>res/、lib/ 和 assets/：这些目录与典型 APK 中的目录完全相同。当您上传 App Bundle 时，Google Play 会检查这些目录并且仅打包满足目标设备配置需求的文件，同时保留文件路径。</p>
</li>
<li>
<p>root/：此目录存储的文件之后会重新定位到包含此目录所在模块的任意 APK 的根目录。例如，app bundle 的 base/root/ 目录可能包含您的应用使用 Class.getResource() 加载的基于 Java 的资源。这些文件之后会重新定位到您应用的基本 APK 和 Google Play 生成的每个多 APK 的根目录。此目录中的路径也会保留下来。也就是说，目录（及其子目录）也会重新定位到 APK 的根目录。</p>
</li>
</ul>
<h3 id="split-apks-拆分-apk">Split APKs （拆分 apk）</h3>
<p>AppBundle 按以上方式组织资源之后，就是为了便于拆分 APK 。<br>
拆分 APK 可以从两个维度来考虑：</p>
<h4 id="1-根据机型所需的资源拆分成不同的-apk">1. 根据机型所需的资源拆分成不同的 apk</h4>
<p>由于 Android 手机类型很多需要适配不同的资源：<code>ABI (armeabi armeabi-v7a arm64-v8a x86..)</code> <code>屏幕密度</code> <code>语言</code>。最后各种资源都会被打包到 apk 里。</p>
<figure data-type="image" tabindex="2"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/199a273660974e16a0f5cb4c44b324bc~tplv-k3u1fbpfcp-watermark.image" alt="appbundle_apk-2.png" loading="lazy"></figure>
<p>以上面 apk 里的 <code>res</code> <code>lib</code>文件夹为例可以看到，过去我们打包的 apk 都包含了以上所有的资源，而且 so 库 + 图片布局资源 的体积在整个 apk 中占很大的比例。</p>
<p>但实际上每一台手机从各个维度来讲都只需要一种对应的资源：例如 cpu 是 armeabi-v7a 的就只需要下载 armeabi-v7a 的 so 库；屏幕 PPI 是 400 就只需要下载 xxxhdpi 的图片布局资源 ；中文语言使用者只需要下载中文语言资源。<br>
参考下图：</p>
<figure data-type="image" tabindex="3"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/edea89b9fa634229b02bacdf95bf3639~tplv-k3u1fbpfcp-watermark.image" alt="appbundlesplit.gif" loading="lazy"></figure>
<h4 id="2-根据基本功能-附加功能拆分成不同的-apk">2. 根据基本功能、附加功能拆分成不同的 apk</h4>
<p>app 初次下载只需要下载基本功能，需要用到的时候再进行附加功能模块下载。</p>
<p>根据上面的两个维度的考虑，Google Play 会把 AppBundle 打包成三类 APK</p>
<ul>
<li>
<p>基本 APK：<br>
此 APK 中包含了所有其他拆分 APK 都可以访问的代码和资源，并提供应用的基本功能。当用户请求下载您的应用时，会首先下载并安装该 APK。这是因为只有基本 APK 的清单才包含关于应用的服务、内容提供方、权限、平台版本要求和对系统功能的依赖性的完整声明。Google Play 会根据项目的应用模块（即基本模块）为应用生成基本 APK。如果您想减小应用的初始下载大小，请一定要注意，此模块中包含的所有代码和资源都包含在应用的基本 APK 中。</p>
</li>
<li>
<p>配置 APK：<br>
每个配置 APK 都包含针对特定屏幕密度、CPU 架构或语言的原生库和资源。当用户下载您的应用时，他们的设备只会下载并安装该设备对应的配置 APK。每个配置 APK 都是基本 APK 或功能模块 APK 的依赖项。也就是说，配置 APK 会随它们为之提供代码和资源的 APK 一起下载和安装。与基本模块和功能模块不同，您不需要为配置 APK 单独创建模块。如果您在为基本模块和功能模块组织管理配置专用的备用资源时遵循了标准实践，Google Play 会自动为您生成配置 APK。</p>
</li>
<li>
<p>功能模块 APK：<br>
每个功能模块 APK 都包含您使用功能模块进行了模块化处理的某项应用功能的代码和资源。您随后可以自定义如何以及何时将该功能下载到设备上。例如，使用 Play 核心库，可在将基本 APK 安装到设备上之后再按需安装某些功能，以向用户提供额外的功能。假设我们有一款聊天应用，它仅在用户想要拍摄并发送照片时才下载并安装该功能。由于功能模块在安装时可能不可用，因此您应将所有通用代码和资源包含在基本 APK 中。也就是说，您的功能模块应假定在安装时只有基本 APK 的代码和资源可用。Google Play 会根据项目的功能模块为应用生成功能模块 APK。</p>
</li>
</ul>
<p>一个包含三个功能模块并支持多种设备配置的应用如下的 APK 之间依赖关系树如下：</p>
<figure data-type="image" tabindex="4"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64eb79d3e6b5445396c34cf442b514de~tplv-k3u1fbpfcp-watermark.image" alt="apk_splits_tree-2x.png" loading="lazy"></figure>
<h3 id="构建-测试-配置-appbundle">构建、测试、配置 AppBundle</h3>
<h4 id="构建-appbundle">构建 AppBundle</h4>
<p>和以前打包 APK 类似，命令 assemble 换成 bundle 就可以了。如</p>
<pre><code>./gradlew assembleProductionRelease
 -&gt;  
./gradlew bundleProductionRelease
</code></pre>
<h4 id="测试-appbundle">测试 AppBundle</h4>
<ul>
<li>
<p>通过 Google Play 的测试频道部署 AppBundle<br>
比较麻烦，需要比较正式的配置</p>
</li>
<li>
<p>通过 Google Play 的内部分享频道部署 AppBundle<br>
交付测试人员测试的话推荐这种方式，可以直接上传 .aab 分享下载，比测试频道的限制更少：<br>
App 签名和 versionCode 这些都没有限制。<br>
参考下图</p>
</li>
</ul>
<figure data-type="image" tabindex="5"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c4eca29b074c4d9695671d4022ae1a57~tplv-k3u1fbpfcp-watermark.image" alt="internalshare-2.png" loading="lazy"></figure>
<ul>
<li>
<p>使用命令行工具<code>bundletool</code></p>
<ol>
<li>生成 apks</li>
</ol>
<pre><code>//默认使用debug的签名
bundletool build-apks --bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks
//或指定签名
bundletool build-apks --bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks
</code></pre>
</li>
</ul>
<p>--ks=/MyApp/keystore.jks<br>
--ks-pass=file:/MyApp/keystore.pwd<br>
--ks-key-alias=MyKeyAlias<br>
--key-pass=file:/MyApp/key.pwd<br>
```</p>
<pre><code>2. 从 apks 部署 apk 到设备 

```
bundletool install-apks --apks=/MyApp/my_app.apks
```
</code></pre>
<h5 id="生成-apks-时的一些配置">生成 apks 时的一些配置</h5>
<p>默认生成 apks 时，所有相关的配置集都会打包到 apk，测试的时候一般只需要特定机型的 apk，有几种配置的方法：</p>
<ul>
<li>只生成已连接到 adb 机型的 apk</li>
</ul>
<pre><code>bundletool build-apks --connected-device
--bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks
</code></pre>
<ul>
<li>生成一个描述机型配置的 JSON 文件</li>
</ul>
<pre><code>bundletool get-device-spec --output=/tmp/device-spec.json
</code></pre>
<p>然后生成 apks 的时候配置一下</p>
<pre><code>bundletool build-apks --device-spec=/MyApp/pixel2.json
--bundle=/MyApp/my_app.aab --output=/MyApp/my_app.apks
</code></pre>
<p>也可以手动生成或者调整机型配置的 JSON 文件</p>
<pre><code>{
 &quot;supportedAbis&quot;: [&quot;arm64-v8a&quot;, &quot;armeabi-v7a&quot;],
 &quot;supportedLocales&quot;: [&quot;en&quot;, &quot;fr&quot;],
 &quot;screenDensity&quot;: 640,
 &quot;sdkVersion&quot;: 27
}
</code></pre>
<p>其它参数配置参考<a href="https://developer.android.com/studio/command-line/bundletool#generate_apks">文档</a></p>
<h5 id="从-apks-中提取指定的-apk">从 APKs 中提取指定的 APK</h5>
<p>除了只生成特定机型 APK 的APKs之外，也可以从 APKs 中提取指定的 APK，方便安装和估算 APK 大小之类的。</p>
<p>提取指定 apk:</p>
<pre><code>bundletool extract-apks
--apks=/MyApp/my_existing_APK_set.apks
--output-dir=/MyApp/my_pixel2_APK_set.apks
--device-spec=/MyApp/bundletool/pixel2.json
</code></pre>
<p>估算 APK 安装到设备后大小范围 (也可手动指定配置参考<a href="https://developer.android.com/studio/command-line/bundletool#measure_size">文档</a>)</p>
<pre><code>bundletool get-size total --apks=/MyApp/my_app.apks
</code></pre>
<h3 id="appbundle-原理和实际效果">AppBundle 原理和实际效果</h3>
<p>AppBundle 技术最大的不同就是以前只打一个 APK 直接安装 ，现在打包成一个 AppBundle 再打包成 APKs，根据设备配置进行安装，下面实际来测试一下有什么不同。</p>
<p>Android 开发人员应该都知道安装的 apk 实际上被放在了一个 APP 的私有的目录(/data/app)。<br>
以 Demo 项目为例，直接打包 apk 后安装到模拟器:</p>
<figure data-type="image" tabindex="6"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c97d560add9479ca305d0ef63284c4f~tplv-k3u1fbpfcp-watermark.image" alt="apk-size-2.png" loading="lazy"></figure>
<p>可以看到安装目录下只有一个 <code>base.apk</code> ,大小是 23.5MB<br>
然后我再打包一个 appbundle ，用 bundletool 生成 APKs 后查看内容</p>
<figure data-type="image" tabindex="7"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e44d949881ca4102abf4bdf85dc4a85f~tplv-k3u1fbpfcp-watermark.image" alt="apks.png" loading="lazy"></figure>
<p>可以看到中有很多根据不同维度生成的 APK，实际上 APKs 就是包含所有 split apk 的集合。</p>
<p>下一步用命令从 APKs 从安装到模拟器后，查看安装目录。</p>
<figure data-type="image" tabindex="8"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/391a2633f9c0456d8fa2fdb75e04d0ae~tplv-k3u1fbpfcp-watermark.image" alt="appbundle-size-2.png" loading="lazy"></figure>
<p>可以看到安装目录里的内容不一样了，被拆分成多个 apk 进行安装。<br>
有 base.apk split_config.en.apk split_config.x86.apk split_config.xxhdpi.apk 以及一些其他的如 so库和 dex 文件。</p>
<ul>
<li>base.apk  : 基础的 APK</li>
<li>split_config.en.apk 英语语言的资源</li>
<li>split_config.x86.apk x86架构的配置</li>
<li>split_config.xxhdpi.apk 该设备仅需的 xxhdpi</li>
<li>lib/x86 x86架构下用到的 so库</li>
<li>oat/x86/base.art base.odex base.vdex 对应以前的 dex 文件</li>
</ul>
<p>再对比一下直接安装 apk 和经过 AppBundle 安装拆分后的总大小差异</p>
<figure data-type="image" tabindex="9"><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b28766022854d14859000a9f9d0cf63~tplv-k3u1fbpfcp-watermark.image" alt="size-diff-2.png" loading="lazy"></figure>
<p>可以看到两者有 16.5MB 和 (7.5MB-14.8MB) 的差异（意思是根据机型不同安装的 apk 大小范围）对于这个so库和图片资源用的不多的 APP 体积最多可以减少50%+，其它 APP 差距可能会更大，所以效果还是很明显的，并且下载和安装到设备后的体积都能得到优化。</p>
<h5 id="动态交付play-feature-delivery">动态交付（Play Feature Delivery）：</h5>
<p>除此之外，拆分 apk 还可以实现动态交付的功能，首次安装只下载基本的 apk，非必要的模块动态下载。（依赖于 Google Play 商店）<br>
这个我还没有实际用过，可以参考文档 <a href="https://developer.android.com/guide/app-bundle/dynamic-delivery">Play Feature Delivery</a></p>
<h5 id="appbundle-的限制">AppBundle 的限制</h5>
<ul>
<li>Android 5.0</li>
</ul>
<p>Android 5.0 以上才支持安装拆分 APK，所以 5.0 以下相关的特性都没办法完全利用，不过开发者也不需要太关心， Google Play 会生成相应可以使用的 APK。</p>
<ul>
<li>
<p>oob 格式</p>
<p>游戏常用的 oob 格式不再支持，推荐改为 asset_pack</p>
</li>
</ul>
<h5 id="appbundle-签名替换">AppBundle 签名替换</h5>
<p>部分项目的签名流程是在我们签名 apk 后，客户会重新签名再上传到 Google Play：<br>
AppBundle 格式不能用 apksinger 签名，可以改用 jarsigner。<br>
另外一个方法参考后面会提到的 Play 签名计划</p>
<h4 id="play-应用签名计划">Play 应用签名计划</h4>
<p>Google Play 一直有一个 Play 应用签名计划，以前不用管它，但使用了 AppBundle 的话强制要求使用。一个原因是我们上传的 AppBundle 后，Google Play 需要打包成 APKs ，所以我们需要把签名交给 Google Play.</p>
<p><strong>Play 应用签名计划会使用两个密钥：应用签名密钥和上传密钥，上传密钥是用于验证我们上传给 Google的 .aab/.apk 的身份，应用签名密钥可以前一样给App签名的。</strong></p>
<p>原理参考：</p>
<figure data-type="image" tabindex="10"><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d8da13e668047fea2036287aba624d0~tplv-k3u1fbpfcp-watermark.image" alt="appsigning_googleplayappsigningdiagram_2x.png" loading="lazy"></figure>
<p>其中关于应用签名密钥有两种选择：</p>
<ol>
<li>
<p>上传加密后的密钥给 Google Play ，然后 Google Play 用这个密钥签名。</p>
</li>
<li>
<p>上传加密后的密钥给 Google Play，但是 Google Play 会自己生成另一套密钥来给 APK 签名，我们上传的密钥只作为验证 AppBundle 使用。</p>
<ul>
<li>好处：万一我们的密钥丢失或被盗了，只需证明身份，那么还可以继续使用 Google Play 生成的签名，方式一的话，就只能更换签名。</li>
<li>坏处：<br>
1. 如果我们想在其它商店或者官网发布有自己密钥签名的 APK，那么就由于和 Google Play 的签名不一样，不能覆盖安装。<br>
2. 一些 SDK 如我们用过的乐天 IDSDK 就需要根据证书指纹认证身份，需要更换为真实签名的指纹。</li>
</ul>
</li>
</ol>
<p>上传密钥需要用 PEPK 工具加密后上传：</p>
<figure data-type="image" tabindex="11"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/406e76ceab564424b1b426672466effa~tplv-k3u1fbpfcp-watermark.image" alt="pepk.png" loading="lazy"></figure>
<p>此外，刚才提到的替换签名的需求也可以通过区分上传密钥和签名来实现，将我们这边打包的 appbundle 的 密钥设置为Play签名计划里的上传密钥，将客户实际打包的密钥设置为应用签名密钥，就可以实现原来重新签名的需求。</p>
<h3 id="总结">总结</h3>
<p>总的来说，如果我们的 APP工程结构标准，没有用太多的黑科技的话（特殊情况可能会打包失败之类，需要专门排查），通过 AppBundle 可以很轻松地以很低的成本就获得较大的 APK 体积压缩优化，还是很划算的。并且 Google Play 强制要求了，也不用纠结用不用了。项目已经使用 AppBundle 格式一段时间了，没有遇到太大问题。<br>
另外，通过 AppBundle 我认为以后开发 APP 时可以有一些拆分 Module 的想法。这样可以尝试 Play Feature Delivery 、 Instant App （免安装App）这些功能。</p>
<p>参考：<br>
<a href="https://developer.android.com/guide/app-bundle/app-bundle-format?hl=zh_cn#multi_apks">https://developer.android.com/guide/app-bundle/app-bundle-format?hl=zh_cn#multi_apks</a><br>
<a href="https://developer.android.com/studio/command-line/bundletool">https://developer.android.com/studio/command-line/bundletool</a><br>
<a href="https://developer.android.com/guide/app-bundle/dynamic-delivery">https://developer.android.com/guide/app-bundle/dynamic-delivery</a><br>
<a href="https://developer.android.com/guide/app-bundle/test">https://developer.android.com/guide/app-bundle/test</a><br>
<a href="https://support.google.com/googleplay/android-developer/answer/9842756?hl=zh-Hans#">https://support.google.com/googleplay/android-developer/answer/9842756?hl=zh-Hans#</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Chrome Extension 开发简介]]></title>
        <id>https://xiejinpeng007.github.io/post/chrome-extensions-develop-intro/</id>
        <link href="https://xiejinpeng007.github.io/post/chrome-extensions-develop-intro/">
        </link>
        <updated>2021-02-05T05:56:42.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>最近想写一个对网页进行自动填充、跳转等操作的一个脚本。联想到平时用了那么多插件，调查了一下之后发现 Chrome 插件可以做很多事情，翻译类、广告拦截类、修改页面样式类（主题、暗黑模式）、效率类（快捷键、鼠标手势）、以及一系列小工具。</p>
<h3 id="chrome-插件是什么">Chrome 插件是什么？</h3>
<p>Chrome 插件相信各位用的很多很熟悉了，根据名字来看，其实<code>插件/拓展</code>这个描述挺准的，Chrome Extensions 能在原本网页功能的基础上通过操作 DOM 来添加/修改 JS 、CSS 、HTML 达到功能的增加、样式的修改等目的。</p>
<h3 id="开发-chrome-extensions-需要具备的知识">开发 Chrome Extensions 需要具备的知识</h3>
<ul>
<li>JavaScript HTML CSS</li>
</ul>
<h2 id="核心部分">核心部分</h2>
<h3 id="manifestjson">manifest.json</h3>
<p><code>manifes.json</code>是 Chrome 插件最重要也是唯一必须的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，<code>manifest_version</code>、<code>name</code>、<code>version</code> 3个是必不可少的，description 和 icons 是推荐的。<br>
这里是以 V2 版本为例，最新的 manifest 版本刚刚被 Google 升到了 V3。</p>
<pre><code>{
	// manifest 版本，最新的是 3
	&quot;manifest_version&quot;: 2,
	// 插件的名称
	&quot;name&quot;: &quot;demo&quot;,
	// 插件的版本
	&quot;version&quot;: &quot;1.0.0&quot;,
	// 插件描述
	&quot;description&quot;: &quot;简单的Chrome扩展demo&quot;,
	// 图标
	&quot;icons&quot;:
	{
		&quot;16&quot;: &quot;img/icon.png&quot;,
		&quot;48&quot;: &quot;img/icon.png&quot;,
		&quot;128&quot;: &quot;img/icon.png&quot;
	},
	// 会一直常驻的后台JS或后台页面
	&quot;background&quot;:
	{
		// 2种指定方式，如果指定JS，那么会自动生成一个背景页
		&quot;page&quot;: &quot;background.html&quot;
		//&quot;scripts&quot;: [&quot;js/background.js&quot;]
	},
	// 浏览器右上角图标设置，browser_action、page_action、app必须三选一
	&quot;browser_action&quot;: 
	{
		&quot;default_icon&quot;: &quot;img/icon.png&quot;,
		// 图标悬停时的标题，可选
		&quot;default_title&quot;: &quot;这是一个示例Chrome插件&quot;,
		&quot;default_popup&quot;: &quot;popup.html&quot;
	},
	// 当某些特定页面打开才显示的图标
	/*&quot;page_action&quot;:
	{
		&quot;default_icon&quot;: &quot;img/icon.png&quot;,
		&quot;default_title&quot;: &quot;我是pageAction&quot;,
		&quot;default_popup&quot;: &quot;popup.html&quot;
	},*/
	// 需要直接注入页面的JS
	&quot;content_scripts&quot;: 
	[
		{
			//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],
			// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址
			&quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],
			// 多个JS按顺序注入
			&quot;js&quot;: [&quot;js/jquery-1.8.3.js&quot;, &quot;js/content-script.js&quot;],
			// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式
			&quot;css&quot;: [&quot;css/custom.css&quot;],
			// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，最后一个表示页面空闲时，默认document_idle
			&quot;run_at&quot;: &quot;document_start&quot;
		},
		// 这里仅仅是为了演示content-script可以配置多个规则
		{
			&quot;matches&quot;: [&quot;*://*/*.png&quot;, &quot;*://*/*.jpg&quot;, &quot;*://*/*.gif&quot;, &quot;*://*/*.bmp&quot;],
			&quot;js&quot;: [&quot;js/show-image-content-size.js&quot;]
		}
	],
	// 权限申请
	&quot;permissions&quot;:
	[
		&quot;contextMenus&quot;, // 右键菜单
		&quot;tabs&quot;, // 标签
		&quot;notifications&quot;, // 通知
		&quot;webRequest&quot;, // web请求
		&quot;webRequestBlocking&quot;,
		&quot;storage&quot;, // 插件本地存储
		&quot;http://*/*&quot;, // 可以通过executeScript或者insertCSS访问的网站
		&quot;https://*/*&quot; // 可以通过executeScript或者insertCSS访问的网站
	],
	// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的
	&quot;web_accessible_resources&quot;: [&quot;js/inject.js&quot;],
	// 插件主页，这个很重要，不要浪费了这个免费广告位
	&quot;homepage_url&quot;: &quot;https://www.baidu.com&quot;,
	// 覆盖浏览器默认页面
	&quot;chrome_url_overrides&quot;:
	{
		// 覆盖浏览器默认的新标签页
		&quot;newtab&quot;: &quot;newtab.html&quot;
	},
	// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个
	&quot;options_ui&quot;:
	{
		&quot;page&quot;: &quot;options.html&quot;,
		// 添加一些默认的样式，推荐使用
		&quot;chrome_style&quot;: true
	},
	// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字
	&quot;omnibox&quot;: { &quot;keyword&quot; : &quot;go&quot; },
	// 默认语言
	&quot;default_locale&quot;: &quot;zh_CN&quot;,
	// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件
	&quot;devtools_page&quot;: &quot;devtools.html&quot;
}
</code></pre>
<h4 id="sample">Sample</h4>
<p>匹配不同的 url 执行不同的脚本</p>
<pre><code>{
    &quot;name&quot;: &quot;自动预约&quot;,
    &quot;version&quot;: &quot;1.0&quot;,
    &quot;description&quot;: &quot;sede.administracionespublicas&quot;,
    &quot;permissions&quot;: [&quot;tabs&quot;,&quot;activeTab&quot;,&quot;declarativeContent&quot;,&quot;storage&quot;],
    &quot;background&quot;: {
      &quot;scripts&quot;: [&quot;background.js&quot;],
      &quot;persistent&quot;: false
    },
    &quot;browser_action&quot;: {
        &quot;default_popup&quot;: &quot;popup.html&quot;
      },
      &quot;content_scripts&quot;: [
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas/icpplustiem/index.html&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_index.js&quot;]
        },{
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas/icpplustiem/citar*&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_citar.js&quot;]
        },
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas/icpplustiem/acInfo&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_acinfo.js&quot;]
        },
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas./icpplustiem/acEntrada&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_acentrada.js&quot;]
        },
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas/icpplustiem/acValidarEntrada&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_acvalidar.js&quot;]
        },
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas.gob.es/icpplustiem/acCitar&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_acCitar.js&quot;]
        },
        {
          &quot;matches&quot;: [&quot;https://sede.administracionespublicas.gob.es/icpplustiem/acVerFormulario&quot;],
          &quot;run_at&quot;: &quot;document_end&quot;,
          &quot;js&quot;: [&quot;autofill_acVerFormulario.js&quot;]
        }
      ],
    &quot;manifest_version&quot;: 2
  }

</code></pre>
<figure data-type="image" tabindex="1"><img src="https://developer-chrome-com.imgix.net/image/BrQidfK9jaQyIHwdw91aVpkPiib2/CNDAVsTnJeSskIXVnSQV.png?auto=format&amp;w=400" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="2"><img src="https://developer-chrome-com.imgix.net/image/BrQidfK9jaQyIHwdw91aVpkPiib2/466ftDp0EXB4E1XeaGh0.png?auto=format&amp;w=400" alt="和其它组件通信" loading="lazy"></figure>
<h3 id="content-scripts">Content Scripts</h3>
<blockquote></blockquote>
<p>Content scripts are files that run in the context of web pages. By using the standard Document Object Model (DOM), they are able to read details of the web pages the browser visits, make changes to them and pass information to their parent extension.</p>
<p><a href="https://developer.chrome.com/docs/extensions/mv2/content_scripts/"><code>Content Scripts</code></a> 是实现插件的拓展能力非常重要的一部分， Contents Scripts 让我们通过操作 DOM 来实现对页面动态/静态地注入 JS CSS。<br>
Contents Scripts 和原生页面共享 DOM 但是不共享 JS（无法修改原始 JS），使用的 API 也比较有限，但可以通过和权限更高的<code>background scripts</code>通讯来实现。</p>
<pre><code>{
	// 需要直接注入页面的JS
	&quot;content_scripts&quot;: 
	[
		{
			//&quot;matches&quot;: [&quot;http://*/*&quot;, &quot;https://*/*&quot;],
			// &quot;&lt;all_urls&gt;&quot; 表示匹配所有地址
			&quot;matches&quot;: [&quot;&lt;all_urls&gt;&quot;],
			// 多个JS按顺序注入
			&quot;js&quot;: [&quot;js/jquery-1.8.3.js&quot;, &quot;js/content-script.js&quot;],
			// 注入 css
			&quot;css&quot;: [&quot;css/custom.css&quot;],
			// 代码注入的时间，可选值： &quot;document_start&quot;, &quot;document_end&quot;, or &quot;document_idle&quot;，默认document_idle
			&quot;run_at&quot;: &quot;document_start&quot;
		}
	],
}
</code></pre>
<p>Content Scripts 可以直接使用的 API：</p>
<ul>
<li>i18n</li>
<li>storage</li>
<li>runtime:
<ul>
<li>connect</li>
<li>getManifest</li>
<li>getURL</li>
<li>id</li>
<li>onConnect</li>
<li>onMessage</li>
<li>sendMessage</li>
</ul>
</li>
</ul>
<h2 id="background-scripts">background scripts</h2>
<p><a href="https://developer.chrome.com/docs/extensions/mv2/background_pages/"><code>background scripts</code></a> 是插件的事件处理中心，会在有任务的时候尽可能长时间地运行在后台，用来监听一些重要的事件（插件被安装、导航页被打开、Tab 被打开、Tab被跳转以及 contents scripts 传过来的事件等等），还可以进行一些类似 Tab 创建/跳转的操作，权限也较大。</p>
<pre><code>{
  &quot;name&quot;: &quot;Awesome Test Extension&quot;,
  ...
  &quot;background&quot;: {
    &quot;scripts&quot;: [&quot;background.js&quot;],
    &quot;persistent&quot;: false
  },
  ...
}
</code></pre>
<p>注册 Listener Sample</p>
<pre><code>//插件安装了后注册一个监听右键选中文本的事件 (比如选中本文后右键可以通过 Google 搜索 “xxx”)
chrome.runtime.onInstalled.addListener(function() {
  chrome.contextMenus.create({
    &quot;id&quot;: &quot;sampleContextMenu&quot;,
    &quot;title&quot;: &quot;Sample Context Menu&quot;,
    &quot;contexts&quot;: [&quot;selection&quot;]
  });
});

// This will run when a bookmark is created.
chrome.bookmarks.onCreated.addListener(function() {
  // do something
});

</code></pre>
<h3 id="communication-between-pages-storage-message-passing">Communication between pages  &amp; Storage &amp; Message passing</h3>
<p>插件间不同组件通信可以通过几个方法来实现</p>
<ul>
<li><code>chrome.extension</code>  API 下的 getViews() getBackgroundPage()...</li>
<li><code>storage</code> API  HTML5 <code>web storage API</code></li>
<li><code>message passing</code></li>
</ul>
<h4 id="storage-api">Storage API</h4>
<p>关于 <a href="https://developer.chrome.com/docs/apps/app_storage/">Storage API</a> 有很多内容，这里主要介绍常用的的 <a href="https://developer.chrome.com/docs/extensions/reference/storage/">LocalStorage API</a></p>
<p>使用 <code>chrome.storage.sync.*</code>存储的数据会同步到其它登录过的设备</p>
<pre><code>chrome.storage.sync.set({key: value}, function() {
  console.log('Value is set to ' + value);
});

chrome.storage.sync.get(['key'], function(result) {
  console.log('Value currently is ' + result.key);
});
</code></pre>
<p>使用<code>chrome.storage.local.*</code>  存储的数据只会存储在本地</p>
<pre><code>chrome.storage.local.set({key: value}, function() {
  console.log('Value is set to ' + value);
});

chrome.storage.local.get(['key'], function(result) {
  console.log('Value currently is ' + result.key);
});

监听数据的变化
</code></pre>
<pre><code>chrome.storage.onChanged.addListener(function(changes, namespace) {
  for (var key in changes) {
    var storageChange = changes[key];
    console.log('Storage key &quot;%s&quot; in namespace &quot;%s&quot; changed. ' +
                'Old value was &quot;%s&quot;, new value is &quot;%s&quot;.',
                key,
                namespace,
                storageChange.oldValue,
                storageChange.newValue);
  }
});
</code></pre>
<h3 id="message-passing">Message passing</h3>
<p>由于 contents scripts 的当前的 web page 而不是整个插件，所以通过 web page context 所能获取的信息/权限有限。这时需要使用各类消息机制来传递消息。</p>
<p><a href="https://developer.chrome.com/docs/extensions/mv3/messaging/">Message passing</a>有多种方式：</p>
<ul>
<li>Simple one-time requests</li>
<li>Long-lived connections</li>
<li>Cross-extension messaging</li>
<li>Native messaging</li>
</ul>
<p>这里主要介绍常用的 <code>Simple one-time requests</code></p>
<h4 id="simple-one-time-requests-简单的一次性消息">Simple one-time requests 简单的一次性消息</h4>
<p>简单的插件内部消息可以通过  <code>runtime.sendMessage</code> or <code>tabs.sendMessage</code> 发送一次性 JSON-serializable 消息来实现。</p>
<p>从<code>content scripts</code> 发送到 extension (如<code>background.js</code>)</p>
<pre><code>chrome.runtime.sendMessage({greeting: &quot;hello&quot;}, function(response) {
  console.log(response.farewell);
});
</code></pre>
<p>从 extension（比如 <code>background.js</code>）发送到 <code>content scripts</code></p>
<pre><code>//也可以传 null 不指定 tabId
chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
  chrome.tabs.sendMessage(tabs[0].id, {greeting: &quot;hello&quot;}, function(response) {
    console.log(response.farewell);
  });
});
</code></pre>
<p>接收消息，此外如果多个页面都监听了消息，只有第一个调用 <code>sendResponse</code>的会成功发送。</p>
<pre><code>chrome.runtime.onMessage.addListener(
  function(request, sender, sendResponse) {
    console.log(sender.tab ?
                &quot;from a content script:&quot; + sender.tab.url :
                &quot;from the extension&quot;);
    if (request.greeting == &quot;hello&quot;)
      sendResponse({farewell: &quot;goodbye&quot;});
  }
);
</code></pre>
<h3 id="permission-api">Permission &amp; API</h3>
<p>类似 app ,使用 chrome API 的时候需要在 manifest.json 申明相关权限。</p>
<h5 id="比较常用用的一些api系列">比较常用用的一些API系列：</h5>
<ul>
<li>chrome.tabs</li>
<li>chrome.runtime</li>
<li>chrome.webRequest</li>
<li>chrome.window</li>
<li>chrome.storage</li>
<li>chrome.contextMenus</li>
<li>chrome.devtools</li>
<li>chrome.extension</li>
</ul>
<h5 id="权限列表参考">权限列表参考</h5>
<ul>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/declare_permissions/">Permission</a></li>
<li><a href="https://developer.chrome.com/docs/extensions/reference/">API</a></li>
</ul>
<h2 id="ui-交互部分">UI 交互部分</h2>
<p><a href="https://developer.chrome.com/docs/extensions/mv3/user_interface/">Design the user interface</a></p>
<h3 id="popup">Popup</h3>
<figure data-type="image" tabindex="3"><img src="https://developer-chrome-com.imgix.net/image/BrQidfK9jaQyIHwdw91aVpkPiib2/JVduBMXnyUorfNjFZmue.png?auto=format&amp;w=300" alt="" loading="lazy"></figure>
<p>是一个点击右上角工具栏图标后弹出一个页面，（通过<a href="https://developer.chrome.com/docs/extensions/reference/browserAction/"><code>chrome.browserAction</code></a> 配置）也是 chrome.browserAction 重要的一个配置。可以用来做成提供给用户对插件进行配置的窗口。</p>
<h5 id="通过-browser-action-or-page-action-来注册-popup">通过 browser action or page action 来注册 popup</h5>
<pre><code>{
  &quot;name&quot;: &quot;Drink Water Event&quot;,
  ...
  &quot;browser_action&quot;: {
    &quot;default_popup&quot;: &quot;popup.html&quot;
  }
  ...
}
</code></pre>
<p>也可以通过 <code>browserAction.setPopup</code> or <code>pageAction.setPopup</code> 动态设置</p>
<pre><code>chrome.storage.local.get('signed_in', function(data) {
  if (data.signed_in) {
    chrome.browserAction.setPopup({popup: 'popup.html'});
  } else {
    chrome.browserAction.setPopup({popup: 'popup_sign_in.html'});
  }
});
</code></pre>
<h3 id="notification">Notification</h3>
<p>全局弹窗使用可以 Chrome Notification 或 HTML5 Notification<br>
当前页面可以用原生 <code>alert('msg')</code></p>
<pre><code>chrome.notifications.create(null, {
	type: 'basic',
	iconUrl: 'img/icon.png',
	title: 'title',
	message: 'msg'
});
</code></pre>
<h3 id="context-menu">Context menu</h3>
<p>上下文菜单：显示在选中文字后的右键的菜单</p>
<figure data-type="image" tabindex="4"><img src="https://developer-chrome-com.imgix.net/image/BrQidfK9jaQyIHwdw91aVpkPiib2/LhrliaEhN82maJmeNp7f.png?auto=format&amp;w=400" alt="" loading="lazy"></figure>
<p>需要在 background.js 下创建，其中 title 中如果放的是数组的话，那么会显示二级菜单。</p>
<pre><code>chrome.runtime.onInstalled.addListener(function() {
  for (let key of Object.keys(kLocales)) {
    chrome.contextMenus.create({
      id: key,
      title: kLocales[key],
      type: 'normal',
      contexts: ['selection'],
    });
  }
});

const kLocales = {
  'com.au': 'Australia',
  'com.br': 'Brazil',
  'ca': 'Canada',
  'cn': 'China',
  'fr': 'France',
  'it': 'Italy',
  'co.in': 'India',
  'co.jp': 'Japan',
  'com.ms': 'Mexico',
  'ru': 'Russia',
  'co.za': 'South Africa',
  'co.uk': 'United Kingdom'
};
</code></pre>
<h3 id="commands">Commands</h3>
<p>用来注册快捷键和相关的命令</p>
<pre><code>{
  &quot;name&quot;: &quot;Tab Flipper&quot;,
  ...
  &quot;commands&quot;: {
    &quot;flip-tabs-forward&quot;: {
      &quot;suggested_key&quot;: {
        &quot;default&quot;: &quot;Ctrl+Shift+Right&quot;,
        &quot;mac&quot;: &quot;Command+Shift+Right&quot;
      },
      &quot;description&quot;: &quot;Flip tabs forward&quot;
    },
    &quot;flip-tabs-backwards&quot;: {
      &quot;suggested_key&quot;: {
        &quot;default&quot;: &quot;Ctrl+Shift+Left&quot;,
        &quot;mac&quot;: &quot;Command+Shift+Left&quot;
      },
      &quot;description&quot;: &quot;Flip tabs backwards&quot;
    }
  }
  ...
}
</code></pre>
<h3 id="override-pages">Override pages</h3>
<p>用来覆盖 新Tab、历史记录、标签页这三种页面的任意一种。</p>
<pre><code>{
  &quot;name&quot;: &quot;Awesome Override Extension&quot;,
  ...

  &quot;chrome_url_overrides&quot; : {
    &quot;newtab&quot;: &quot;override_page.html&quot; //or history or bookmarks
  },
  ...
}
</code></pre>
<ul>
<li><a href="https://developer.chrome.com/docs/extensions/reference/"> API </a></li>
<li><a href="https://github.com/GoogleChrome/chrome-extensions-samples"> Samples </a></li>
</ul>
<h3 id="打包-发布">打包 &amp; 发布</h3>
<p>插件可以在扩展程序页面（chrome://extensions/）选择<code>打包扩展程序</code>打包为 .crx 文件进行发布（需要注册成开发者），一般自用的话打开开发者模式选择<code>加载已解压的扩展程序</code>选择文件夹即可。</p>
<h3 id="manifest-v3">Manifest V3</h3>
<p>刚推出的新版本 <a href="https://developer.chrome.com/docs/extensions/mv3/intro/">Manifest V3</a> 主要是一些 API 的变更，v2也可以继续使用。</p>
<h3 id="总结">总结</h3>
<p>对于 Chrome Extensions 开发我也还在学习中，以上主要总结了常用且重要的配置、特性和 API ，还有很多其它 API 可以参考文档，<br>
官方文档没有中文，但也写的很简洁易懂，官方 sample 更是详尽，几乎所有的 API 都有相应的 sample，建议参考。</p>
<ul>
<li><a href="https://developer.chrome.com/docs/extensions/mv3/">chrome-extensions-mv3</a></li>
<li><a href="https://github.com/GoogleChrome/chrome-extensions-samples">chrome-extensions-samples</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Android 10(Q)/11(R) 分区存储适配]]></title>
        <id>https://xiejinpeng007.github.io/post/android-scoped-storage/</id>
        <link href="https://xiejinpeng007.github.io/post/android-scoped-storage/">
        </link>
        <updated>2020-09-10T07:26:50.000Z</updated>
        <content type="html"><![CDATA[<p>大部分应用都会请求 ( READ_EXTERNAL_STORAGE ) ( WRITE_EXTERNAL_STORAGE ) 存储权限，来做一些诸如在 SD 卡中存储文件或者读取多媒体文件等常规操作。这些应用可能会在磁盘中存储大量文件，即使应用被卸载了还会依然存在。另外，这些应用还可能会读取其他应用的一些敏感文件数据。</p>
<p>为此，Google 终于下定决心在 Android 10 中引入了分区存储，对权限进行场景的细分，按需索取，并在 Android 11 中进行了进一步的调整。</p>
<h2 id="android-存储分区情况">Android 存储分区情况</h2>
<p>Android 中存储可以分为两大类：私有存储和共享存储</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：
<ul>
<li>内部存储私有目录<code>(/data/data/packageName)</code> ；</li>
<li>外部存储私有目录 <code>(/sdcard/Android/data/packageName)</code>，</li>
</ul>
</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。</li>
</ul>
<h2 id="android-10q-行为变更">Android 10(Q) 行为变更：</h2>
<p>Android 10 中主要对<code>共享目录</code>进行了权限详细的划分，不再能通过绝对路径访问。</p>
<p>受影响的接口：</p>
<figure data-type="image" tabindex="1"><img src="https://xiejinpeng007.github.io/post-images/1597822089838.png" alt="" loading="lazy"></figure>
<h3 id="访问不同分区的方式">访问不同分区的方式：</h3>
<ol>
<li>私有目录：和以前的版本一致，可通过 <code>File()</code> API 访问，无需申请权限。</li>
<li>共享目录：需要通过<code>MediaStore</code>和<code>Storage Access Framework</code> API 访问，视具体情况申请权限，下面详细介绍。</li>
</ol>
<p>其中，对共享目录的权限进行了细分：</p>
<ol>
<li>
<p>无需申请权限的操作：<br>
通过 <code>MediaStore API</code>对媒体集、文件集进行媒体/文件的添加、对 <strong>自身APP</strong> 创建的 媒体/文件 进行查询、修改、删除的操作。</p>
</li>
<li>
<p>需要申请<code>READ_EXTERNAL_STORAGE</code>权限：<br>
通过 <code>MediaStore API</code>对所有的媒体集进行查询、修改、删除的操作。</p>
</li>
<li>
<p>调用 <code>Storage Access Framework API</code> ：<br>
会启动系统的文件选择器向用户申请操作指定的文件</p>
</li>
</ol>
<p>新的访问方式：</p>
<figure data-type="image" tabindex="2"><img src="https://xiejinpeng007.github.io/post-images/1597822101677.png" alt="" loading="lazy"></figure>
<h2 id="android-11-r-行为变更">Android 11 (R) 行为变更 :</h2>
<p>Android 11 (R) 在 Android 10 (Q) 中分区存储的基础上进行了调整</p>
<h3 id="1-新增执行批量操作">1. 新增执行批量操作</h3>
<blockquote>
<p>为实现各种设备之间的一致性并增加用户便利性，Android 11 向 MediaStore API 中添加了多种方法。对于希望简化特定媒体文件更改流程（例如在原位置编辑照片）的应用而言，这些方法尤为有用。</p>
</blockquote>
<p>MediaStore API 新增的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>createWriteRequest (ContentResolver, Collection)</td>
<td>用户向应用授予对指定媒体文件组的写入访问权限的请求。</td>
</tr>
<tr>
<td>createFavoriteRequest (ContentResolver, Collection, boolean)</td>
<td>用户将设备上指定的媒体文件标记为 “收藏” 的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为 “收藏”。</td>
</tr>
<tr>
<td>createTrashRequest (ContentResolver, Collection, boolean)</td>
<td>用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。</td>
</tr>
<tr>
<td>createDeleteRequest (ContentResolver, Collection)</td>
<td>用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</td>
</tr>
</tbody>
</table>
<p>系统在调用以上任何一个方法后，会构建一个 PendingIntent 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。</p>
<h3 id="2-使用直接文件路径和原生库访问文件">2. 使用直接文件路径和原生库访问文件</h3>
<blockquote>
<p>为了帮助您的应用更顺畅地使用第三方媒体库，Android 11 允许您使用除 MediaStore API 之外的 API 访问共享存储空间中的媒体文件。不过，您也可以转而选择使用以下任一 API 直接访问媒体文件：</p>
<p>File API。<br>
原生库，例如 fopen()。</p>
</blockquote>
<p>简单来说就是，可以通过 <code>File()</code> 等API 访问有权限访问的媒体集了。</p>
<h5 id="性能">性能：</h5>
<p>通过 <code>File ()</code> 等直接通过路径访问的 API 实际上也会映射为<code>MediaStore</code> API 。<br>
按文件路径顺序读取的时候性能相当；随机读取和写入的时候则会更慢，所以还是推荐直接使用 <code>MediaStore</code>API。</p>
<h3 id="3-新增权限">3. 新增权限</h3>
<p><code>MANAGE_EXTERNAL_STORAGE</code> :<br>
类似以前的 <code>READ_EXTERNAL_STORAGE</code> + <code>WRITE_EXTERNAL_STORAGE</code>，除了应用专有目录都可以访问。</p>
<p>应用可通过执行以下操作向用户请求名为所有文件访问权限的特殊应用访问权限：</p>
<ol>
<li>在清单中声明 MANAGE_EXTERNAL_STORAGE 权限。</li>
<li>使用 ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION intent 操作将用户引导至一个系统设置页面，在该页面上，用户可以为您的应用启用以下选项：授予所有文件的管理权限。</li>
</ol>
<ul>
<li>在 Google Play 上架的话，需要提交使用此权限的说明，只有指定的几种类型的 APP 才能使用。</li>
</ul>
<h2 id="sample">Sample</h2>
<ul>
<li>
<p>使用 <code>MediaStore</code> 增删改查媒体集</p>
</li>
<li>
<p>使用 <code>Storage Access Framework</code> 访问文件集</p>
</li>
</ul>
<h3 id="1-媒体集">1. 媒体集</h3>
<h4 id="1-查询媒体集需要-read_external_storage-权限">1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限）</h4>
<p>实际上 <code>MediaStore</code> 是以前就有的 API ，不同的是过去主要通过 <code>MediaStore.Video.Media._DATA</code> 这个<code>Column</code> 请求原始数据，可以得到绝对<code>Uri</code> ，现在需要请求<code>MediaStore.Video.Media._ID</code>来得到相对<code>Uri</code>再进行处理。</p>
<pre><code class="language-kotlin">// Need the READ_EXTERNAL_STORAGE permission if accessing video files that your
// app didn't create.

// Container for information about each video.
data class Video(
    val uri: Uri,
    val name: String,
    val duration: Int,
    val size: Int
)
val videoList = mutableListOf&lt;Video&gt;()

val projection = arrayOf(
    MediaStore.Video.Media._ID,
    MediaStore.Video.Media.DISPLAY_NAME,
    MediaStore.Video.Media.DURATION,
    MediaStore.Video.Media.SIZE
)

// Show only videos that are at least 5 minutes in duration.
val selection = &quot;${MediaStore.Video.Media.DURATION} &gt;= ?&quot;
val selectionArgs = arrayOf(
    TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES).toString()
)

// Display videos in alphabetical order based on their display name.
val sortOrder = &quot;${MediaStore.Video.Media.DISPLAY_NAME} ASC&quot;

val query = ContentResolver.query(
    MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
    projection,
    selection,
    selectionArgs,
    sortOrder
)
query?.use { cursor -&gt;
    // Cache column indices.
    val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)
    val nameColumn =
            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)
    val durationColumn =
            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)
    val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)

    while (cursor.moveToNext()) {
        // Get values of columns for a given video.
        val id = cursor.getLong(idColumn)
        val name = cursor.getString(nameColumn)
        val duration = cursor.getInt(durationColumn)
        val size = cursor.getInt(sizeColumn)

        val contentUri: Uri = ContentUris.withAppendedId(
            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
            id
        )

        // Stores column values and the contentUri in a local object
        // that represents the media file.
        videoList += Video(contentUri, name, duration, size)
    }
}

</code></pre>
<h4 id="2插入媒体集无需权限">2）插入媒体集（无需权限）</h4>
<pre><code class="language-kotlin">// Add a media item that other apps shouldn't see until the item is
// fully written to the media store.
val resolver = applicationContext.contentResolver

// Find all audio files on the primary external storage device.
// On API &lt;= 28, use VOLUME_EXTERNAL instead.
val audioCollection = MediaStore.Audio.Media
        .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)

val songDetails = ContentValues().apply {
    put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Workout Playlist.mp3&quot;)
    put(MediaStore.Audio.Media.IS_PENDING, 1)
}

val songContentUri = resolver.insert(audioCollection, songDetails)

resolver.openFileDescriptor(songContentUri, &quot;w&quot;, null).use { pfd -&gt;
    // Write data into the pending audio file.
}

// Now that we're finished, release the &quot;pending&quot; status, and allow other apps
// to play the audio track.
songDetails.clear()
songDetails.put(MediaStore.Audio.Media.IS_PENDING, 0)
resolver.update(songContentUri, songDetails, null, null)
</code></pre>
<h4 id="3更新自己创建的媒体集无需权限">3）更新自己创建的媒体集（无需权限）</h4>
<p>删除类似</p>
<pre><code class="language-kotlin">// Updates an existing media item.
val mediaId = // MediaStore.Audio.Media._ID of item to update.
val resolver = applicationContext.contentResolver

// When performing a single item update, prefer using the ID
val selection = &quot;${MediaStore.Audio.Media._ID} = ?&quot;

// By using selection + args we protect against improper escaping of // values.
val selectionArgs = arrayOf(mediaId.toString())

// Update an existing song.
val updatedSongDetails = ContentValues().apply {
    put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Favorite Song.mp3&quot;)
}

// Use the individual song's URI to represent the collection that's
// updated.
val numSongsUpdated = resolver.update(
        myFavoriteSongUri,
        updatedSongDetails,
        selection,
        selectionArgs)
</code></pre>
<h4 id="4更新删除其它媒体创建的媒体集">4）更新/删除其它媒体创建的媒体集</h4>
<p>若已经开启分区存储则会抛出 <code>RecoverableSecurityException</code>，捕获并通过<code>SAF</code>请求权限</p>
<pre><code class="language-kotlin">// Apply a grayscale filter to the image at the given content URI.
try {
    contentResolver.openFileDescriptor(image-content-uri, &quot;w&quot;)?.use {
        setGrayscaleFilter(it)
    }
} catch (securityException: SecurityException) {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
        val recoverableSecurityException = securityException as?
            RecoverableSecurityException ?:
            throw RuntimeException(securityException.message, securityException)

        val intentSender =
            recoverableSecurityException.userAction.actionIntent.intentSender
        intentSender?.let {
            startIntentSenderForResult(intentSender, image-request-code,
                    null, 0, 0, 0, null)
        }
    } else {
        throw RuntimeException(securityException.message, securityException)
    }
}

</code></pre>
<h3 id="2-文件集-通过-saf">2. 文件集 （通过 SAF）</h3>
<h4 id="1创建文档">1）创建文档</h4>
<p>注：创建操作若重名的话不会覆盖原文档，会添加 (1) 最为后缀，如 document.pdf -&gt; document(1).pdf</p>
<pre><code class="language-kotlin">// Request code for creating a PDF document.
const val CREATE_FILE = 1

private fun createFile(pickerInitialUri: Uri) {
    val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = &quot;application/pdf&quot;
        putExtra(Intent.EXTRA_TITLE, &quot;invoice.pdf&quot;)

        // Optionally, specify a URI for the directory that should be opened in
        // the system file picker before your app creates the document.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }
    startActivityForResult(intent, CREATE_FILE)
}
</code></pre>
<h4 id="2打开文档">2）打开文档</h4>
<p>建议使用 type 设置 MIME 类型</p>
<pre><code class="language-kotlin">// Request code for selecting a PDF document.
const val PICK_PDF_FILE = 2

fun openFile(pickerInitialUri: uri) {
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = &quot;application/pdf&quot;

        // Optionally, specify a URI for the file that should appear in the
        // system file picker when it loads.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }

    startActivityForResult(intent, PICK_PDF_FILE)
}
</code></pre>
<h4 id="3授予对目录内容的访问权限">3）授予对目录内容的访问权限</h4>
<p>用户选择目录后，可访问该目录下的所有内容</p>
<p><em><strong>Android 11 中无法访问 Downloads</strong></em></p>
<pre><code class="language-kotlin">fun openDirectory(pickerInitialUri: Uri) {
    // Choose a directory using the system's file picker.
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply {
        // Provide read access to files and sub-directories in the user-selected
        // directory.
        flags = Intent.FLAG_GRANT_READ_URI_PERMISSION

        // Optionally, specify a URI for the directory that should be opened in
        // the system file picker when it loads.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }

    startActivityForResult(intent, your-request-code)
}
</code></pre>
<h4 id="4永久获取目录访问权限">4）永久获取目录访问权限</h4>
<p>上面提到的授权是临时性的，重启后则会失效。可以通过下面的方法获取相应目录永久性的权限</p>
<pre><code class="language-kotlin">val contentResolver = applicationContext.contentResolver

val takeFlags: Int = Intent.FLAG_GRANT_READ_URI_PERMISSION or
        Intent.FLAG_GRANT_WRITE_URI_PERMISSION
// Check for the freshest data.
contentResolver.takePersistableUriPermission(uri, takeFlags)
</code></pre>
<h4 id="5saf-api-响应">5）SAF API 响应</h4>
<p><code>SAF API</code> 调用后都是通过 <code>onActivityResult</code>来相应动作</p>
<pre><code class="language-kotlin">override fun onActivityResult(
        requestCode: Int, resultCode: Int, resultData: Intent?) {
    if (requestCode == your-request-code
            &amp;&amp; resultCode == Activity.RESULT_OK) {
        // The result data contains a URI for the document or directory that
        // the user selected.
        resultData?.data?.also { uri -&gt;
            // Perform operations on the document using its URI.
        }
    }
}
</code></pre>
<h4 id="6-其它操作">6) 其它操作</h4>
<p>除了上面的操作之外，对文档其它的复制、移动等操作都是通过设置不同的 FLAG 来实现，见 <a href="https://developer.android.com/reference/android/provider/DocumentsContract.Document#COLUMN_FLAGS"><code>Document.COLUMN_FLAGS</code></a></p>
<h4 id="3-批量操作媒体集">3. 批量操作媒体集</h4>
<p>构建一个媒体集的写入操作 <code>createWriteRequest()</code></p>
<pre><code class="language-kotlin">val urisToModify = /* A collection of content URIs to modify. */
val editPendingIntent = MediaStore.createWriteRequest(contentResolver,
        urisToModify)

// Launch a system prompt requesting user permission for the operation.
startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE,
    null, 0, 0, 0)

//相应
override fun onActivityResult(requestCode: Int, resultCode: Int,
                 data: Intent?) {
    ...
    when (requestCode) {
        EDIT_REQUEST_CODE -&gt;
            if (resultCode == Activity.RESULT_OK) {
                /* Edit request granted; proceed. */
            } else {
                /* Edit request not granted; explain to the user. */
            }
    }
}
</code></pre>
<p><code>createFavoriteRequest()</code> <code>createTrashRequest()</code> <code>createDeleteRequest()</code> 同理</p>
<figure data-type="image" tabindex="3"><img src="https://xiejinpeng007.github.io/post-images/1597822142159.png" alt="批量删除图片" loading="lazy"></figure>
<h3 id="适配和兼容">适配和兼容</h3>
<p>在 targetSDK = 29 APP 中，在 <code>AndroidManifes</code> 设置 <code>requestLegacyExternalStorage=&quot;true&quot;</code> 启用兼容模式，以传统分区模式运行。</p>
<pre><code class="language-xml">   &lt;manifest ... &gt;
      &lt;!-- This attribute is &quot;false&quot; by default on apps targeting
           Android 10 or higher. --&gt;
      &lt;application android:requestLegacyExternalStorage=&quot;true&quot; ... &gt;
        ...
      &lt;/application&gt;
    &lt;/manifest&gt;
</code></pre>
<blockquote>
<p><strong>注意</strong>：如果某个应用在安装时启用了传统外部存储，则该应用会保持此模式，直到卸载为止。无论设备后续是否升级为搭载 Android 10 或更高版本，或者应用后续是否更新为以 Android 10 或更高版本为目标平台，此兼容性行为均适用。</p>
</blockquote>
<p>意思就是在新系统新安装的应用才会启用，覆盖安装会保持传统分区模式，例如：</p>
<ul>
<li>
<p>系统通过 OTA 升级到 Android 10/11</p>
</li>
<li>
<p>应用通过更新升级到 targetSdkVersion &gt;= 29</p>
</li>
</ul>
<h3 id="补充">补充</h3>
<p>Q：之前讨论过一些问题，APP 无需权限可以访问自己创建的媒体，那么系统如何进行判断？</p>
<p>A：创建媒体时系统会给媒体打上 packageName tag，应用被卸载则会清除 tag ，所以不会存在使用同样 packageName 进行欺骗的情况。</p>
<p>Q：我可以在媒体集文件夹下创建文档，就可以避开权限的问题了？</p>
<p>A：官方文档上写了只能创建相应类型的媒体/文件，具体如何限制的，没有说明。</p>
<h2 id="总结">总结</h2>
<p>从 Android 10提出分区存储之后到现在已经一年多了，所以Google 从强制推行的态度到现在  targetSDK &gt;=30 才强制启用分区存储来看，Google 还是渐渐地选择给开发者留更多的时间。缺点当然是不强制启用的话，国内 APP 适配进度估计得延后了。不过好消息是在查资料的时候，看到了国内大厂的相关适配文章，至少说明大厂在跟进了。</p>
<p>去年（19年）的文档描述是无论 targetSDK 多少，明年（20年）高版本强制启用。</p>
<figure data-type="image" tabindex="4"><img src="https://xiejinpeng007.github.io/post-images/1597822164995.png" alt="" loading="lazy"></figure>
<p>今年（20）文档描述是 targetSDK &gt;=30 才强制启用</p>
<figure data-type="image" tabindex="5"><img src="https://xiejinpeng007.github.io/post-images/1597822174244.png" alt="" loading="lazy"></figure>
<h5 id="关于适配的难度">关于适配的难度：</h5>
<p>对绝对路径相关接口依赖比较深的 APP 适配还是改动挺多的；其次权限的划分很细，什么时候需要什么权限以及调用哪个接口，理解起来需要一定时间；<code>MediaStore API</code>  <code>SAF API</code> 这类接口以前就设计好了，我也觉得也不算特别友好；最后测试也需要重新进行。</p>
<p>所以虽然明年才会强制执行分区存储，但还是建议尽早理解和 review 项目中需要适配的代码。</p>
<h5 id="参考文档">参考文档：</h5>
<ul>
<li>
<p><a href="https://developer.android.com/preview/privacy/storage">https://developer.android.com/preview/privacy/storage (Android 11 中的存储机制更新)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/shared/documents-files">https://developer.android.com/training/data-storage/shared/documents-files (从共享存储空间访问文档和其他文件)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/files/external-scoped?hl=zh-cn">https://developer.android.com/training/data-storage/files/external-scoped?hl=zh-cn (管理分区外部存储访问)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/guide/topics/providers/document-provider">https://developer.android.com/guide/topics/providers/document-provider (使用存储访问框架打开文件)</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/6844904063432130568">https://juejin.im/post/6844904063432130568 (Android 10 分区存储介绍及百度APP适配实践)</a></p>
</li>
<li>
<p><a href="https://github.com/android/storage-samples">https://github.com/android/storage-samples</a></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebRTC 原理和网络视频通话的实现(Android+服务器端)]]></title>
        <id>https://xiejinpeng007.github.io/post/webrtc/</id>
        <link href="https://xiejinpeng007.github.io/post/webrtc/">
        </link>
        <updated>2020-05-14T06:07:05.000Z</updated>
        <content type="html"><![CDATA[<p>近期由于疫情原因，国内外线上会议使用率攀升，很多公司都推出了相关服务， Google 也把本来付费会议服务 Meeting 变为免费，实际上现在很多的网络视频软件都使用到了 WebRTC 这个核心的技术。<br>
之前调查过一个摄像头监控功能的 App ，也用到了 WebRTC 相关的技术，于是做成了一个可以视频通话的客户端和服务器端，并做了一些技术的总结分享一下。</p>
<h3 id="简介">简介：</h3>
<blockquote>
<p>WebRTC（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。</p>
</blockquote>
<p>虽然叫 WebRTC ，实际上目前主流浏览器和操作系统都已经支持了相关API。它通过点对点（Point-to-Point）的方式进行通话，但也需要信令服务器来进行相关配置信息的交换。</p>
<p><em><strong>注：下面的原理介绍和 demo 实现，都按照最标准易懂的流程来设计，实际的业务开发会根据情况进行调整。</strong></em></p>
<h3 id="原理">原理：</h3>
<h4 id="基本的图示">基本的图示：</h4>
<p><img src="https://xiejinpeng007.github.io/post-images/1589436796971.png" alt="simple_arch" loading="lazy"><br>
从上图可以看AB互相呼叫的相关流程需要通过信令服务器中转，而视频/音频等流量数据是点对点直接传输的。</p>
<h4 id="重要-api-和相关协议">重要 API 和相关协议：</h4>
<ul>
<li>Network Stream API</li>
<li>MediaStream：MediaStream 用来表示一个媒体数据流。</li>
<li>MediaStreamTrack 在浏览器中表示一个媒体源。</li>
<li>RTCPeerConnection</li>
<li>RTCPeerConnection：一个RTCPeerConnection对象允许用户在两个终端之间直接通讯。</li>
<li>RTCIceCandidate：表示一个ICE协议的候选者。</li>
<li>RTCIceServer：表示一个ICE Server。</li>
<li>Peer-to-peer Data API</li>
<li>DataChannel：数据通道（DataChannel）接口表示一个在两个节点之间的双向的数据通道。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#SDP">Session Description Protocol</a> :一种用于描述在设备之间共享媒体的连接的数据格式.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ICE">Interactive Connectivity Establishment (ICE) </a>: 一个用于网络穿透的框架，其中使用 TURN/STUN 服务来实现。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#STUN">Session Traversal Utilities for NAT (STUN)</a>: 用于获取公网地址的协议<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858590133.png" alt="" loading="lazy"></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#TURN">Traversal Using Relays around NAT (TURN) </a>: 用于中继数据的协议</li>
<li></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://xiejinpeng007.github.io/post-images/1589858577167.png" alt="" loading="lazy"></figure>
<h4 id="建立连接的基本流程">建立连接的基本流程：</h4>
<ol>
<li>两端进行相关初始化（Socket 、ICE、流媒体等的配置）</li>
<li>A： 发起呼叫:创建用于连接的 <code>PeerConnection(PC)</code> 和自己的配置文件 <code>SessionDescription(SDP)</code><br>
将 SDP 设置为 LocalDescription ,然后通过信令服务器将 SDP 转发给 B ,这个流程称之为 Offer 。</li>
<li>B 收到 SDP 后设置为 RemoteDescription ,创建自己的 SDP ，设置为 LocalDescription,然后通过信令服务器将 SDP 转发 给 A,这个过程称之为 Answer。</li>
<li>A 收到 SDP 后设置为 RemoteDescription</li>
<li>在初始化时会进行 ICE 服务的配置，所以 ICE 服务成功后有回调，A B 在回调后将 ICE 的配置发送给对方，收到后分别设置到 ICE 配置中，则会进行最终的连接。</li>
<li>连接成功后若已设置 DataChannel MediaStream ...等配置，那么相关回调会执行，此时即可获取数据。</li>
</ol>
<p>期间，因为需要点对点的通信，而在公网上由于 NAT/firewalls 的限制，无法直接进行通讯，所以需要使用 ICE 框架来进行，ICE 框架内部使用 STUN / TURN 协议来实现。</p>
<ul>
<li>STUN： 上面已经解释了是用于获取公网IP的服务，Google 也提供了公共的服务器 <code>stun:stun.l.google.com:19302</code></li>
<li>TURN： 主要是用于客户端即使知道了互相的 IP ，由于 Symmetric NAT 的限制无法直接建立连接时用于转发媒体流数据的服务，这个一般来说需要自己搭建。</li>
</ul>
<h3 id="android-客户端的实现">Android 客户端的实现</h3>
<p>客户端的功能包括了自定义服务器地址连接服务器、查看在线设备、选择设备进行视频通话</p>
<p>依赖库中 Webrtc 使用 Google 官方提供的， 服务器端和 Android 端使用了同样的 Socket 库，若服务器端没有什么限制推荐使用 OkHttp 自带的 Socket 通信功能。</p>
<pre><code>    implementation 'org.webrtc:google-webrtc:1.0.28513'
    implementation 'com.github.nkzawa:socket.io-client:0.4.2'

</code></pre>
<h4 id="webrtcclient-的初始化">WebRtcClient 的初始化</h4>
<pre><code>    init {
        //初始化 PeerConnectionFactory 配置
        PeerConnectionFactory.initialize(
            PeerConnectionFactory
                .InitializationOptions
                .builder(app)
                .createInitializationOptions()
        )
        
        //初始化视频编码/解码信息
        factory = PeerConnectionFactory.builder()
            .setVideoDecoderFactory(
                DefaultVideoDecoderFactory(eglContext)
            )
            .setVideoEncoderFactory(
                DefaultVideoEncoderFactory(
                    eglContext, true, true
                )
            )
            .createPeerConnectionFactory()

        // 初始化 Socket 通信
        val messageHandler = MessageHandler()

        try {
            socket = IO.socket(url)
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }

        socket?.on(&quot;id&quot;, messageHandler.onId)
        socket?.on(&quot;message&quot;, messageHandler.onMessage)
        socket?.on(&quot;ids&quot;, messageHandler.onIdsChanged)
        socket?.connect()

        //初始化 ICE 服务器创建 PC 时使用
        iceServers.add(PeerConnection.IceServer(&quot;stun:23.21.150.121&quot;))
        iceServers.add(PeerConnection.IceServer(&quot;stun:stun.l.google.com:19302&quot;))

        //初始化本地的 MediaConstraints 创建 PC 时使用，是流媒体的配置信息
        pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveAudio&quot;, &quot;true&quot;))
        pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveVideo&quot;, &quot;true&quot;))
        pcConstraints.optional.add(MediaConstraints.KeyValuePair(&quot;DtlsSrtpKeyAgreement&quot;, &quot;true&quot;))
    }
</code></pre>
<h4 id="开始建立连接">开始建立连接</h4>
<p>上面介绍的<code>建立连接的基本流程</code>提到了 A 呼叫 B 的话是由 A 开启 Offer 流程，由于我希望创建 PC 的时候知道自己的 id 和获取所有在线客户端，所以修改了一些流程，增加了<code>init</code> <code>readyToStream</code>的动作。</p>
<ul>
<li>初始化 Socket 连接上服务器后会返回相应 clientId, 此时进行本地摄像头的初始化和本地媒体流的初始化最后进行向服务器发送准备初始化成功的指令。</li>
</ul>
<pre><code>    private fun getVideoCapturer() =
        Camera2Enumerator(app).run {
            deviceNames.find {
                isFrontFacing(it)
            }?.let {
                createCapturer(it, null)
            } ?: throw IllegalStateException()
        }

    fun startLocalCamera(name: String, context: Context) {
        //init local media stream
        val localVideoSource = factory.createVideoSource(false)
        val surfaceTextureHelper =
            SurfaceTextureHelper.create(
                Thread.currentThread().name, eglContext
            )
        (vc as VideoCapturer).initialize(
            surfaceTextureHelper,
            context,
            localVideoSource.capturerObserver
        )
        vc.startCapture(320, 240, 60)
        localMS = factory.createLocalMediaStream(&quot;LOCALMEDIASTREAM&quot;)
        localMS?.addTrack(factory.createVideoTrack(&quot;LOCALMEDIASTREAM&quot;, localVideoSource))
        webrtcListener.onLocalStream(localMS!!)

        try {
            val message = JSONObject()
            message.put(&quot;name&quot;, name)
            socket?.emit(&quot;readyToStream&quot;, message)
        } catch (e: JSONException) {
            e.printStackTrace()
        }
    }
</code></pre>
<ul>
<li>此时已连上服务器并配置完毕，调用 <code>refreshIds</code> 获取已连接上服务器客户端，选择 id 进行呼叫</li>
</ul>
<pre><code>  //发送消息的方法
private fun sendMessage(to: String, type: String, payload: JSONObject) {
        val message = JSONObject()
        message.put(&quot;to&quot;, to)
        message.put(&quot;type&quot;, type)
        message.put(&quot;payload&quot;, payload)
        socket?.emit(&quot;message&quot;, message)
    }
    
    fun refreshIds() {
        socket?.emit(&quot;refreshids&quot;, null)
    }
    
    fun callByClientId(clientId: String) {
        sendMessage(clientId, &quot;init&quot;, JSONObject())
    }

</code></pre>
<ul>
<li><code>readyToStream</code> <code>refreshIds</code>是为了实现查看在线设备相关功能，并非 WebRTC 的标准，下面的<code>建立连接的基本流程</code>是必要的流程。<br>
接收消息后根据消息进入不同的响应流程以及具体的实现。</li>
</ul>
<pre><code>    private inner class MessageHandler {
		//建立 PC 交换 SDP ICE 等配置的事件
        val onMessage = Emitter.Listener { args -&gt;
            val data = args[0] as JSONObject
            try {
                val from = data.getString(&quot;from&quot;)
                val type = data.getString(&quot;type&quot;)
                var payload: JSONObject? = null
                if (type != &quot;init&quot;) {
                    payload = data.getJSONObject(&quot;payload&quot;)
                }
                //用于检查是否 PC 是否已存在已经是否达到最大的2个 PC 的限制
                if (!peers.containsKey(from)) {
                    val endPoint = findEndPoint()
                    if (endPoint == MAX_PEER) return@Listener
                    else addPeer(from, endPoint)
                }
                //根据不同的指令类型和数据响应相应步骤的方法
                when (type) {
                    &quot;init&quot; -&gt; createOffer(from)
                    &quot;offer&quot; -&gt; createAnswer(from, payload)
                    &quot;answer&quot; -&gt; setRemoteSdp(from, payload)
                    &quot;candidate&quot; -&gt; addIceCandidate(from, payload)
                }

            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }
        //连接上服务器会返回自己的 clientId 的事件，可开始呼叫。
        val onId = Emitter.Listener { args -&gt;
            val id = args[0] as String
            webrtcListener.onCallReady(id)
        }
		 //获取在线客户端的事件
        val onIdsChanged = Emitter.Listener { args -&gt;
            Log.d(TAG, args.toString())
            val ids = args[0] as JSONArray

            webrtcListener.onOnlineIdsChanged(ids)
        }
    }
    
    //开始 Offer 流程
    private fun createOffer(peerId: String) {
        Log.d(TAG, &quot;CreateOffer&quot;)
        val peer = peers[peerId]
        peer?.pc?.createOffer(peer, pcConstraints)
    }

	//开始 Answer 流程
    private fun createAnswer(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;CreateAnswer&quot;)
        val peer = peers[peerId]
        val sdp = SessionDescription(
            SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)),
            payload?.getString(&quot;sdp&quot;)
        )
        peer?.pc?.setRemoteDescription(peer, sdp)
        peer?.pc?.createAnswer(peer, pcConstraints)
    }

	//设置 SDP 后无需操作等待 ICE 成功后响应
    private fun setRemoteSdp(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;SetRemoteSDP&quot;)
        val peer = peers[peerId]
        val sdp = SessionDescription(
            SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)),
            payload?.getString(&quot;sdp&quot;)
        )
        peer?.pc?.setRemoteDescription(peer, sdp)
    }

	//收到 ICE  后添加到 PC
    private fun addIceCandidate(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;AddIceCandidate&quot;)
        val pc = peers[peerId]!!.pc
        if (pc!!.remoteDescription != null) {
            val candidate = IceCandidate(
                payload!!.getString(&quot;id&quot;),
                payload.getInt(&quot;label&quot;),
                payload.getString(&quot;candidate&quot;)
            )
            pc.addIceCandidate(candidate)
        }
    }
</code></pre>
<h4 id="基本流程中的一些细节补充">基本流程中的一些细节补充：</h4>
<ul>
<li>建立 PeerConnection 时需绑定本地媒体流</li>
</ul>
<pre><code>        init {
            Log.d(TAG, &quot;new Peer: $id $endPoint&quot;)
            this.pc = factory.createPeerConnection(iceServers, pcConstraints, this)
            pc?.addStream(localMS!!) //, new MediaConstraints()
            webrtcListener.onStatusChanged(&quot;CONNECTING&quot;)
        }
</code></pre>
<ul>
<li>需要实现 <code>SdpObserver</code> <code>PeerConnection.Observer</code> 接口，用于监听 PeerConnection SDP 关键的回调。</li>
</ul>
<pre><code>	// SDP 创建成功后回调，发送给服务器。
        override fun onCreateSuccess(sdp: SessionDescription) {
            // TODO: modify sdp to use pcParams prefered codecs
            try {
                val payload = JSONObject()
                payload.put(&quot;type&quot;, sdp.type.canonicalForm())
                payload.put(&quot;sdp&quot;, sdp.description)
                sendMessage(id, sdp.type.canonicalForm(), payload)
                pc!!.setLocalDescription(this@Peer, sdp)
            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }
       
       // ICE 框架获取候选者成功后的回调，发送给服务器。
        override fun onIceCandidate(candidate: IceCandidate) {
            try {
                val payload = JSONObject()
                payload.put(&quot;label&quot;, candidate.sdpMLineIndex)
                payload.put(&quot;id&quot;, candidate.sdpMid)
                payload.put(&quot;candidate&quot;, candidate.sdp)
                sendMessage(id, &quot;candidate&quot;, payload)
            } catch (e: JSONException) {
                e.printStackTrace()
            }

        }
        
        // ICE 连接状态变化时的回调
         override fun onIceConnectionChange(iceConnectionState: PeerConnection.IceConnectionState) {
            webrtcListener.onStatusChanged(iceConnectionState.name)
            Log.d(TAG, &quot;onIceConnectionChange ${iceConnectionState.name}&quot;)
            if (iceConnectionState == PeerConnection.IceConnectionState.DISCONNECTED) {
                removePeer(id)
            }
        }
 	
 	//连接成功后，最后获取到媒体流，发给 View 层进行视频/音频的播放。
       override fun onAddStream(mediaStream: MediaStream) {
            Log.d(TAG, &quot;onAddStream &quot; + mediaStream.id)
            // remote streams are displayed from 1 to MAX_PEER (0 is localStream)
            webrtcListener.onAddRemoteStream(mediaStream, endPoint + 1)
        }
	
	//媒体流断开
        override fun onRemoveStream(mediaStream: MediaStream) {
            Log.d(TAG, &quot;onRemoveStream &quot; + mediaStream.id)
            removePeer(id)
        }
        
</code></pre>
<p>在<code>onAddStream</code>中将 MediaStream 发给 View 层后 WebRtcClient 中的连接的工作基本完成。</p>
<ul>
<li>View 层中将 MediaStream 绑定到 View 中</li>
</ul>
<pre><code>	//使用 org.webrtc.SurfaceViewRenderer
        &lt;org.webrtc.SurfaceViewRenderer
            android:id=&quot;@+id/remote_renderer&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;
            
       //初始化
     override fun onCreate(savedInstanceState: Bundle?) {      
        binding.remoteRenderer.apply {
            setEnableHardwareScaler(true)
            init(eglBase.eglBaseContext, null)
        }
      }
	//绑定从 WebRtcClent 中转发 MediaStream
      override fun onAddRemoteStream(remoteStream: MediaStream, endPoint: Int) {
                    remoteStream.videoTracks[0].addSink(binding.remoteRenderer)
                }
</code></pre>
<p>此外，上面只是展示了关键步骤，但实际编码中回调较多，还是比较繁杂。<br>
完整代码参考 <a href="https://github.com/xiejinpeng007/WebRTC-Android-Server">https://github.com/xiejinpeng007/WebRTC-Android-Server</a></p>
<h3 id="信令服务器端nodejs">信令服务器端（NodeJS）</h3>
<p>负责转发信令等功能</p>
<p>部署：<br>
在 SignalServer 根目录下执行 <code>node app.js</code>  会部署在 3000 端口，并监听客户端的连接情况。<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858682056.png" alt="" loading="lazy"></p>
<h3 id="使用和演示">使用和演示</h3>
<p>输入信令服务器地址（公网和局域网皆可）连接服务器后， 根据在线用户进行呼叫，由于 STUN 服务器用了 Google 的，所以需要梯子。</p>
<ol>
<li>设定服务器地址查看在线用户</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://xiejinpeng007.github.io/post-images/1589858691023.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>选择用户进行拨号连接,可以看到成功了。<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858701140.gif" alt="" loading="lazy"></li>
</ol>
<h3 id="总结">总结</h3>
<p>优点：</p>
<ul>
<li>当然是大部分流量不经过服务器直接点对点(P2P)传输，可以大大的节省服务商的带宽资源。</li>
</ul>
<p>缺点:</p>
<ul>
<li>原生只支持1对1的通信，要实现多人通信需要借助服务端的其它方案例如中转。</li>
<li>复杂的网络场景连接质量无法保证，比如跨国等情况，也需要服务商进行优化。</li>
</ul>
<p>大多使用 WebRTC 技术的都根据具体业务都在此基础上进行了二次封装， Google 自家应用上也看到在使用相关的技术，所以总的来说 WebRTC 确实是一套实际可用的技术。</p>
<h3 id="参考">参考:</h3>
<p><a href="https://github.com/xiejinpeng007/WebRTC-Android-Server">https://github.com/xiejinpeng007/WebRTC-Android-Server</a>  (Demo)<br>
<a href="https://webrtc.github.io/webrtc-org/native-code/android/">https://webrtc.github.io/webrtc-org/native-code/android/</a><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给现有 App 引入 Flutter Module]]></title>
        <id>https://xiejinpeng007.github.io/post/add-flutter-module-to-app/</id>
        <link href="https://xiejinpeng007.github.io/post/add-flutter-module-to-app/">
        </link>
        <updated>2019-10-09T06:27:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近 Flutter 很火，相信长得帅的人都已经对它都有了初步的了解。<br>
不过由于目前默认使用 Flutter 作为框架接管整个 App 进行开发，不够灵活：一方面使用纯 Flutter 开发需要在项目开始之前仔细评估是否有难以实现的功能；另一方面现有的 App 想使用 Flutter 的话很难全部转换过去。<br>
很容易想到在现有的 App 的基础上加入 Flutter 作为部分画面/功能的实现是一个理想的方案，也更有利于做技术尝试和风险控制。<br>
实际上目前 Flutter 官方提供了两种方案用于给现有 App 加入 Flutter Module，另外还有一些第三方的方案，最近我做了一些尝试，分享一些成果。<br>
需要注意的是， 给现有 App 引入 Flutter Module 的功能还在实验性的阶段, APIs 和工具链处于未稳定阶段,且需要切换到   <code>master</code>  分支（不稳定）使用。</p>
<p>效果：<br>
<img src="https://xiejinpeng007.github.io/post-images/1570603064756.gif" alt="从原生App中打开 Flutter Module（ Fragment ）" loading="lazy"><br>
从原生App中打开 Flutter Module（ Fragment , Google Pixel3 XL ）</p>
<h2 id="android">Android</h2>
<h3 id="创建一个-flutter-module">创建一个 Flutter module</h3>
<p>假设在 <code>some/path/MyApp</code> 下是 Android 项目目录</p>
<pre><code class="language-shell">cd some/path
flutter create -t module --org com.example flutter_to_app
</code></pre>
<p>会在 <code>some/path/flutter_to_app</code>生成一个 Flutter Module</p>
<h3 id="宿主-app-设置">宿主 App 设置</h3>
<p>需要在<code>app/build.gradle</code>里设置</p>
<pre><code>android {
  //...
  compileOptions {
    sourceCompatibility 1.8
    targetCompatibility 1.8
  }
}
</code></pre>
<h3 id="让-app-依赖-flutter-module">让 App 依赖 Flutter Module</h3>
<p>有两种方案，直接依赖源代码和 aar 产物。</p>
<h4 id="1-依赖生成的-aar">1. 依赖生成的 aar</h4>
<pre><code class="language-shell">cd ~/Documents/Android/flutter_to_app
flutter build aar
</code></pre>
<pre><code>// MyApp/app/build.gradle

android {
  // ...
}

repositories {
  maven {
  //可以使用相对路径或者绝对路径
    url 'some/path/flutter_to_app/build/host/outputs/repo'
  }
}

dependencies {
  // ...
  releaseCompile ('com.example. flutter_to_app:flutter_release:1.0@aar') {
    transitive = true
  }
}
</code></pre>
<p>可以用 <code>flutter build aar --debug</code> 生成 debug 依赖</p>
<pre><code>// MyApp/app/build.gradle

dependencies {
  // ...
  debugCompile ('com.example.my_flutter:flutter_debug:1.0@aar') {
    transitive = true
  }
}
</code></pre>
<h4 id="2直接依赖源码">2.直接依赖源码</h4>
<p>依赖 aar 的方式有点麻烦，还需要到 Module 中编译，所以也可以直接依赖源码编译</p>
<p>在宿主 App <code>settings.gradle</code>加入</p>
<pre><code>// MyApp/settings.gradle
include ':app'
...                                     
setBinding(new Binding([gradle: this]))                                 
evaluate(new File(                                                     
 settingsDir.parentFile,                                                
  'flutter_to_app/.android/include_flutter.groovy'                          
))  
</code></pre>
<p>上面的<code>File()</code>路径是 flutter module 相对 host app 的路径。binding 和 <code>include_flutter.groovy</code> 脚本引入 flutter module 本身和相关的 plugin。</p>
<p>最后，依赖模块:</p>
<pre><code>// MyApp/app/build.gradle
dependencies {
  implementation project(':flutter')
}
</code></pre>
<h3 id="在-android-项目中使用-flutter-module">在 Android 项目中使用 Flutter Module</h3>
<p>目前有两种方式实现，分别在</p>
<ol>
<li><code>io.flutter.facade.*</code></li>
<li><code>io.flutter.embedding.android.*</code></li>
</ol>
<p>两个包下， 第一种已经被 deprecated ,第二种还处于 technical preview 阶段，所以两种版本的 API 都还不稳定，但可以大概看一下两种方式。</p>
<h4 id="以前的方式deprecated-ioflutterfacade">以前的方式（deprecated） ( io.flutter.facade )</h4>
<p>通过使用 <code>Flutter.createView</code>:</p>
<pre><code>fab.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
    View flutterView = Flutter.createView(
      MainActivity.this,
      getLifecycle(),
      &quot;route1&quot;
    );
    FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(600, 800);
    layout.leftMargin = 100;
    layout.topMargin = 200;
    addContentView(flutterView, layout);
  }
});
</code></pre>
<p>通过使用 <code>Flutter.createFragment</code>:</p>
<pre><code>// MyApp/app/src/main/java/some/package/SomeActivity.java
fab.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
    FragmentTransaction tx = getSupportFragmentManager().beginTransaction();
    tx.replace(R.id.someContainer, Flutter.createFragment(&quot;route1&quot;));
    tx.commit();
  }
});
</code></pre>
<p>创建<code>View</code>和<code>Fragment</code>都非常简单，但是实际测试下来，启动 View (FlutterFragment实际上也是通过 createView 来生成视图的)会有启动时间，体验没那么无缝。</p>
<h3 id="新的方式-ioflutterembeddingandroid">新的方式（ io.flutter.embedding.android.* ）</h3>
<h4 id="通过-flutterview-继承自-framelayout">通过 FlutterView ( 继承自 FrameLayout )</h4>
<pre><code>实例化 FlutterView 嵌入 Native
FlutterView flutterView = new FlutterView(this);
FrameLayout frameLayout = findViewById(R.id.framelayout);
frameLayout.addView(flutterView);
//创建一个 FlutterView 就可以了，这个时候还不会渲染。
//调用下面代码后才会渲染
flutterView.attachToFlutterEngine(flutterEngine);
</code></pre>
<p><img src="https://xiejinpeng007.github.io/post-images/1570602991085.gif" alt="直接在原生App中加入 FlutterView" loading="lazy"><br>
直接在原生App中加入 FlutterView ( Google Pixel3 XL )</p>
<h4 id="通过-flutterfragment-打开">通过 FlutterFragment 打开</h4>
<h5 id="通过-xml">通过 xml</h5>
<pre><code>	&lt;fragment
    android:id=&quot;@+id/flutterfragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:name=&quot;io.flutter.embedding.android.FlutterFragment&quot;
    /&gt;
</code></pre>
<h5 id="直接实例化">直接实例化</h5>
<pre><code>flutterFragment = new FlutterFragment.createDefault();
</code></pre>
<h4 id="通过-flutteractivity-打开">通过 FlutterActivity 打开</h4>
<h5 id="在-androidmanifestxml-中注册">在 AndroidManifest.xml 中注册</h5>
<pre><code>    &lt;activity
        android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot;
        android:theme=&quot;@style/LaunchTheme&quot;
        android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density&quot;
        android:hardwareAccelerated=&quot;true&quot;
        android:windowSoftInputMode=&quot;adjustResize&quot;
        android:exported=&quot;true&quot;
        /&gt;
</code></pre>
<h5 id="默认启动方式">默认启动方式</h5>
<pre><code>	//默认路由为 '/'
    Intent defaultFlutter = new FlutterActivity.createDefaultIntent(currentActivity);
    startActivity(defaultFlutter);
</code></pre>
<h5 id="启动到指定路由">启动到指定路由</h5>
<pre><code>    Intent customFlutter = new FlutterActivity.IntentBuilder()
      .initialRoute(&quot;someOtherRoute&quot;)
      .build(currentActivity);
    startActivity(customFlutter);
</code></pre>
<h3 id="flutterengine-缓存机制">FlutterEngine 缓存机制</h3>
<p>实际上，通过 API 和源码可以看出，新版的 Flutter 相关类<code>io.flutter.embedding.android.*</code>完全重新设计了 Native 调用的方式，从包名（embedding）就可以看出是希望嵌入 Native， 其中一个重要的变化是加入了 <code>FlutterEngine</code> 的缓存机制。<br>
通过老的方式启动 Flutter 的响应时间长包括了需要启动<code>FlutterEngine</code>的时间，可以理解为冷启动，而且从原生的不同<code>Activity / ViewController</code> 启动 Flutter 都需要启动一个新的 <code>FlutterEngine</code>，所以不仅第一次启动 Flutter 时间长 ，每次启动都会需要同样的时间。比如下面的情况</p>
<p><code>Native A -&gt; Flutter B -&gt; Native C -&gt; Flutter D</code></p>
<p>这样从<code>Native A</code> 和 <code>Native B</code>启动时会实例化两个<code>FlutterEngine</code>。<br>
<img src="https://xiejinpeng007.github.io/post-images/1570603039285.gif" alt="未使用 FlutterEngineCache 时从原生 App 启动白屏" loading="lazy"><br>
未使用 FlutterEngineCache 时从原生 App 启动白屏 ( Google Pixel3 XL )</p>
<p>这样不仅慢，对资源的开销也更多。<br>
为了解决这个问题，新的解决方案引入了<code>FlutterEngine</code> 缓存机制。</p>
<h4 id="1-使用-flutterenginecache">1. 使用 FlutterEngineCache</h4>
<pre><code>// 实例化 FlutterEngine.
FlutterEngine flutterEngine = new FlutterEngine(context);

// 预热
 flutterEngine
  .getDartExecutor()
  .executeDartEntrypoint(
    DartEntrypoint.createDefault()
  );
  
 //放入 FlutterEngineCache
  FlutterEngineCache
  .getInstance()
  .put(&quot;my_engine_id&quot;, flutterEngine);
  
  //启动 Activity 的时候使用
  Intent intent = FlutterActivity
  .withCachedEngine(&quot;my_engine_id&quot;)
  .build();
  startActivity(intent);
  
  //实例化 Fragment
  FlutterFragment flutterFragment = FlutterFragment
  .withCachedEngine(&quot;my_engine_id&quot;)
  .build();
</code></pre>
<h4 id="2-继承-flutterfragment-flutteractivity">2. 继承 FlutterFragment / FlutterActivity</h4>
<p>自行处理存储 FlutterEngine 的地方</p>
<pre><code>public class MyFlutterFragment extends FlutterFragment {
  @Override
  @Nullable
  protected FlutterEngine provideFlutterEngine(@NonNull Context context) {
    //自行存储 FlutterEngine 实例
    return MyFlutterEngine.getFlutterEngine();

    //比如 Application 中
    return ((MyApp) context.getApplication).getFlutterEngine();
  }
}
</code></pre>
<pre><code>public class MyFlutterActivity extends FlutterActivity {
  @Nullable
  @Override
  public FlutterEngine provideFlutterEngine(@NonNull Context context) {
    FlutterEngine flutterEngine;
    //自行存储 FlutterEngine 实例
    flutterEngine = MyFlutterEngineCache.getFlutterEngine();
    
    //比如 Application 中
    flutterEngine = ((MyApp) getApplication()).getFlutterEngine();

    return flutterEngine;
  }
}
</code></pre>
<h4 id="3-在-activity-实现-flutterengineprovider-接口">3. 在 Activity 实现 FlutterEngineProvider 接口</h4>
<pre><code>public class MyActivity extends Activity implements FlutterEngineProvider {
  @Override
  @Nullable
  FlutterEngine provideFlutterEngine(@NonNull Context context) {
    //自行存储 FlutterEngine 实例
    return MyFlutterEngine.getFlutterEngine();
    
    //比如 Application 中
    return ((MyApp) context.getApplication).getFlutterEngine();
  }
}
</code></pre>
<h3 id="flutterboost-方案">FlutterBoost 方案</h3>
<blockquote>
<p>新一代 Flutter-Native 混合解决方案。 FlutterBoost是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL）。</p>
</blockquote>
<p>FlutterBoost 是闲鱼开源处理 Flutter-Native 混合开发的解决方案，是一个热门的方案，但和官方方案对比我认为有两个重要的异同点：</p>
<ol>
<li>当时闲鱼设计这个库其中的一个重要目的就是为了解决 FlutterEngine 无法重用的问题（当时 Flutter 团队还没有可以处理 FlutterEngine 重用的方案），而现在 Flutter 团队推出的新的解决方案也可以解决这个问题。</li>
<li>目前 Flutter 官方的方案的细粒度更小，可以通过 View 的方式调用 Flutter ，也就是说你可以只将画面中的某一个图表用 Flutter 替换。</li>
</ol>
<p>最后，官方的两种方案一种已经被舍弃一种还处于实验性阶段，目前最新方案的<code>Milestone</code> 是12月，所以到时候再次评估可行性。而国内大厂基本上各自都有自己的解决方案，所以目前使用官方方案的话还需要仔细评估。</p>
<h2 id="ios">iOs</h2>
<p><em>WIP</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 介绍 & 开发经验总结]]></title>
        <id>https://xiejinpeng007.github.io/post/introducing-the-flutter/</id>
        <link href="https://xiejinpeng007.github.io/post/introducing-the-flutter/">
        </link>
        <updated>2019-08-22T08:05:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flutter-介绍-开发经验总结">Flutter 介绍 &amp; 开发经验总结</h1>
<h2 id="前言">前言</h2>
<p>Flutter 已经推出2年了，虽然一直在关注，但还是想等生态成熟一点再去踩坑。近期有一个需要使用跨平台技术的项目，在讨论后，我们选择使用 Flutter。开发完成之后，我这里总结一些重要的点，供大家参考。<br>
当然，要学习的话最后还是需要读一遍文档，然后自己 Coding。</p>
<h2 id="环境配置">环境配置：</h2>
<p>参考<a href="https://flutter-io.cn/docs/get-started/install/macos">官方文档</a></p>
<h2 id="dart-语言">Dart 语言</h2>
<p>Flutter 采用 Dart 语言，我使用之后的感受就是： 语法基本等于 Java + Javascript + 另外一些常见的语法，没太大学习成本，也没太大亮点，下面列一些值得一提的点。</p>
<ul>
<li>
<p>所有变量都是对象</p>
</li>
<li>
<p>静态语言</p>
</li>
<li>
<p>支持闭包</p>
</li>
<li>
<p>方法是顶级的</p>
</li>
<li>
<p>支持反射（Flutter 不支持反射）</p>
</li>
<li>
<p>没有可见性修饰符 属性/类前加<code>_</code>就是 private</p>
</li>
<li>
<p>Stream : 支持 map... 各类操作符，订阅等</p>
</li>
<li>
<p>异步：Dart 的异步操作也通过 <code>Futrue</code>（同 Javascript 中的 <code>Promise</code>） 的方式实现，也支持 <code>async</code> <code>await</code> 语法糖（自动包装为<code>Futrue</code>）。这并不是 Dart 特有的特性，网上有大量资料可以参考。</p>
</li>
<li>
<p>赋值操作符</p>
<ul>
<li>?:</li>
<li>??</li>
<li>??=</li>
</ul>
</li>
<li>
<p>可选方法参数</p>
</li>
</ul>
<pre><code> void setUser(String name,{id = '0'});
 //调用
 setUser('mario',id : '01');
</code></pre>
<ul>
<li>联级操作符</li>
</ul>
<pre><code>   var profit = Profit()
     ..fund = 'fund'
     ..profit = 'profit'
     ..profitValue = 'profitValue';
</code></pre>
<ul>
<li>dynamic 可以指代任何类型，不会进行类型检查。</li>
</ul>
<pre><code>var a = 'test';
(a as dynamic).hello();//编译器不会报错
</code></pre>
<h2 id="flutter">Flutter</h2>
<h3 id="widget-概念">Widget 概念</h3>
<blockquote>
<p>在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于APP主题数据传递的Theme等等，而原生开发中的控件通常只是指UI元素。</p>
</blockquote>
<p>我的理解为 Widget 的工作 = HTML + CSS 的工作。而且很多配置样式的属性名字和 CSS 中的名字差不多。</p>
<p>Widget 分为 <code>StatelessWidget</code> <code>StatefulWidget</code> 两种，他们的核心方法都是通过<code>build()</code>方法返回一个 Widget 。</p>
<pre><code>  @protected
  Widget build(BuildContext context);
</code></pre>
<ul>
<li><code>StatelessWidget</code> 的<code>build()</code>在 Widget 中。</li>
<li><code>StatefulWidget</code>由于必须创建相应的 <code>State&lt;T extends Widget&gt;</code> ,所以包括<code>build()</code>在内的相关生命周期方法都在<code>State</code>中。<br>
下面是<code>State</code>的生命周期，由于一个画面也是一个 Widget 所以也是一个画面的生命周期。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/widget_lifecyle.jpg?raw=true" alt="widget_lifecyle.jpg" loading="lazy"></figure>
<h3 id="widget-目录-link">Widget 目录 ( <a href="https://flutterchina.club/widgets/material/">link</a> )</h3>
<figure data-type="image" tabindex="2"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/widgets.png?raw=true" alt="widgets.png" loading="lazy"></figure>
<p>上面是官方提供的所有的 Widget，可以看到基本上所有UI相关的内容都是通过不同类型的 Widget 来实现，通过<code>child/children</code>参数进行嵌套。</p>
<h4 id="不同风格的-widget">不同风格的 Widget</h4>
<p>除了基础 Widget 外，官方提供了 Material(Android) + Cupertino(ioS) 两种视觉风格的 Widget。<br>
例如你可以在使用一个 Marterial 风格的<code>RaisedButton</code>或是 Cuptino 风格的<code>CupertinoButton</code>，再也不用担心设计师让 Android 照着 ioS 做成一样了。</p>
<h4 id="layout-widget">Layout Widget</h4>
<p>还有用来控制布局的 Layout Widget ,作为容器来使用，看名字都大概知道什么作用了。</p>
<ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
<li>Stack</li>
<li>Column</li>
<li>Row</li>
<li>Expanded</li>
<li>ListView</li>
</ul>
<h4 id="交互模型-widget">交互模型 Widget</h4>
<p>控制点击、滑动等交互的 Widget。<br>
在 Flutter 里点击事件并不是<code>setOnClickListener</code>的方式 ，而是给 Widget 外层加一层交互 Widget ，如点击可使用<code>GestureDetector</code>。<br>
例如给上面 Splash 画面中的<code>Image</code>加一个点击事件。</p>
<pre><code>  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }
  
  ==&gt;
  
  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: GestureDetector(
        onTap: () {
          //点击事件
        },
        child: Image.asset('images/logo.png'),
      ),
    );
  }
</code></pre>
<h4 id="sample">Sample</h4>
<p>所以，一个最基本的 Widget 长什么样？这是一个带有是否 login 检查的 Splash 画面。</p>
<ul>
<li>StatelessWidget</li>
</ul>
<pre><code>class SplashPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    checkLogin();
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }

// 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。
  checkLogin(BuildContext context) async {
    var sp = await SharedPreferences.getInstance();
    var token = sp.getString(&quot;X-Auth-Token&quot;);
    if (token != null &amp;&amp; token != &quot;&quot;)
      Navigator.pushNamedAndRemoveUntil(
          context, HomePage.routeName, (_) =&gt; false);
    else
      Navigator.pushNamed(context, LoginRegisterPage.routeName);
  }
}

</code></pre>
<ul>
<li>StatefulWidget</li>
</ul>
<pre><code>class SplashPage extends StatefulWidget {
  //创建相应的 State
  @override
  State createState() =&gt; _SplashState();
}

class _SplashState extends State&lt;SplashPage&gt; {
  @override
  void initState() {
    super.initState();
    checkLogin(context);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }

// 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。
  checkLogin(BuildContext context) async {
    var sp = await SharedPreferences.getInstance();
    var token = sp.getString(&quot;X-Auth-Token&quot;);
    if (token != null &amp;&amp; token != &quot;&quot;)
      Navigator.pushNamedAndRemoveUntil(
          context, HomePage.routeName, (_) =&gt; false);
    else
      Navigator.pushNamed(context, LoginRegisterPage.routeName);
  }
  
  @override
  void dispose() {
      super.dispose();
    }
}

</code></pre>
<h3 id="app-结构">App 结构</h3>
<figure data-type="image" tabindex="3"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/counterAppwidgertree.jpg?raw=true" alt="counterAppwidgertree.jpg" loading="lazy"></figure>
<p>上图是整个 Flutter App 的结构，从父节点开始分别是：</p>
<ol>
<li><code>MyApp</code>: 整个 App 的入口在<code>main.dart</code>的<code>main()</code>函数中，调用 <code>runApp(MyApp())</code>,而 MyApp 也是一个 Widget，只不过用来定义一些全局的内容，例如主题、多语言，路由</li>
<li><code>MaterialApp</code>: 一个 Material 风格的主题，对应的还有 CupertinoApp。</li>
<li><code>MyHomePage</code> <code>MyHomePageState</code> : 一个画面，也是 Widget。</li>
<li><code>Scaffold</code> : 定义了一个画面的一些基本效果，比如这里 AppBar、滑动效果等采用 Material 风格，另外还有 ioS 风格的 <code>CupertinoPageScaffold</code>。</li>
<li>剩下就是一些基本的组件。</li>
</ol>
<p>一个基本的 main.dart 大概长这样：</p>
<pre><code>void main() async {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  static final navigatorKey = GlobalKey&lt;NavigatorState&gt;();
  static NavigatorState get navigator =&gt; navigatorKey.currentState;

  @override
  Widget build(BuildContext context) {
    return  CupertinoApp(
        title: '',
        theme: CupertinoThemeData(
          primaryColor: Color(0xFFFFFFFF),
          barBackgroundColor: Color(0xFF515669),
          scaffoldBackgroundColor: Color(0xFF3C3B45),
        ),
        navigatorKey: navigatorKey,
        routes: {
          HomePage.routeName: (_) =&gt; HomePage(),
          LoginRegisterPage.routeName: (_) =&gt; LoginRegisterPage(),
          LoginPage.routeName: (_) =&gt; LoginPage(),
          ForgetPswPage.routeName: (_) =&gt; ForgetPswPage(),
          RegisterPage.routeName: (_) =&gt; RegisterPage(),
        },
        ),
        home: SplashPage(),
    );
  }
}

</code></pre>
<ul>
<li><code>theme</code> 定义了一个 ioS 风格的 CupertinoApp 主题（实际开发中可能需要同时使用 Material Cupertino 风格控件所以需要自定义主题）</li>
<li><code>routes</code> 参数注册路由表</li>
<li><code>home</code> 参数设置首次加载的 Splash 画面</li>
</ul>
<h3 id="路由">路由</h3>
<p>和 Web 中的路由类似，通过在路由表注册相应的 url 和画面。基本方法</p>
<ul>
<li>push / pushNamed / pushNamedAndRemoveUntil/...</li>
<li>pop / popUntil / ...</li>
</ul>
<p>基本使用：</p>
<pre><code>// pushNamed 的定义
Future pushNamed(BuildContext context, String routeName,{Object arguments})

//打开一个画面，传一个00
Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: '00');

//新画面接受参数
var arg = ModalRoute.of(context).settings.arguments);

//关闭一个画面，返回一个01
Navigator.of(context).pop(01);

</code></pre>
<ul>
<li>实际上更好的方法来处理传值的问题</li>
<li>可以看到<code>pushNamed</code>方法返回值是一个<code>Future</code> ，说明是一个异步操作，因为可以接受打开的画面<code>pop</code>关闭时返回的<code>result</code> ，此处在<code>pop</code>时返回了一个 01，那么就可以这样接收到。</li>
</ul>
<pre><code>var result = async Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: 'arg');
</code></pre>
<h3 id="网络请求和序列化">网络请求和序列化</h3>
<p>Flutter 的 网络请求库没有特别完美的，目前使用的是 <a href="https://github.com/flutterchina/dio">Dio</a> ,大致是一个简化版的 okhttp 。</p>
<p>由于 Flutter 禁止使用反射，因为运行时反射会干扰 Dart 的 tree shaking，所以类似 Gson 这样通过反射进行序列化的方式就行不通了。<br>
目前大概的解决方案有两种：</p>
<ul>
<li>手写：<code>Dio</code> 会把返回值解析为 Map/List ，所以可以这样手写:</li>
</ul>
<pre><code>  Future&lt;Profits&gt; requestProfits() async {
    var response = await dio.get(&quot;u/profits&quot;);
    var data = response.data;
    print(&quot;requestProfits:$data&quot;);

    var profit = Profit()
      ..fund = data['profit'][&quot;fund&quot;]
      ..profit = data['profit'][&quot;profit&quot;]
      ..profitValue = toMoney(data['profit']['profitValue']);

    return Profits()
      ..miningProfit = data['miningProfit']
      ..lastMiningProfit = data['lastMiningProfit']
      ..shareProfit = data['shareProfit']
      ..lastShareProfit = data['lastShareProfit']
      ..tradeProfit = data['tradeProfit']
      ..lastTradeProfit = data['lastTradeProfit']
      ..vipProfit = data['vipProfit']
      ..lastVipProfit = data['lastVipProfit']
      ..profit = profit;
  }
</code></pre>
<ul>
<li>生成代码：使用 <a href="https://pub.dev/packages/json_serializable">json_serializable</a></li>
</ul>
<pre><code>//user.dart

import 'package:json_annotation/json_annotation.dart';

// user.g.dart 将在我们运行生成命令后自动生成
part 'user.g.dart';

///这个标注是告诉生成器，这个类是需要生成Model类的
@JsonSerializable()

class User{
  User(this.name, this.email);

  String name;
  String email;
  //不同的类使用不同的mixin即可
  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);
  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);  
}
</code></pre>
<p>当然，还是需要写 <code>fromJson</code> <code>toJson</code> 的模板代码，也可以通过生成的方式解决。</p>
<h3 id="平台特定代码">平台特定代码</h3>
<p>Flutter 主要是负责了UI部分的构建，各平台特定的代码还是要通过原生实现，主要用两种方法处理：</p>
<ul>
<li><code>Platform Channel</code> : 大概就是 Flutter 端和原生端注册约定好 <code>platform_channel_name</code> 的 <code>Platform Channel</code>  ，然后调用方法和传参，另一端解析就行了。具有原生能力的 plugin 也就是这样实现的。比如</li>
</ul>
<pre><code>//flutter
MethodChannel('method_channel_mobile').invokeMethod('sendMobile','13000000000')

//Android MainActivity

MethodChannel(flutterView, MOBILE_CHANNEL)
            .setMethodCallHandler { methodCall, result -&gt;
                when {
                    TextUtils.equals(methodCall.method, &quot;mobile&quot;) -&gt; {
                        mobile = methodCall.arguments.toString()
                        result.success(&quot;success&quot;)
                    }
                     result.notImplemented()
                }
            }
</code></pre>
<ul>
<li><code>PlatformView</code> 直接嵌套原生的 View 到 Flutter 中，但这样做效率不高。另外需要注意的是不要传入一个 view 到<code>PlatformView</code>中，否则可能出现 Flutter 端多次调用该<code>PlatformView</code>的时候状态会共存，以及不会销毁。</li>
</ul>
<pre><code>// 定义一个用于的 PlatformView 和 PlatformViewFactory 用于实例化 Native View 
class ButtonFactory(
    private val context: Context
) : PlatformViewFactory(StandardMessageCodec.INSTANCE) {

    override fun create(p0: Context?, p1: Int, p2: Any?): PlatformView {
        return ButtonPlatformView(context)
    }
    class ButtonPlatformView(
        private val context: Context
    ) : PlatformView {

        override fun getView(): Button {
            return Button(context)
        }
        override fun dispose() {
        }
    }
}

//在 MainActivity 中注册
        registrarFor(&quot;native_view&quot;).platformViewRegistry()
            .registerViewFactory(&quot;native_view&quot;,ButtonPlatformFactory)
</code></pre>
<h3 id="widget-嵌套的问题">Widget 嵌套的问题</h3>
<p>网上对 Flutter 嵌套讨论的比较多的问题就是，UI 复杂了以后，嵌套层数太多。<br>
确实有这个问题，之前说了 Widget 不光是 View 还包括配置文件，所以一个类似 Button 这样的 Widget 可能就需要嵌套3 4层。<br>
下面是我写的一个登录画面的登录按钮，感受一下:</p>
<pre><code>  CupertinoButton _loginButton() {
    return CupertinoButton(
      padding: EdgeInsets.all(0),
      child: Container(
          width: double.infinity,
          height: 45,
          decoration: BoxDecoration(
            gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: _isLoginAvailable
                    ? &lt;Color&gt;[Color(0xFF657FF8), Color(0xFF4260E8)]
                    : &lt;Color&gt;[Color(0xFFCBCFE2), Color(0xFF73788F)]),
            borderRadius: BorderRadius.all(Radius.circular(6)),
          ),
          child: Center(
            child: Text(
              &quot;登 录&quot;,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: _isLoginAvailable ? Colors.white : Color(0x76FFFFFF),
                fontWeight: FontWeight.bold,
              ),
            ),
          )),
//      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
      onPressed: !_isLoginAvailable ? null : _startCustomFlow,
    );
  }
</code></pre>
<p>实际上这还是只是结构+样式部分，不包括点击后的逻辑。<br>
甚至你可以看到 Button 中的文字也是通过嵌套一个 Widget 来实现的，但这也是 Flutter 的一个优势，不再需要写自定义 Widget 的人去提供大量像文字能不能加粗，变色、斜体等等细节的样式，直接让你传一个 Widget 自行处理，类似的情况还有很多。<br>
另外一个问题是 Widget State 的状态可能太多，包括各个 Widget 的状态和画面的状态堆在一起，想起了当年原生 Android 一个 Activity 50个变量的恐惧。<br>
但我认为这些主要还是因为 Flutter 处于发展的初期，还没有太成熟的架构，目前官方提供了状态管理的库 <code>Provider</code>。<br>
我目前的解决方案是尽量提成方法和独立的Widget：</p>
<ul>
<li>对于有整个页面无关局部状态的 Widget 提成一个独立的 <code>StatefulWidget</code>。</li>
<li>对于没有局部状态的，需要重用就提成一个<code>StatelessWidget</code>，不需要就抽成一个方法，返回 Widget，参考上面的 Button 。</li>
<li>最后在<code>build()</code>方法中只描述整个画面的结构。</li>
</ul>
<p>例如一个 login 画面的<code>build()</code>方法我是这样写的：</p>
<pre><code>  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: cusAppBar(context, elevation: 0),
        backgroundColor: $3C3B45,
        body: Stack(
          children: &lt;Widget&gt;[
            SingleChildScrollView(
              child: Container(
                margin: EdgeInsets.only(left: 15, right: 15),
                child: Column(
                  children: &lt;Widget&gt;[
                    _logo(),
                    Form(
                      onChanged: _onFormChanged,
                      child: Column(
                        children: &lt;Widget&gt;[
                          _phoneRow(),
                          _divider(),
                          _passwordColumn(),
                          _forgetPswText(),
                          _loginButton(),
                          _registerText()
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
</code></pre>
<h3 id="热重载hotreload">热重载（HotReload）</h3>
<p>Flutter 的热重载是广受欢迎的一个特性，重要原因则是 Debug 模式采用 JIT 编译，release 模式采用 AOT 编译。实际用下来效果不错。</p>
<h3 id="问题">问题</h3>
<ul>
<li>编译偶尔遇到的一个问题：<br>
问题：Waiting for another flutter command to release the startup lock...<br>
解决：rm ./flutter/bin/cache/lockfile</li>
</ul>
<h5 id="最后以上只是总结一些重要的点最终官方文档肯定是要读一遍的熟悉大部分-widget-的用法-文档">最后，以上只是总结一些重要的点，最终官方文档肯定是要读一遍的,熟悉大部分 Widget 的用法: <a href="https://flutterchina.club/docs/">文档</a></h5>
<h3 id="总结">总结</h3>
<p>优点：</p>
<ul>
<li><code>Android iOs 两端 UI 高度一致</code>：由于 Flutter 使用自己的一套绘制 UI 的引擎和逻辑，完全不使用 Native View，仅仅调用原生的绘制接口，所以几乎可以做到两个平台的 UI 一模一样，这也是 Flutter 还要做 Web maCos 等全平台的原因。我在开发期间一直使用 Android 进行调试，最后在 Ios 上跑的时候，几乎没有什么差别(虽然目前 UI 也不太复杂)。</li>
<li><code>接入原生相对容易</code>：需要原生实现的功能通过<code>PlatformChannel</code>和 <code>PlatformView</code>也大多都能实现，还可以通过<code>PlatformChannel</code>来启动一个原生的<code>Activity/Fragment</code>实现。（比如扫一扫功能）</li>
<li><code>贵族血统</code>：Google 的全力支持，国内大厂也都在积极尝试。</li>
<li><code>初步可用的程度</code>：目前已经完成了一个小项目的开发，在和原生交互不多的情况下还没有遇到太大的坑。</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>基础功能的缺失</code>：很多基础的功能也需要用 plugin 通过原生来实现，比如 Webview Map 这些组件，更不要说一些 SDK ,几乎都需要自己写 plugin。</li>
<li><code>跨平台的通信</code>：对于大量使用<code>MethodChannel</code>进行通信以及各平台间API有差异的情况下，设计和维护的问题。</li>
<li><code>性能</code>：目前原生 Flutter 在帧数上接近原生，用户使用体验接近，但内存开销更大，尤其在视频方面。</li>
</ul>
<p>总的来说：我的看法是，比较看好 Flutter 跨更多平台的前途，目前来说适合用来开发和原生平台 API 交互不那么复杂的 App 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置 Gitlab-CI 触发企业微信群机器人发送通知]]></title>
        <id>https://xiejinpeng007.github.io/post/pei-zhi-gitlab-ci-hong-fa-qi-ye-wei-xin-qun-ji-qi-ren-fa-song-tong-zhi/</id>
        <link href="https://xiejinpeng007.github.io/post/pei-zhi-gitlab-ci-hong-fa-qi-ye-wei-xin-qun-ji-qi-ren-fa-song-tong-zhi/">
        </link>
        <updated>2019-07-02T10:22:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置-gitlab-ci-触发企业微信群机器人发送通知">配置 Gitlab-CI 触发企业微信群机器人发送通知</h3>
<p>最近企业微信增加了群机器人功能，可以拿来在 Gitlab-CI 打包完成后发送通知，分享下配置方法：</p>
<h4 id="配置群机器人">配置群机器人:</h4>
<ol>
<li>
<p>在相应群右键-添加群机器人-设置相关参数</p>
</li>
<li>
<p>可以看到给出了相应的 Webhook 地址和使用文档,本质就是发一个 POST 请求。 url 包含了相关 key , JSON 包含消息内容。<br>
消息内容支持三种类型，具体语法可以参考文档。</p>
<ul>
<li>text</li>
<li>markdown</li>
<li>图文</li>
</ul>
</li>
<li>
<p>然后可以用 Postman 或者 Terminal 来测试能否收到（替换为自己的 WebHook）。</p>
</li>
</ol>
<pre><code>curl 'http://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx' \
   -H 'Content-Type: application/json' \
   -d '
   {
        &quot;msgtype&quot;: &quot;text&quot;,
        &quot;text&quot;: {
            &quot;content&quot;: &quot;hello world&quot;
        }
   }'
</code></pre>
<h4 id="配置到-gitlab-ci">配置到 Gitlab-CI:</h4>
<p>在原来正常的打包流程基础上，写一个打包成功(失败)后触发的脚本，放在和 gitlab-ci.yml 同级，传入不同参数，发送不同数据，我这里通过第一个参数判断成功失败：</p>
<ul>
<li>成功的参数: on_success branch_name commit_hash apk_name</li>
<li>失败的参数：on_failure</li>
</ul>
<pre><code>#!/usr/bin/env bash

if [[ $1 == &quot;on_success&quot; ]];
then
curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \
      -H 'Content-Type: application/json' \
      -d '
      {
        &quot;msgtype&quot;: &quot;markdown&quot;,
        &quot;markdown&quot;: {
          &quot;content&quot;: &quot;分支:'$2'   提交:'$3'
          '$4'.apk 打包完成！
          [点击查看](https://your_url/pipelines)&quot;
        }
      }'
elif [[ $1 == &quot;on_failure&quot; ]];
then
curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \
      -H 'Content-Type: application/json' \
      -d '
      {
        &quot;msgtype&quot;: &quot;markdown&quot;,
        &quot;markdown&quot;: {
          &quot;content&quot;: &quot;打包失败！
          [点击查看](https://your_url/pipelines)&quot;
        }
      }'
fi
</code></pre>
<p>改一下 gitlab-ci.yml 文件中的配置调用脚本:</p>
<pre><code>...
build_production_release:
  stage: build_production_release
  script:
    - ./gradlew assembleProductionRelease
    - mv app/build/outputs/apk/production/release/*.apk .
    - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;
  artifacts:
    name: &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;
    paths:
      - ./*.apk
    expire_in: 2 weeks
  when: manual
    # except:
    # - feature/CI-CD

clean_build_job:
  stage: clean
  script:
    - ./gradlew clean
    - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot;
  when: on_failure
  ...
</code></pre>
<ul>
<li>
<p>在打包的 job ( build_production_release ) <code>./gradle assemblexxx</code> 之后传入相关参数调用脚本成功的代码<br>
<code>sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;</code></p>
</li>
<li>
<p>打包失败时的 job ( clean_build_job ) 传入 on_failure 调用脚本失败的代码<br>
<code>sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot;</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 XDslPagerAdapter 快速创建 ViewPager]]></title>
        <id>https://xiejinpeng007.github.io/post/shi-yong-xdslpageradapter-kuai-su-chuang-jian-viewpager/</id>
        <link href="https://xiejinpeng007.github.io/post/shi-yong-xdslpageradapter-kuai-su-chuang-jian-viewpager/">
        </link>
        <updated>2019-04-09T09:24:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用-xdslpageradapter-快速创建-viewpager">使用 XDslPagerAdapter 快速创建 ViewPager</h2>
<p>在 Android 开发中经常需要使用 ViewPager ，大多数的功能类似但每次都需要写 Adapter 和一堆模板代码。<br>
目前我们很多项目都使用了 Kotlin 和 Databinding,为了简洁快速地构建 ViewPager，我使用 DSL 和 Databinding 的特性写了一个用于快速创建 PagerAdapter 的工具<code>XDslPagerAdapter</code>。</p>
<p>下面通过创建一个欢迎画面举例说明：</p>
<pre><code>        binding.guideViewPager.run {
            xDslPagerAdapter {
                item(R.layout.pager_guide) {
                    model(BR.model to Page(0, R.drawable.img_tutorial01, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 1 })
                    action { binding -&gt;
                        (binding as? PagerGuideBinding)?.run {
                            (nextPageButton.layoutParams as? ViewGroup.MarginLayoutParams)?.run {
                                marginStart = dp2px(30F)
                                marginEnd = dp2px(30F)
                            }
                        }
                    }
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(1, R.drawable.img_tutorial02, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 2 })
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(2, R.drawable.img_tutorial03, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 3 })
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(3, R.drawable.img_tutorial04, &quot;开始使用&quot;))
                    click(BR.click to { _: Page -&gt;
                        SharedPrefModel.isFistTime = false
                        startActivity(Intent(context, MainActivity::class.java))
                        finish()
                    })
                }
            }
        }
</code></pre>
<ol>
<li>首先调用 ViewPager 的拓展方法<code>xDslPagerAdapter()</code>开始创建<code>PagerAdapter</code></li>
<li>在<code>PagerAdapter</code>内部使用 <code>item()</code>开始创建<code>Item</code>，其中<code>layout</code>是必须的参数。</li>
<li>在<code>Item</code>内部可以使用的方法有<code>model()``click()``action</code>
<ul>
<li><code>model()</code>传入包含 DataBinding 的 <code>BR.Id</code> 和对应的 <code>Model</code>（类型为你 ViewModel 的类型，用来绑定显示相关数据）</li>
<li><code>click()</code>传入包含 DataBinding 的 <code>BR.Id</code> 和对应的 <code>Click</code>（类型为<code>Function&lt;Any&gt;</code>用来绑定点击事件），多个点击事件可多次调用。</li>
<li><code>action()</code>可用来获取 Databinding 为 layout 的 ViewDataBinding 类,用来处理其它的内容，例如动态改变布局等。</li>
</ul>
</li>
</ol>
<p>源码也很简单 源码地址 <a href="https://github.com/xiejinpeng007/XDslPagerAdapter">https://github.com/xiejinpeng007/XDslPagerAdapter</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RxJava2.x 从源码分析原理]]></title>
        <id>https://xiejinpeng007.github.io/post/rxjava2x-cong-yuan-ma-fen-xi-yuan-li/</id>
        <link href="https://xiejinpeng007.github.io/post/rxjava2x-cong-yuan-ma-fen-xi-yuan-li/">
        </link>
        <updated>2019-02-11T09:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>RxJava 相信各位已经使用了很久，大部分人在刚学习 RxJava 感叹切换线程的方便，调用逻辑清晰的同时，并不知道其中的原理，主要是靠记住运行的顺序。<br>
随着我们设计出的 RxJava流 越来越复杂，一些复杂的问题并不能靠着记住的运行顺序就能解决。<br>
下面，就通过最常用的操作符的源码来看看所谓的<code>流</code>是什么运行的。</p>
<p>首先我们用<code>Single</code>举例，设计一个最基本的 RxJava 流，只有一个 <code>Observable(ColdObservable)</code> 和<code>Obsever</code>：</p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
              			.subscribe(it -&gt; Log.i(&quot;subscribe&quot;, it));
</code></pre>
<p>上游发送一个<code>&quot;wtf&quot;</code> ，下游接受时将其打印出来。上游发送端使用 <code>Single.just</code> 作为创建方法,<br>
看一下 <code>just()</code> 方法里做了什么。</p>
<pre><code>    public static &lt;T&gt; Single&lt;T&gt; just(final T item) {
        ObjectHelper.requireNonNull(item, &quot;value is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item));
    }
    
    public static &lt;T&gt; Single&lt;T&gt; onAssembly(@NonNull Single&lt;T&gt; source) {
    Function&lt;? super Single, ? extends Single&gt; f = onSingleAssembly;
    if (f != null) {
        return apply(f, source);
    }
    return source;
}
</code></pre>
<p>其中 <code>ObjectHelper.requireNonNull</code> 只是空检查。<br>
<code>RxJavaPlugins.onAssembly</code> 方法，这个方法其实就是通过一个全局的变量 <code>onSingleAssembly</code> 来对方法进行 Hook ，这一系列<code>xxxAssembly</code>全局变量默认为空，所以实际上当我们没有设置的时候其实 <code>just</code> 方法是直接返回了一个 新实例化的<code>SingleJust</code>对象。</p>
<p>再看看<code>SingleJust</code>内部：</p>
<pre><code>public final class SingleJust&lt;T&gt; extends Single&lt;T&gt; {

    final T value;
    public SingleJust(T value) {
        this.value = value;
    }

    @Override
    protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) {
        observer.onSubscribe(Disposables.disposed());
        observer.onSuccess(value);
    }

}

</code></pre>
<p>实例化的时候只是将值保存了下来，没有其它操作。<br>
下一步调用<code>subscribe()</code>来启动这个流<code>(ColdObservable)</code>，然后看看<code>subscribe</code>中做了什么：</p>
<pre><code>    public final void subscribe(SingleObserver&lt;? super T&gt; subscriber) {
        ObjectHelper.requireNonNull(subscriber, &quot;subscriber is null&quot;);
        subscriber = RxJavaPlugins.onSubscribe(this, subscriber);
        ObjectHelper.requireNonNull(subscriber, &quot;subscriber returned by the RxJavaPlugins hook is null&quot;);

        try {
 	         //核心逻辑
            subscribeActual(subscriber);
        } catch (NullPointerException ex) {
            throw ex;
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;);
            npe.initCause(ex);
            throw npe;
        }
    }
</code></pre>
<p>同样 <code>RxJavaPlugins.onSubscribe</code>  默认没有作用,实际的核心逻辑是调用了<code>subscribeActual(SingleObserver)</code>。<br>
对于我们上面设计的流，则是调用了 SingleJust 中的 <code>subscribeActual(SingleObserver)</code></p>
<p>回顾上面 <code>SingleJust</code> 中 <code>subscribeActual(SingleObserver)</code> 的实现：</p>
<pre><code>        observer.onSubscribe(Disposables.disposed());
        observer.onSuccess(value);
</code></pre>
<p>得到两个信息</p>
<ul>
<li>首先调用下游观察者 <code>SingleObserver</code> 的 <code>OnSubscribe</code> 方法并传递用于取消操作的 <code>Disposable</code></li>
<li>调用<code>OnSuccess</code> 方法并传递之前保存下来的 <code>value</code></li>
</ul>
<h3 id="map-操作符">Map 操作符</h3>
<p>现在我们加入一个常用且重要的<code>Map</code>操作到流中</p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .map(it-&gt; 0)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it)));
</code></pre>
<p>上面这个流包括了三种典型的操作 创建<code>Creation</code> 操作符<code>Transformation</code>和 订阅<code>Subscribe</code>。</p>
<p>依然先检查<code>map()</code> 方法，可以看到其中实例化了一个<code>SingleMap</code></p>
<pre><code>    public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper));
    }
</code></pre>
<p>再看看 <code>SingleMap</code></p>
<pre><code>public final class SingleMap&lt;T, R&gt; extends Single&lt;R&gt; {
    final SingleSource&lt;? extends T&gt; source;
    final Function&lt;? super T, ? extends R&gt; mapper;

    public SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? super T, ? extends R&gt; mapper) {
        this.source = source;
        this.mapper = mapper;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) {
        source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper));
    }

    static final class MapSingleObserver&lt;T, R&gt; implements SingleObserver&lt;T&gt; {

        final SingleObserver&lt;? super R&gt; t;
        final Function&lt;? super T, ? extends R&gt; mapper;

        MapSingleObserver(SingleObserver&lt;? super R&gt; t, Function&lt;? super T, ? extends R&gt; mapper) {
            this.t = t;
            this.mapper = mapper;
        }

        @Override
        public void onSubscribe(Disposable d) {
            t.onSubscribe(d);
        }

        @Override
        public void onSuccess(T value) {
            R v;
            try {
                v = ObjectHelper.requireNonNull(mapper.apply(value), &quot;The mapper function returned a null value.&quot;);
            } catch (Throwable e) {
                Exceptions.throwIfFatal(e);
                onError(e);
                return;
            }

            t.onSuccess(v);
        }

        @Override
        public void onError(Throwable e) {
            t.onError(e);
        }
    }
}
</code></pre>
<p>类中信息稍微复杂一些：</p>
<ol>
<li>首先我们关注在<code>SingleMap</code>实例化的时候也是只做了保存数据的操作，而没有实际逻辑：将流的上游保存为 <code>source</code> 将数据转换的方法保存为 <code>mapper</code></li>
<li>第二步我们知道下游观察者 <code>SingleObserver</code> 会调用核心逻辑 <code>subscribeActual</code>方法来启动流</li>
<li>在这里的<code>subscribeActual</code>方法中可以看到几个重要的信息
<ul>
<li><code>MapSingleObserver</code>是一个观察者</li>
<li><code>MapSingleObserver</code> 保存了下游的观察者 <code>SingleObserver</code> 以及 <code>mapper</code></li>
<li>上游 <code>source</code> 被 <code>MapSingleObserver</code> 订阅</li>
</ul>
</li>
</ol>
<p>由此可以看出在<code>SingleMap</code>被下游观察者订阅了之后，实例化了一个新的观察者<code>MapSingleObserver</code>并保存下游观察者<code>SingleObserver</code>的信息，再去订阅上游<code>SingleJust</code>。<br>
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能的设计模式称为<code>装饰者模式</code>。</p>
<p>总结上面的执行顺序：</p>
<ol>
<li>在<code>Rx流</code>的最后一步调用 <code>subscribe</code>启动流<code>(ColdObservable)</code></li>
<li>首先执行<code>SingleMap</code>中的<code>subscribeActual</code>方法，其中包括生成新的<code>MapSingleObserver</code>并订阅 <code>SingleJust</code></li>
<li>执行<code>SingleJust</code>中的<code>subscribeActual</code>：调用下游<code>MapSingleObserver</code>的<code>onSubscribe</code> <code>onSuccess</code>方法</li>
<li><code>MapSingleObserver</code>中的<code>onSubsribe</code> <code>onSuccess</code>方法也很简单，分别调用下游 <code>Observer</code>的 <code>onSubsribe``onSuccess(异常时 onError)</code>方法</li>
</ol>
<h3 id="observeon-操作符">observeOn 操作符</h3>
<p>Rxjava首先被大家津津乐道之处是可以方便的切换线程，避免<code>Callback Hell</code>，现在来看看线程切换操作符。<br>
我们加入线程切换操作符 <code>observeOn</code></p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .map(it-&gt; 0)
				 .observeOn(Schedulers.io())
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it)));
</code></pre>
<p>同样的，在 <code>observeOn</code>方法中实例化了一个<code>SingleObserveOn</code></p>
<pre><code>    public final Single&lt;T&gt; observeOn(final Scheduler scheduler) {
        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleObserveOn&lt;T&gt;(this, scheduler));
    }
</code></pre>
<p>继续看<code>SingleObserveOn</code>类中信息</p>
<pre><code>public final class SingleObserveOn&lt;T&gt; extends Single&lt;T&gt; {

    final SingleSource&lt;T&gt; source;
    final Scheduler scheduler;

    public SingleObserveOn(SingleSource&lt;T&gt; source, Scheduler scheduler) {
        this.source = source;
        this.scheduler = scheduler;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) {
        source.subscribe(new ObserveOnSingleObserver&lt;T&gt;(s, scheduler));
    }

    static final class ObserveOnSingleObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt;
    implements SingleObserver&lt;T&gt;, Disposable, Runnable {
        private static final long serialVersionUID = 3528003840217436037L;

        final SingleObserver&lt;? super T&gt; actual;
        final Scheduler scheduler;

        T value;
        Throwable error;

        ObserveOnSingleObserver(SingleObserver&lt;? super T&gt; actual, Scheduler scheduler) {
            this.actual = actual;
            this.scheduler = scheduler;
        }

        @Override
        public void onSubscribe(Disposable d) {
            if (DisposableHelper.setOnce(this, d)) {
                actual.onSubscribe(this);
            }
        }

        @Override
        public void onSuccess(T value) {
            this.value = value;
            Disposable d = scheduler.scheduleDirect(this);
            DisposableHelper.replace(this, d);
        }

        @Override
        public void onError(Throwable e) {
            this.error = e;
            Disposable d = scheduler.scheduleDirect(this);
            DisposableHelper.replace(this, d);
        }

        @Override
        public void run() {
            Throwable ex = error;
            if (ex != null) {
                actual.onError(ex);
            } else {
                actual.onSuccess(value);
            }
        }

        @Override
        public void dispose() {
            DisposableHelper.dispose(this);
        }

        @Override
        public boolean isDisposed() {
            return DisposableHelper.isDisposed(get());
        }
    }
}


</code></pre>
<p>类似的</p>
<ul>
<li>构造函数中保存了上游和线程切换的信息</li>
<li><code>subscribeActual</code> 实例化了一个新的观察者<code>ObserveOnSingleObserver</code></li>
</ul>
<p>不同的</p>
<ul>
<li><code>ObserveOnSingleObserver</code> 还继承了<code>AtomicReference&lt;Disposable&gt;</code>、实现了<code>Disposable``Runnable</code>接口</li>
<li><code>onSuccess``onError</code>中都没有直接调用下游的<code>onSuccess</code> <code>onError</code>方法，而是调用了<code>Disposable d = scheduler.scheduleDirect(this);</code>来执行<code>run</code>方法中的逻辑，而<code>run</code>方法中的逻辑则是调用下游的<code>onSuccess</code> <code>onError</code>方法</li>
</ul>
<p>查看<code>schedulerDirect</code>内部信息</p>
<pre><code>    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
        final Worker w = createWorker();
        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
        DisposeTask task = new DisposeTask(decoratedRun, w);
        w.schedule(task, delay, unit);
        return task;
    }
</code></pre>
<p>创建了一个对应线程的<code>Worker</code>和一个可用于取消的<code>DisposeTask</code>并执行，对于<code>IoScheduler</code>则是创建了<code>EventLoopWorker</code>，再看看<code>EventLoopWorker</code>中的信息。</p>
<pre><code>    @Override
    public Worker createWorker() {
        return new EventLoopWorker(pool.get());
    }
</code></pre>
<pre><code>    static final class EventLoopWorker extends Scheduler.Worker {
        private final CompositeDisposable tasks;
        private final CachedWorkerPool pool;
        private final ThreadWorker threadWorker;

        final AtomicBoolean once = new AtomicBoolean();

        EventLoopWorker(CachedWorkerPool pool) {
            this.pool = pool;
            this.tasks = new CompositeDisposable();
            this.threadWorker = pool.get();
        }

        @Override
        public void dispose() {
            if (once.compareAndSet(false, true)) {
                tasks.dispose();

                // releasing the pool should be the last action
                pool.release(threadWorker);
            }
        }

        @Override
        public boolean isDisposed() {
            return once.get();
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {
            if (tasks.isDisposed()) {
                // don't schedule, we are unsubscribed
                return EmptyDisposable.INSTANCE;
            }

            return threadWorker.scheduleActual(action, delayTime, unit, tasks);
        }
    }
</code></pre>
<p><code>EventLoopWorker</code>中则是维护了一套包含相应的<code>线程池</code>、可取消的<code>CompositeDisposable</code>、以及用于运行<code>Runable</code>的<code>ThreadWorker</code>。总的来说就是一套可以在相应线程运行且可取消的类和逻辑。</p>
<ul>
<li>上面则解释了为什么<code>observeOn</code>可以切换下游的线程(<code>onSuccess</code> <code>onError</code>)</li>
<li>同样解释了为什么不会改变<code>onSubsribe</code>的调用线程，因为可以看到<code>onSubscribe</code>方法中直接调用了下游的<code>onSucsribe</code>，并没有受到线程切换的影响。</li>
</ul>
<h3 id="subscribeon">SubscribeOn</h3>
<p>实际上，<code>subsribeOn</code> 是 RxJava2.x 中比较复杂也是相较于 RxJava1.x 改动比较大的一个操作符,它甚至会影响流的执行顺序。（可以参见唐雪茂写的 <a href="https://lexiangla.com/teams/k100002/docs/d00dcc362b2311e8a1c75254004b6d18?company_from=1656b36e07d011e8b7a85254005b9a60">Rxjava流的设计</a> 中的<code>1</code> <code>2</code>两个流）</p>
<p>我们现在设计两个<code>Rx流</code></p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4);
</code></pre>
<pre><code>Disposable disposable2 = Single.just(&quot;wtf&quot;)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1)
				 .subscribeOn(Schedulers.io())
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4);
</code></pre>
<p>你可能已经知道并记住了两个流的打印的顺序分别是 <code>01234</code> <code>23014</code>，但是为什么<code>doOnSubsribe</code>方法和<code>RxJava1</code>中调用顺序完全不一样，为什么通过<code>subscribeOn</code>切换线程会影响执行顺序？</p>
<p>先找到 <code>SingleSubscribeOn</code> 类</p>
<pre><code>public final class SingleSubscribeOn&lt;T&gt; extends Single&lt;T&gt; {
    final SingleSource&lt;? extends T&gt; source;
    final Scheduler scheduler;
    
    public SingleSubscribeOn(SingleSource&lt;? extends T&gt; source, Scheduler scheduler) {
        this.source = source;
        this.scheduler = scheduler;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) {
        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s, source);
        //直接调用下游 onSubscribe
        s.onSubscribe(parent);
        //再执行订阅上游的方法
        Disposable f = scheduler.scheduleDirect(parent);
        parent.task.replace(f);
    }

    static final class SubscribeOnObserver&lt;T&gt;
    extends AtomicReference&lt;Disposable&gt;
    implements SingleObserver&lt;T&gt;, Disposable, Runnable {

        private static final long serialVersionUID = 7000911171163930287L;
        final SingleObserver&lt;? super T&gt; actual;
        final SequentialDisposable task;
        final SingleSource&lt;? extends T&gt; source;
        
        SubscribeOnObserver(SingleObserver&lt;? super T&gt; actual, SingleSource&lt;? extends T&gt; source) {
            this.actual = actual;
            this.source = source;
            this.task = new SequentialDisposable();
        }

        @Override
        public void onSubscribe(Disposable d) {
        	  //没有继续调用下游的 onSubscribe 方法
            DisposableHelper.setOnce(this, d);
        }

        @Override
        public void onSuccess(T value) {
            actual.onSuccess(value);
        }

        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }

        @Override
        public void dispose() {
            DisposableHelper.dispose(this);
            task.dispose();
        }

        @Override
        public boolean isDisposed() {
            return DisposableHelper.isDisposed(get());
        }

        @Override
        public void run() {
            source.subscribe(this);
        }
    }

}
</code></pre>
<p>同样的直接看<code>subscribeActual</code>方法及<code>onSubscribe</code>方法，发现事情并没有那么简单，和之前的操作符的逻辑区别很大：</p>
<ul>
<li><code>SubscribeOnObserver</code>同样还继承了<code>AtomicReference&lt;Disposable&gt;</code>，实现了<code>Disposable``Runnable</code>接口</li>
<li>并没有直接调用<code>subscribe</code>订阅上游，而是执行了其它操作符在 <code>onSubscribe</code>中订阅下游的操作</li>
<li>然后再结合<code>Disposable f = scheduler.scheduleDirect(parent);</code>和<code>run</code>方法可以知道在新的线程中执行了订阅上游的操作 <code>source.subscribe(this);</code></li>
<li><code>onSubsribe</code>中并没有再继续调用下游的 <code>onSubsribe</code></li>
</ul>
<p>综合起来可以知道，本来应该在整个流从下至上订阅完成后按照从上至下的顺序执行 <code>onSubscribe</code>的流，在使用<code>subsribeOn</code>操作符的后，在订阅的时(执行<code>subscribeActual</code>)，就开始执行下游的<code>onSubscribe</code>且在当前线程！然后才在指定的<code>io</code>线程执行之下而上的操作，这也是为什么<code>subsribeOn</code>影响的是上游的线程。</p>
<h3 id="小结">小结：</h3>
<p>我认为实际上 Rx 使用了很多优秀的设计将我们各种常用的操作进行了封装，让我们自由组合使用，其本身并没有用什么黑科技。例如切换线程本质上则是帮我们启用了一个新的线程并把接下来的代码放进去执行。<br>
当然，其中还有很多更深入的内容需要我们继续发现和学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 中的依赖注入 KODEIN]]></title>
        <id>https://xiejinpeng007.github.io/post/kotlin-zhong-de-yi-lai-zhu-ru-kodein/</id>
        <link href="https://xiejinpeng007.github.io/post/kotlin-zhong-de-yi-lai-zhu-ru-kodein/">
        </link>
        <updated>2018-06-08T09:23:31.000Z</updated>
        <content type="html"><![CDATA[<p>用 Java 进行 Android 开发的话，依赖注入这一块一般使用 Dagger ,转用 Kotlin 之后有更多的选择，Kodein 是个不错的库， 4.0 5.0 都使用过了，相对于 Dagger 有很多好处。</p>
<ul>
<li>用 Kotlin 编写利用了更优秀的语言特性 比如类型推断，Dagger 在编写 Component 的时候需要知道注入类的类型</li>
<li>无需像 Dagger 一样编写大量模板代码</li>
<li>不会像 Dagger 一样在编译期因为其它的编译错误导致无法生成所需文件从而报一堆错。</li>
<li>...</li>
</ul>
<h3 id="最基本的使用步骤">最基本的使用步骤</h3>
<ol>
<li>在 Application 继承 <code>KodeinAware</code> 并绑定依赖</li>
</ol>
<pre><code>class MyApp : Application(), KodeinAware {
	override val kodein = Kodein.lazy { 
	    /* bindings */
	}
}
</code></pre>
<ol start="2">
<li>在 context aware 的 Android 类中通过 <code>closestKodein</code> 方法获取</li>
<li>加载依赖</li>
</ol>
<pre><code>class MyApp : Application(), KodeinAware {

    //实例化 Application 级的 kodein 通过 DSL 绑定 module
	override val kodein = Kodein.lazy { 
        //导入预设的 android 组件
        import(androidModule(this@MainApplication))
        //绑定或者导入自定义依赖
	}
}
</code></pre>
<h3 id="相关基本概念">相关基本概念</h3>
<h4 id="在-application-定义-application-级的-kodein">在 Application 定义 Application 级的 <code>Kodein</code></h4>
<pre><code>class MyApp : Application(), KodeinAware {

    //实例化 Application 级的 kodein 通过 DSL 绑定 module
	override val kodein = Kodein.lazy { 
        //导入预设的 android 组件
        import(androidModule(this@MainApplication))
        //绑定或者导入自定义依赖
	}
}
</code></pre>
<h4 id="通过-closestkodein-恢复-application-级的-kodein-然后通过-kodein-加载依赖">通过 closestKodein 恢复 Application 级的 <code>Kodein</code>  然后通过 <code>Kodein</code> 加载依赖</h4>
<p>#####kodein &amp; ds 默认都是懒加载</p>
<pre><code>class MyActivity : Activity(), KodeinAware {
    override val kodein by closestKodein()
    val ds: DataSource by instance()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ds.connect() 
        /* ... */
    }
}
</code></pre>
<h4 id="使用-trigger-在-oncreate-中手动触发加载依赖取消懒加载">使用 Trigger 在 onCreate() 中手动触发加载依赖（取消懒加载）</h4>
<p>同样可以避免依赖死循环（除非加载依赖的方式只有 instance）</p>
<pre><code>class MyActivity : Activity(), KodeinAware {
    override val kodein by closestKodein()
    override val kodeinTrigger = KodeinTrigger()
    val ds: DataSource by instance()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        kodeinTrigger.trigger() 
        /* ... */
    }
}
</code></pre>
<h4 id="在没有-non-context-aware-的类中加载-kodein">在没有 Non-Context-Aware 的类中加载 Kodein</h4>
<pre><code>class MyController(androidContext: Context) : KodeinAware {
    override val kodein by androidContext.closestKodein()
    override val kodeinContext = kcontext(androidContext)
    val inflater: LayoutInflater by instance()
}
</code></pre>
<h4 id="多级-kodin-依赖">多级 Kodin 依赖</h4>
<h5 id="定义-activity-级的-kodein-继承自-application-级">定义 Activity 级的 <code>Kodein</code> 继承自 Application 级</h5>
<pre><code>class MyActivity : Activity(), KodeinAware {
    private val _parentKodein by closestKodein() 
    override val kodein: Kodein = Kodein {
        extend(_parentKodein) 
        /* activity specific bindings */
    }
}
</code></pre>
<h4 id="activity-retained-kodein">Activity Retained Kodein</h4>
<h5 id="使用-retainedkodein-在-activity-重启的时候不会重新创建-kodein">使用 retainedKodein 在 Activity 重启的时候不会重新创建 Kodein</h5>
<pre><code>class MyActivity : Activity(), KodeinAware {
    private val _parentKodein by closestKodein()
    override val kodein: Kodein by retainedKodein { 
        extend(_parentKodein)
        /* activity specific bindings */
    }
}
</code></pre>
<h4 id="android-scopes-作用域">Android scopes 作用域</h4>
<pre><code>//每个 Activity 一个单例
val kodein = Kodein {
    bind&lt;Controller&gt;() with scoped(androidScope&lt;Activity&gt;()).singleton { ControllerImpl(context) } 
}
</code></pre>
<h4 id="activity-retained-scope">Activity retained scope</h4>
<h4 id="同样-activityretainedscope-在-activity-重启时不会重新创建依赖">同样 activityRetainedScope 在 Activity 重启时不会重新创建依赖</h4>
<pre><code>val kodein = Kodein {
    bind&lt;Controller&gt;() with scoped(activityRetainedScope).singleton { ControllerImpl() } 
}
</code></pre>
<h4 id="bindings-declaring-dependencies-申明依赖的一些重要的参数">Bindings: Declaring dependencies 申明依赖的一些重要的参数</h4>
<h5 id="绑定的方式">绑定的方式</h5>
<ul>
<li>Provider binding : 每次加载都生成新的实例，无参， 传入<code>() -&gt; T</code></li>
<li>Singleton binding : 单例 传入 <code>() → T</code></li>
<li>Eager singleton : 单例 创建了 Kodein 实例后立即实例化 传入 <code>() -&gt; T</code></li>
<li>Factory binding : 每次加载都生成新的实例，需要参数，传入<code>(A) -&gt; T</code></li>
<li>Multiton binding : 有参的单例，同样参数同样实例，传入 <code>(A) -&gt; T</code></li>
<li>Tagged bindings : 通过 tag 来区分同类型不同的实例 例如</li>
</ul>
<pre><code>val kodein = Kodein {
    bind&lt;Die&gt;() with ... 
    bind&lt;Die&gt;(tag = &quot;DnD10&quot;) with ... 
    bind&lt;Die&gt;(tag = &quot;DnD20&quot;) with ... 
}
</code></pre>
<h5 id="基本上以上的参数涵盖了大部分的通用使用场景kodein-还有很多复杂的高级用法">基本上以上的参数涵盖了大部分的通用使用场景，Kodein 还有很多复杂的高级用法</h5>
<h4 id="jvm-soft-weak-两种引用回收机制">JVM: Soft &amp; Weak 两种引用回收机制</h4>
<ol>
<li>使用 WeakReference 在<code>OutOfMemoryException</code>之前 JVM 执行 GC</li>
<li>使用 SoftReference 在没有引用的时候就 JVM 执行 GC</li>
</ol>
<pre><code>val kodein = Kodein {
    bind&lt;Map&gt;() with refSingleton(ref = softReference) { WorldMap() } 
    bind&lt;Client&gt;() with refSingleton(ref = weakReference) { id -&gt; clientFromDB(id) } 
}
</code></pre>
<h4 id="transitive-dependencies-依赖传递">Transitive dependencies 依赖传递</h4>
<h5 id="依赖中使用依赖的情况kotlin-的类型推断系统可以很简单的实现">依赖中使用依赖的情况，Kotlin 的类型推断系统可以很简单的实现。</h5>
<pre><code>class Die(private val random: Random, private val sides: Int) {
/*...*/
}

val kodein = Kodein {
    bind&lt;Die&gt;() with singleton { Die(instance(), instance(tag = &quot;max&quot;)) } 

    bind&lt;Random&gt;() with provider { SecureRandom() } 
    constant(tag &quot;max&quot;) with 5 
}
</code></pre>
<h5 id="更多高级用法">更多高级用法...</h5>
<ul>
<li><a href="http://kodein.org/Kodein-DI/?5.0">KODEIN DI: KOtlin DEpendency INjection: 5.0.0</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/android">Kodein on Android</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/getting-started">Getting started</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/core">Core documentation</a></li>
</ul>
]]></content>
    </entry>
</feed>