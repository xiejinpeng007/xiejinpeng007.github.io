<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xiejinpeng007.github.io</id>
    <title>xiejinpeng&apos;s space</title>
    <updated>2020-08-19T07:29:56.669Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xiejinpeng007.github.io"/>
    <link rel="self" href="https://xiejinpeng007.github.io/atom.xml"/>
    <subtitle>你觉得做什么事很痛苦，那么就需要去越过它。</subtitle>
    <logo>https://xiejinpeng007.github.io/images/avatar.png</logo>
    <icon>https://xiejinpeng007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, xiejinpeng&apos;s space</rights>
    <entry>
        <title type="html"><![CDATA[Android 10(Q)/11(R) 分区存储适配]]></title>
        <id>https://xiejinpeng007.github.io/post/android-10q11r-fen-qu-cun-chu-gua-pei/</id>
        <link href="https://xiejinpeng007.github.io/post/android-10q11r-fen-qu-cun-chu-gua-pei/">
        </link>
        <updated>2020-08-19T07:26:50.000Z</updated>
        <content type="html"><![CDATA[<p>大部分应用都会请求 ( READ_EXTERNAL_STORAGE ) ( WRITE_EXTERNAL_STORAGE ) 存储权限，来做一些诸如在 SD 卡中存储文件或者读取多媒体文件等常规操作。这些应用可能会在磁盘中存储大量文件，即使应用被卸载了还会依然存在。另外，这些应用还可能会读取其他应用的一些敏感文件数据。</p>
<p>为此，Google 终于下定决心在 Android 10 中引入了分区存储，对权限进行场景的细分，按需索取，并在 Android 11 中进行了进一步的调整。</p>
<h2 id="android-存储分区情况">Android 存储分区情况</h2>
<p>Android 中存储可以分为两大类：私有存储和共享存储</p>
<ul>
<li>私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录：
<ul>
<li>内部存储私有目录<code>(/data/data/packageName)</code> ；</li>
<li>外部存储私有目录 <code>(/sdcard/Android/data/packageName)</code>，</li>
</ul>
</li>
<li>共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。</li>
</ul>
<h2 id="android-10q-行为变更">Android 10(Q) 行为变更：</h2>
<p>Android 10 中主要对<code>共享目录</code>进行了权限详细的划分，不再能通过绝对路径访问。</p>
<p>受影响的接口：</p>
<figure data-type="image" tabindex="1"><img src="https://xiejinpeng007.github.io/post-images/1597822089838.png" alt="" loading="lazy"></figure>
<h3 id="访问不同分区的方式">访问不同分区的方式：</h3>
<ol>
<li>私有目录：和以前的版本一致，可通过 <code>File()</code> API 访问，无需申请权限。</li>
<li>共享目录：需要通过<code>MediaStore</code>和<code>Storage Access Framework</code> API 访问，视具体情况申请权限，下面详细介绍。</li>
</ol>
<p>其中，对共享目录的权限进行了细分：</p>
<ol>
<li>
<p>无需申请权限的操作：<br>
通过 <code>MediaStore API</code>对媒体集、文件集进行媒体/文件的添加、对 <strong>自身APP</strong> 创建的 媒体/文件 进行查询、修改、删除的操作。</p>
</li>
<li>
<p>需要申请<code>READ_EXTERNAL_STORAGE</code>权限：<br>
通过 <code>MediaStore API</code>对所有的媒体集进行查询、修改、删除的操作。</p>
</li>
<li>
<p>调用 <code>Storage Access Framework API</code> ：<br>
会启动系统的文件选择器向用户申请操作指定的文件</p>
</li>
</ol>
<p>新的访问方式：</p>
<figure data-type="image" tabindex="2"><img src="https://xiejinpeng007.github.io/post-images/1597822101677.png" alt="" loading="lazy"></figure>
<h2 id="android-11-r-行为变更">Android 11 (R) 行为变更 :</h2>
<p>Android 11 (R) 在 Android 10 (Q) 中分区存储的基础上进行了调整</p>
<h3 id="1-新增执行批量操作">1. 新增执行批量操作</h3>
<blockquote>
<p>为实现各种设备之间的一致性并增加用户便利性，Android 11 向 MediaStore API 中添加了多种方法。对于希望简化特定媒体文件更改流程（例如在原位置编辑照片）的应用而言，这些方法尤为有用。</p>
</blockquote>
<p>MediaStore API 新增的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>createWriteRequest (ContentResolver, Collection)</td>
<td>用户向应用授予对指定媒体文件组的写入访问权限的请求。</td>
</tr>
<tr>
<td>createFavoriteRequest (ContentResolver, Collection, boolean)</td>
<td>用户将设备上指定的媒体文件标记为 “收藏” 的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为 “收藏”。</td>
</tr>
<tr>
<td>createTrashRequest (ContentResolver, Collection, boolean)</td>
<td>用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。</td>
</tr>
<tr>
<td>createDeleteRequest (ContentResolver, Collection)</td>
<td>用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。</td>
</tr>
</tbody>
</table>
<p>系统在调用以上任何一个方法后，会构建一个 PendingIntent 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。</p>
<h3 id="2-使用直接文件路径和原生库访问文件">2. 使用直接文件路径和原生库访问文件</h3>
<blockquote>
<p>为了帮助您的应用更顺畅地使用第三方媒体库，Android 11 允许您使用除 MediaStore API 之外的 API 访问共享存储空间中的媒体文件。不过，您也可以转而选择使用以下任一 API 直接访问媒体文件：</p>
<p>File API。<br>
原生库，例如 fopen()。</p>
</blockquote>
<p>简单来说就是，可以通过 <code>File()</code> 等API 访问有权限访问的媒体集了。</p>
<h5 id="性能">性能：</h5>
<p>通过 <code>File ()</code> 等直接通过路径访问的 API 实际上也会映射为<code>MediaStore</code> API 。<br>
按文件路径顺序读取的时候性能相当；随机读取和写入的时候则会更慢，所以还是推荐直接使用 <code>MediaStore</code>API。</p>
<h3 id="3-新增权限">3. 新增权限</h3>
<p><code>MANAGE_EXTERNAL_STORAGE</code> :<br>
类似以前的 <code>READ_EXTERNAL_STORAGE</code> + <code>WRITE_EXTERNAL_STORAGE</code>，除了应用专有目录都可以访问。</p>
<p>应用可通过执行以下操作向用户请求名为所有文件访问权限的特殊应用访问权限：</p>
<ol>
<li>在清单中声明 MANAGE_EXTERNAL_STORAGE 权限。</li>
<li>使用 ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION intent 操作将用户引导至一个系统设置页面，在该页面上，用户可以为您的应用启用以下选项：授予所有文件的管理权限。</li>
</ol>
<ul>
<li>在 Google Play 上架的话，需要提交使用此权限的说明，只有指定的几种类型的 APP 才能使用。</li>
</ul>
<h2 id="sample">Sample</h2>
<ul>
<li>
<p>使用 <code>MediaStore</code> 增删改查媒体集</p>
</li>
<li>
<p>使用 <code>Storage Access Framework</code> 访问文件集</p>
</li>
</ul>
<h3 id="1-媒体集">1. 媒体集</h3>
<h4 id="1-查询媒体集需要-read_external_storage-权限">1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限）</h4>
<p>实际上 <code>MediaStore</code> 是以前就有的 API ，不同的是过去主要通过 <code>MediaStore.Video.Media._DATA</code> 这个 colum 请求原始数据，可以得到绝对Uri<code>，现在需要请求</code>MediaStore.Video.Media._ID<code>来得到相对</code>Uri`再进行处理。</p>
<pre><code class="language-kotlin">// Need the READ_EXTERNAL_STORAGE permission if accessing video files that your
// app didn't create.

// Container for information about each video.
data class Video(
    val uri: Uri,
    val name: String,
    val duration: Int,
    val size: Int
)
val videoList = mutableListOf&lt;Video&gt;()

val projection = arrayOf(
    MediaStore.Video.Media._ID,
    MediaStore.Video.Media.DISPLAY_NAME,
    MediaStore.Video.Media.DURATION,
    MediaStore.Video.Media.SIZE
)

// Show only videos that are at least 5 minutes in duration.
val selection = &quot;${MediaStore.Video.Media.DURATION} &gt;= ?&quot;
val selectionArgs = arrayOf(
    TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES).toString()
)

// Display videos in alphabetical order based on their display name.
val sortOrder = &quot;${MediaStore.Video.Media.DISPLAY_NAME} ASC&quot;

val query = ContentResolver.query(
    MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
    projection,
    selection,
    selectionArgs,
    sortOrder
)
query?.use { cursor -&gt;
    // Cache column indices.
    val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID)
    val nameColumn =
            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME)
    val durationColumn =
            cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION)
    val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE)

    while (cursor.moveToNext()) {
        // Get values of columns for a given video.
        val id = cursor.getLong(idColumn)
        val name = cursor.getString(nameColumn)
        val duration = cursor.getInt(durationColumn)
        val size = cursor.getInt(sizeColumn)

        val contentUri: Uri = ContentUris.withAppendedId(
            MediaStore.Video.Media.EXTERNAL_CONTENT_URI,
            id
        )

        // Stores column values and the contentUri in a local object
        // that represents the media file.
        videoList += Video(contentUri, name, duration, size)
    }
}

</code></pre>
<h4 id="2插入媒体集无需权限">2）插入媒体集（无需权限）</h4>
<pre><code class="language-kotlin">// Add a media item that other apps shouldn't see until the item is
// fully written to the media store.
val resolver = applicationContext.contentResolver

// Find all audio files on the primary external storage device.
// On API &lt;= 28, use VOLUME_EXTERNAL instead.
val audioCollection = MediaStore.Audio.Media
        .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)

val songDetails = ContentValues().apply {
    put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Workout Playlist.mp3&quot;)
    put(MediaStore.Audio.Media.IS_PENDING, 1)
}

val songContentUri = resolver.insert(audioCollection, songDetails)

resolver.openFileDescriptor(songContentUri, &quot;w&quot;, null).use { pfd -&gt;
    // Write data into the pending audio file.
}

// Now that we're finished, release the &quot;pending&quot; status, and allow other apps
// to play the audio track.
songDetails.clear()
songDetails.put(MediaStore.Audio.Media.IS_PENDING, 0)
resolver.update(songContentUri, songDetails, null, null)
</code></pre>
<h4 id="3更新自己创建的媒体集无需权限">3）更新自己创建的媒体集（无需权限）</h4>
<p>删除类似</p>
<pre><code class="language-kotlin">// Updates an existing media item.
val mediaId = // MediaStore.Audio.Media._ID of item to update.
val resolver = applicationContext.contentResolver

// When performing a single item update, prefer using the ID
val selection = &quot;${MediaStore.Audio.Media._ID} = ?&quot;

// By using selection + args we protect against improper escaping of // values.
val selectionArgs = arrayOf(mediaId.toString())

// Update an existing song.
val updatedSongDetails = ContentValues().apply {
    put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Favorite Song.mp3&quot;)
}

// Use the individual song's URI to represent the collection that's
// updated.
val numSongsUpdated = resolver.update(
        myFavoriteSongUri,
        updatedSongDetails,
        selection,
        selectionArgs)
</code></pre>
<h4 id="4更新删除其它媒体创建的媒体集">4）更新/删除其它媒体创建的媒体集</h4>
<p>若已经开启分区存储则会抛出 <code>RecoverableSecurityException</code>，捕获并通过<code>SAF</code>请求权限</p>
<pre><code class="language-kotlin">// Apply a grayscale filter to the image at the given content URI.
try {
    contentResolver.openFileDescriptor(image-content-uri, &quot;w&quot;)?.use {
        setGrayscaleFilter(it)
    }
} catch (securityException: SecurityException) {
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {
        val recoverableSecurityException = securityException as?
            RecoverableSecurityException ?:
            throw RuntimeException(securityException.message, securityException)

        val intentSender =
            recoverableSecurityException.userAction.actionIntent.intentSender
        intentSender?.let {
            startIntentSenderForResult(intentSender, image-request-code,
                    null, 0, 0, 0, null)
        }
    } else {
        throw RuntimeException(securityException.message, securityException)
    }
}

</code></pre>
<h3 id="2-文件集-通过-saf">2. 文件集 （通过 SAF）</h3>
<h4 id="1创建文档">1）创建文档</h4>
<p>注：创建操作若重名的话不会覆盖原文档，会添加 (1) 最为后缀，如 document.pdf -&gt; document(1).pdf</p>
<pre><code class="language-kotlin">// Request code for creating a PDF document.
const val CREATE_FILE = 1

private fun createFile(pickerInitialUri: Uri) {
    val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = &quot;application/pdf&quot;
        putExtra(Intent.EXTRA_TITLE, &quot;invoice.pdf&quot;)

        // Optionally, specify a URI for the directory that should be opened in
        // the system file picker before your app creates the document.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }
    startActivityForResult(intent, CREATE_FILE)
}
</code></pre>
<h4 id="2打开文档">2）打开文档</h4>
<p>建议使用 type 设置 MIME 类型</p>
<pre><code class="language-kotlin">// Request code for selecting a PDF document.
const val PICK_PDF_FILE = 2

fun openFile(pickerInitialUri: uri) {
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
        addCategory(Intent.CATEGORY_OPENABLE)
        type = &quot;application/pdf&quot;

        // Optionally, specify a URI for the file that should appear in the
        // system file picker when it loads.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }

    startActivityForResult(intent, PICK_PDF_FILE)
}
</code></pre>
<h4 id="3授予对目录内容的访问权限">3）授予对目录内容的访问权限</h4>
<p>用户选择目录后，可访问该目录下的所有内容</p>
<p><em><strong>Android 11 中无法访问 Downloads</strong></em></p>
<pre><code class="language-kotlin">fun openDirectory(pickerInitialUri: Uri) {
    // Choose a directory using the system's file picker.
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply {
        // Provide read access to files and sub-directories in the user-selected
        // directory.
        flags = Intent.FLAG_GRANT_READ_URI_PERMISSION

        // Optionally, specify a URI for the directory that should be opened in
        // the system file picker when it loads.
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri)
    }

    startActivityForResult(intent, your-request-code)
}
</code></pre>
<h4 id="4永久获取目录访问权限">4）永久获取目录访问权限</h4>
<p>上面提到的授权是临时性的，重启后则会失效。可以通过下面的方法获取相应目录永久性的权限</p>
<pre><code class="language-kotlin">val contentResolver = applicationContext.contentResolver

val takeFlags: Int = Intent.FLAG_GRANT_READ_URI_PERMISSION or
        Intent.FLAG_GRANT_WRITE_URI_PERMISSION
// Check for the freshest data.
contentResolver.takePersistableUriPermission(uri, takeFlags)
</code></pre>
<h4 id="5saf-api-响应">5）SAF API 响应</h4>
<p><code>SAF API</code> 调用后都是通过 <code>onActivityResult</code>来相应动作</p>
<pre><code class="language-kotlin">override fun onActivityResult(
        requestCode: Int, resultCode: Int, resultData: Intent?) {
    if (requestCode == your-request-code
            &amp;&amp; resultCode == Activity.RESULT_OK) {
        // The result data contains a URI for the document or directory that
        // the user selected.
        resultData?.data?.also { uri -&gt;
            // Perform operations on the document using its URI.
        }
    }
}
</code></pre>
<h4 id="6-其它操作">6) 其它操作</h4>
<p>除了上面的操作之外，对文档其它的复制、移动等操作都是通过设置不同的 FLAG 来实现，见 <a href="https://developer.android.com/reference/android/provider/DocumentsContract.Document#COLUMN_FLAGS"><code>Document.COLUMN_FLAGS</code></a></p>
<h4 id="3-批量操作媒体集">3. 批量操作媒体集</h4>
<p>构建一个媒体集的写入操作 <code>createWriteRequest()</code></p>
<pre><code class="language-kotlin">val urisToModify = /* A collection of content URIs to modify. */
val editPendingIntent = MediaStore.createWriteRequest(contentResolver,
        urisToModify)

// Launch a system prompt requesting user permission for the operation.
startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE,
    null, 0, 0, 0)

//相应
override fun onActivityResult(requestCode: Int, resultCode: Int,
                 data: Intent?) {
    ...
    when (requestCode) {
        EDIT_REQUEST_CODE -&gt;
            if (resultCode == Activity.RESULT_OK) {
                /* Edit request granted; proceed. */
            } else {
                /* Edit request not granted; explain to the user. */
            }
    }
}
</code></pre>
<p><code>createFavoriteRequest()</code> <code>createTrashRequest()</code> <code>createDeleteRequest()</code> 同理</p>
<figure data-type="image" tabindex="3"><img src="https://xiejinpeng007.github.io/post-images/1597822142159.png" alt="批量删除图片" loading="lazy"></figure>
<h3 id="适配和兼容">适配和兼容</h3>
<p>在 targetSDK = 29 APP 中，在 <code>AndroidManifes</code> 设置 <code>requestLegacyExternalStorage=&quot;true&quot;</code> 启用兼容模式，以传统分区模式运行。</p>
<pre><code class="language-xml">   &lt;manifest ... &gt;
      &lt;!-- This attribute is &quot;false&quot; by default on apps targeting
           Android 10 or higher. --&gt;
      &lt;application android:requestLegacyExternalStorage=&quot;true&quot; ... &gt;
        ...
      &lt;/application&gt;
    &lt;/manifest&gt;
</code></pre>
<blockquote>
<p><strong>注意</strong>：如果某个应用在安装时启用了传统外部存储，则该应用会保持此模式，直到卸载为止。无论设备后续是否升级为搭载 Android 10 或更高版本，或者应用后续是否更新为以 Android 10 或更高版本为目标平台，此兼容性行为均适用。</p>
</blockquote>
<p>意思就是在新系统新安装的应用才会启用，覆盖安装会保持传统分区模式，例如：</p>
<ul>
<li>
<p>系统通过 OTA 升级到 Android 10/11</p>
</li>
<li>
<p>应用通过更新升级到 targetSdkVersion &gt;= 29</p>
</li>
</ul>
<h3 id="补充">补充</h3>
<p>Q：之前讨论过一些问题，APP 无需权限可以访问自己创建的媒体，那么系统如何进行判断？</p>
<p>A：创建媒体时系统会给媒体打上 packageName tag，应用被卸载则会清除 tag ，所以不会存在使用同样 packageName 进行欺骗的情况。</p>
<p>Q：我可以在媒体集文件夹下创建文档，就可以避开权限的问题了？</p>
<p>A：官方文档上写了只能创建相应类型的媒体/文件，具体如何限制的，没有说明。</p>
<h2 id="总结">总结</h2>
<p>从 Android 10提出分区存储之后到现在已经一年多了，所以Google 从强制推行的态度到现在  targetSDK &gt;=30 才强制启用分区存储来看，Google 还是渐渐地选择给开发者留更多的时间。缺点当然是不强制启用的话，国内 APP 适配进度估计得延后了。不过好消息是在查资料的时候，看到了国内大厂的相关适配文章，至少说明大厂在跟进了。</p>
<p>去年（19年）的文档描述是无论 targetSDK 多少，明年（20年）高版本强制启用。</p>
<figure data-type="image" tabindex="4"><img src="https://xiejinpeng007.github.io/post-images/1597822164995.png" alt="" loading="lazy"></figure>
<p>今年（20）文档描述是 targetSDK &gt;=30 才强制启用</p>
<figure data-type="image" tabindex="5"><img src="https://xiejinpeng007.github.io/post-images/1597822174244.png" alt="" loading="lazy"></figure>
<h5 id="关于适配的难度">关于适配的难度：</h5>
<p>对绝对路径相关接口依赖比较深的 APP 适配还是改动挺多的；其次权限的划分很细，什么时候需要什么权限以及调用哪个接口，理解起来需要一定时间；<code>MediaStore API</code>  <code>SAF API</code> 这类接口以前就设计好了，我也觉得也不算特别友好；最后测试也需要重新进行。</p>
<p>所以虽然明年才会强制执行分区存储，但还是建议尽早理解和 review 项目中需要适配的代码。</p>
<h5 id="参考文档">参考文档：</h5>
<ul>
<li>
<p><a href="https://developer.android.com/preview/privacy/storage">https://developer.android.com/preview/privacy/storage (Android 11 中的存储机制更新)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/shared/documents-files">https://developer.android.com/training/data-storage/shared/documents-files (从共享存储空间访问文档和其他文件)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/training/data-storage/files/external-scoped?hl=zh-cn">https://developer.android.com/training/data-storage/files/external-scoped?hl=zh-cn (管理分区外部存储访问)</a></p>
</li>
<li>
<p><a href="https://developer.android.com/guide/topics/providers/document-provider">https://developer.android.com/guide/topics/providers/document-provider (使用存储访问框架打开文件)</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/6844904063432130568">https://juejin.im/post/6844904063432130568 (Android 10 分区存储介绍及百度APP适配实践)</a></p>
</li>
<li>
<p>[https://github.com/android/storage-samples</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebRTC 原理和网络视频通话的实现(Android+服务器端)]]></title>
        <id>https://xiejinpeng007.github.io/post/webrtc/</id>
        <link href="https://xiejinpeng007.github.io/post/webrtc/">
        </link>
        <updated>2020-05-14T06:07:05.000Z</updated>
        <content type="html"><![CDATA[<p>近期由于疫情原因，国内外线上会议使用率攀升，很多公司都推出了相关服务， Google 也把本来付费会议服务 Meeting 变为免费，实际上现在很多的网络视频软件都使用到了 WebRTC 这个核心的技术。<br>
之前调查过一个摄像头监控功能的 App ，也用到了 WebRTC 相关的技术，于是做成了一个可以视频通话的客户端和服务器端，并做了一些技术的总结分享一下。</p>
<h3 id="简介">简介：</h3>
<blockquote>
<p>WebRTC（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。</p>
</blockquote>
<p>虽然叫 WebRTC ，实际上目前主流浏览器和操作系统都已经支持了相关API。它通过点对点（Point-to-Point）的方式进行通话，但也需要信令服务器来进行相关配置信息的交换。</p>
<p><em><strong>注：下面的原理介绍和 demo 实现，都按照最标准易懂的流程来设计，实际的业务开发会根据情况进行调整。</strong></em></p>
<h3 id="原理">原理：</h3>
<h4 id="基本的图示">基本的图示：</h4>
<p><img src="https://xiejinpeng007.github.io/post-images/1589436796971.png" alt="simple_arch" loading="lazy"><br>
从上图可以看AB互相呼叫的相关流程需要通过信令服务器中转，而视频/音频等流量数据是点对点直接传输的。</p>
<h4 id="重要-api-和相关协议">重要 API 和相关协议：</h4>
<ul>
<li>Network Stream API</li>
<li>MediaStream：MediaStream 用来表示一个媒体数据流。</li>
<li>MediaStreamTrack 在浏览器中表示一个媒体源。</li>
<li>RTCPeerConnection</li>
<li>RTCPeerConnection：一个RTCPeerConnection对象允许用户在两个终端之间直接通讯。</li>
<li>RTCIceCandidate：表示一个ICE协议的候选者。</li>
<li>RTCIceServer：表示一个ICE Server。</li>
<li>Peer-to-peer Data API</li>
<li>DataChannel：数据通道（DataChannel）接口表示一个在两个节点之间的双向的数据通道。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#SDP">Session Description Protocol</a> :一种用于描述在设备之间共享媒体的连接的数据格式.</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#ICE">Interactive Connectivity Establishment (ICE) </a>: 一个用于网络穿透的框架，其中使用 TURN/STUN 服务来实现。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#STUN">Session Traversal Utilities for NAT (STUN)</a>: 用于获取公网地址的协议<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858590133.png" alt="" loading="lazy"></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols#TURN">Traversal Using Relays around NAT (TURN) </a>: 用于中继数据的协议</li>
<li></li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://xiejinpeng007.github.io/post-images/1589858577167.png" alt="" loading="lazy"></figure>
<h4 id="建立连接的基本流程">建立连接的基本流程：</h4>
<ol>
<li>两端进行相关初始化（Socket 、ICE、流媒体等的配置）</li>
<li>A： 发起呼叫:创建用于连接的 <code>PeerConnection(PC)</code> 和自己的配置文件 <code>SessionDescription(SDP)</code><br>
将 SDP 设置为 LocalDescription ,然后通过信令服务器将 SDP 转发给 B ,这个流程称之为 Offer 。</li>
<li>B 收到 SDP 后设置为 RemoteDescription ,创建自己的 SDP ，设置为 LocalDescription,然后通过信令服务器将 SDP 转发 给 A,这个过程称之为 Answer。</li>
<li>A 收到 SDP 后设置为 RemoteDescription</li>
<li>在初始化时会进行 ICE 服务的配置，所以 ICE 服务成功后有回调，A B 在回调后将 ICE 的配置发送给对方，收到后分别设置到 ICE 配置中，则会进行最终的连接。</li>
<li>连接成功后若已设置 DataChannel MediaStream ...等配置，那么相关回调会执行，此时即可获取数据。</li>
</ol>
<p>期间，因为需要点对点的通信，而在公网上由于 NAT/firewalls 的限制，无法直接进行通讯，所以需要使用 ICE 框架来进行，ICE 框架内部使用 STUN / TURN 协议来实现。</p>
<ul>
<li>STUN： 上面已经解释了是用于获取公网IP的服务，Google 也提供了公共的服务器 <code>stun:stun.l.google.com:19302</code></li>
<li>TURN： 主要是用于客户端即使知道了互相的 IP ，由于 Symmetric NAT 的限制无法直接建立连接时用于转发媒体流数据的服务，这个一般来说需要自己搭建。</li>
</ul>
<h3 id="android-客户端的实现">Android 客户端的实现</h3>
<p>客户端的功能包括了自定义服务器地址连接服务器、查看在线设备、选择设备进行视频通话</p>
<p>依赖库中 Webrtc 使用 Google 官方提供的， 服务器端和 Android 端使用了同样的 Socket 库，若服务器端没有什么限制推荐使用 OkHttp 自带的 Socket 通信功能。</p>
<pre><code>    implementation 'org.webrtc:google-webrtc:1.0.28513'
    implementation 'com.github.nkzawa:socket.io-client:0.4.2'

</code></pre>
<h4 id="webrtcclient-的初始化">WebRtcClient 的初始化</h4>
<pre><code>    init {
        //初始化 PeerConnectionFactory 配置
        PeerConnectionFactory.initialize(
            PeerConnectionFactory
                .InitializationOptions
                .builder(app)
                .createInitializationOptions()
        )
        
        //初始化视频编码/解码信息
        factory = PeerConnectionFactory.builder()
            .setVideoDecoderFactory(
                DefaultVideoDecoderFactory(eglContext)
            )
            .setVideoEncoderFactory(
                DefaultVideoEncoderFactory(
                    eglContext, true, true
                )
            )
            .createPeerConnectionFactory()

        // 初始化 Socket 通信
        val messageHandler = MessageHandler()

        try {
            socket = IO.socket(url)
        } catch (e: URISyntaxException) {
            e.printStackTrace()
        }

        socket?.on(&quot;id&quot;, messageHandler.onId)
        socket?.on(&quot;message&quot;, messageHandler.onMessage)
        socket?.on(&quot;ids&quot;, messageHandler.onIdsChanged)
        socket?.connect()

        //初始化 ICE 服务器创建 PC 时使用
        iceServers.add(PeerConnection.IceServer(&quot;stun:23.21.150.121&quot;))
        iceServers.add(PeerConnection.IceServer(&quot;stun:stun.l.google.com:19302&quot;))

        //初始化本地的 MediaConstraints 创建 PC 时使用，是流媒体的配置信息
        pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveAudio&quot;, &quot;true&quot;))
        pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveVideo&quot;, &quot;true&quot;))
        pcConstraints.optional.add(MediaConstraints.KeyValuePair(&quot;DtlsSrtpKeyAgreement&quot;, &quot;true&quot;))
    }
</code></pre>
<h4 id="开始建立连接">开始建立连接</h4>
<p>上面介绍的<code>建立连接的基本流程</code>提到了 A 呼叫 B 的话是由 A 开启 Offer 流程，由于我希望创建 PC 的时候知道自己的 id 和获取所有在线客户端，所以修改了一些流程，增加了<code>init</code> <code>readyToStream</code>的动作。</p>
<ul>
<li>初始化 Socket 连接上服务器后会返回相应 clientId, 此时进行本地摄像头的初始化和本地媒体流的初始化最后进行向服务器发送准备初始化成功的指令。</li>
</ul>
<pre><code>    private fun getVideoCapturer() =
        Camera2Enumerator(app).run {
            deviceNames.find {
                isFrontFacing(it)
            }?.let {
                createCapturer(it, null)
            } ?: throw IllegalStateException()
        }

    fun startLocalCamera(name: String, context: Context) {
        //init local media stream
        val localVideoSource = factory.createVideoSource(false)
        val surfaceTextureHelper =
            SurfaceTextureHelper.create(
                Thread.currentThread().name, eglContext
            )
        (vc as VideoCapturer).initialize(
            surfaceTextureHelper,
            context,
            localVideoSource.capturerObserver
        )
        vc.startCapture(320, 240, 60)
        localMS = factory.createLocalMediaStream(&quot;LOCALMEDIASTREAM&quot;)
        localMS?.addTrack(factory.createVideoTrack(&quot;LOCALMEDIASTREAM&quot;, localVideoSource))
        webrtcListener.onLocalStream(localMS!!)

        try {
            val message = JSONObject()
            message.put(&quot;name&quot;, name)
            socket?.emit(&quot;readyToStream&quot;, message)
        } catch (e: JSONException) {
            e.printStackTrace()
        }
    }
</code></pre>
<ul>
<li>此时已连上服务器并配置完毕，调用 <code>refreshIds</code> 获取已连接上服务器客户端，选择 id 进行呼叫</li>
</ul>
<pre><code>  //发送消息的方法
private fun sendMessage(to: String, type: String, payload: JSONObject) {
        val message = JSONObject()
        message.put(&quot;to&quot;, to)
        message.put(&quot;type&quot;, type)
        message.put(&quot;payload&quot;, payload)
        socket?.emit(&quot;message&quot;, message)
    }
    
    fun refreshIds() {
        socket?.emit(&quot;refreshids&quot;, null)
    }
    
    fun callByClientId(clientId: String) {
        sendMessage(clientId, &quot;init&quot;, JSONObject())
    }

</code></pre>
<ul>
<li><code>readyToStream</code> <code>refreshIds</code>是为了实现查看在线设备相关功能，并非 WebRTC 的标准，下面的<code>建立连接的基本流程</code>是必要的流程。<br>
接收消息后根据消息进入不同的响应流程以及具体的实现。</li>
</ul>
<pre><code>    private inner class MessageHandler {
		//建立 PC 交换 SDP ICE 等配置的事件
        val onMessage = Emitter.Listener { args -&gt;
            val data = args[0] as JSONObject
            try {
                val from = data.getString(&quot;from&quot;)
                val type = data.getString(&quot;type&quot;)
                var payload: JSONObject? = null
                if (type != &quot;init&quot;) {
                    payload = data.getJSONObject(&quot;payload&quot;)
                }
                //用于检查是否 PC 是否已存在已经是否达到最大的2个 PC 的限制
                if (!peers.containsKey(from)) {
                    val endPoint = findEndPoint()
                    if (endPoint == MAX_PEER) return@Listener
                    else addPeer(from, endPoint)
                }
                //根据不同的指令类型和数据响应相应步骤的方法
                when (type) {
                    &quot;init&quot; -&gt; createOffer(from)
                    &quot;offer&quot; -&gt; createAnswer(from, payload)
                    &quot;answer&quot; -&gt; setRemoteSdp(from, payload)
                    &quot;candidate&quot; -&gt; addIceCandidate(from, payload)
                }

            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }
        //连接上服务器会返回自己的 clientId 的事件，可开始呼叫。
        val onId = Emitter.Listener { args -&gt;
            val id = args[0] as String
            webrtcListener.onCallReady(id)
        }
		 //获取在线客户端的事件
        val onIdsChanged = Emitter.Listener { args -&gt;
            Log.d(TAG, args.toString())
            val ids = args[0] as JSONArray

            webrtcListener.onOnlineIdsChanged(ids)
        }
    }
    
    //开始 Offer 流程
    private fun createOffer(peerId: String) {
        Log.d(TAG, &quot;CreateOffer&quot;)
        val peer = peers[peerId]
        peer?.pc?.createOffer(peer, pcConstraints)
    }

	//开始 Answer 流程
    private fun createAnswer(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;CreateAnswer&quot;)
        val peer = peers[peerId]
        val sdp = SessionDescription(
            SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)),
            payload?.getString(&quot;sdp&quot;)
        )
        peer?.pc?.setRemoteDescription(peer, sdp)
        peer?.pc?.createAnswer(peer, pcConstraints)
    }

	//设置 SDP 后无需操作等待 ICE 成功后响应
    private fun setRemoteSdp(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;SetRemoteSDP&quot;)
        val peer = peers[peerId]
        val sdp = SessionDescription(
            SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)),
            payload?.getString(&quot;sdp&quot;)
        )
        peer?.pc?.setRemoteDescription(peer, sdp)
    }

	//收到 ICE  后添加到 PC
    private fun addIceCandidate(peerId: String, payload: JSONObject?) {
        Log.d(TAG, &quot;AddIceCandidate&quot;)
        val pc = peers[peerId]!!.pc
        if (pc!!.remoteDescription != null) {
            val candidate = IceCandidate(
                payload!!.getString(&quot;id&quot;),
                payload.getInt(&quot;label&quot;),
                payload.getString(&quot;candidate&quot;)
            )
            pc.addIceCandidate(candidate)
        }
    }
</code></pre>
<h4 id="基本流程中的一些细节补充">基本流程中的一些细节补充：</h4>
<ul>
<li>建立 PeerConnection 时需绑定本地媒体流</li>
</ul>
<pre><code>        init {
            Log.d(TAG, &quot;new Peer: $id $endPoint&quot;)
            this.pc = factory.createPeerConnection(iceServers, pcConstraints, this)
            pc?.addStream(localMS!!) //, new MediaConstraints()
            webrtcListener.onStatusChanged(&quot;CONNECTING&quot;)
        }
</code></pre>
<ul>
<li>需要实现 <code>SdpObserver</code> <code>PeerConnection.Observer</code> 接口，用于监听 PeerConnection SDP 关键的回调。</li>
</ul>
<pre><code>	// SDP 创建成功后回调，发送给服务器。
        override fun onCreateSuccess(sdp: SessionDescription) {
            // TODO: modify sdp to use pcParams prefered codecs
            try {
                val payload = JSONObject()
                payload.put(&quot;type&quot;, sdp.type.canonicalForm())
                payload.put(&quot;sdp&quot;, sdp.description)
                sendMessage(id, sdp.type.canonicalForm(), payload)
                pc!!.setLocalDescription(this@Peer, sdp)
            } catch (e: JSONException) {
                e.printStackTrace()
            }
        }
       
       // ICE 框架获取候选者成功后的回调，发送给服务器。
        override fun onIceCandidate(candidate: IceCandidate) {
            try {
                val payload = JSONObject()
                payload.put(&quot;label&quot;, candidate.sdpMLineIndex)
                payload.put(&quot;id&quot;, candidate.sdpMid)
                payload.put(&quot;candidate&quot;, candidate.sdp)
                sendMessage(id, &quot;candidate&quot;, payload)
            } catch (e: JSONException) {
                e.printStackTrace()
            }

        }
        
        // ICE 连接状态变化时的回调
         override fun onIceConnectionChange(iceConnectionState: PeerConnection.IceConnectionState) {
            webrtcListener.onStatusChanged(iceConnectionState.name)
            Log.d(TAG, &quot;onIceConnectionChange ${iceConnectionState.name}&quot;)
            if (iceConnectionState == PeerConnection.IceConnectionState.DISCONNECTED) {
                removePeer(id)
            }
        }
 	
 	//连接成功后，最后获取到媒体流，发给 View 层进行视频/音频的播放。
       override fun onAddStream(mediaStream: MediaStream) {
            Log.d(TAG, &quot;onAddStream &quot; + mediaStream.id)
            // remote streams are displayed from 1 to MAX_PEER (0 is localStream)
            webrtcListener.onAddRemoteStream(mediaStream, endPoint + 1)
        }
	
	//媒体流断开
        override fun onRemoveStream(mediaStream: MediaStream) {
            Log.d(TAG, &quot;onRemoveStream &quot; + mediaStream.id)
            removePeer(id)
        }
        
</code></pre>
<p>在<code>onAddStream</code>中将 MediaStream 发给 View 层后 WebRtcClient 中的连接的工作基本完成。</p>
<ul>
<li>View 层中将 MediaStream 绑定到 View 中</li>
</ul>
<pre><code>	//使用 org.webrtc.SurfaceViewRenderer
        &lt;org.webrtc.SurfaceViewRenderer
            android:id=&quot;@+id/remote_renderer&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;match_parent&quot; /&gt;
            
       //初始化
     override fun onCreate(savedInstanceState: Bundle?) {      
        binding.remoteRenderer.apply {
            setEnableHardwareScaler(true)
            init(eglBase.eglBaseContext, null)
        }
      }
	//绑定从 WebRtcClent 中转发 MediaStream
      override fun onAddRemoteStream(remoteStream: MediaStream, endPoint: Int) {
                    remoteStream.videoTracks[0].addSink(binding.remoteRenderer)
                }
</code></pre>
<p>此外，上面只是展示了关键步骤，但实际编码中回调较多，还是比较繁杂。<br>
完整代码参考 <a href="https://github.com/xiejinpeng007/WebRTC-Android-Server">https://github.com/xiejinpeng007/WebRTC-Android-Server</a></p>
<h3 id="信令服务器端nodejs">信令服务器端（NodeJS）</h3>
<p>负责转发信令等功能</p>
<p>部署：<br>
在 SignalServer 根目录下执行 <code>node app.js</code>  会部署在 3000 端口，并监听客户端的连接情况。<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858682056.png" alt="" loading="lazy"></p>
<h3 id="使用和演示">使用和演示</h3>
<p>输入信令服务器地址（公网和局域网皆可）连接服务器后， 根据在线用户进行呼叫，由于 STUN 服务器用了 Google 的，所以需要梯子。</p>
<ol>
<li>设定服务器地址查看在线用户</li>
</ol>
<figure data-type="image" tabindex="2"><img src="https://xiejinpeng007.github.io/post-images/1589858691023.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>选择用户进行拨号连接,可以看到成功了。<br>
<img src="https://xiejinpeng007.github.io/post-images/1589858701140.gif" alt="" loading="lazy"></li>
</ol>
<h3 id="总结">总结</h3>
<p>优点：</p>
<ul>
<li>当然是大部分流量不经过服务器直接点对点(P2P)传输，可以大大的节省服务商的带宽资源。</li>
</ul>
<p>缺点:</p>
<ul>
<li>原生只支持1对1的通信，要实现多人通信需要借助服务端的其它方案例如中转。</li>
<li>复杂的网络场景连接质量无法保证，比如跨国等情况，也需要服务商进行优化。</li>
</ul>
<p>大多使用 WebRTC 技术的都根据具体业务都在此基础上进行了二次封装， Google 自家应用上也看到在使用相关的技术，所以总的来说 WebRTC 确实是一套实际可用的技术。</p>
<h3 id="参考">参考:</h3>
<p><a href="https://github.com/xiejinpeng007/WebRTC-Android-Server">https://github.com/xiejinpeng007/WebRTC-Android-Server</a>  (Demo)<br>
<a href="https://webrtc.github.io/webrtc-org/native-code/android/">https://webrtc.github.io/webrtc-org/native-code/android/</a><br>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[给现有 App 引入 Flutter Module]]></title>
        <id>https://xiejinpeng007.github.io/post/add-flutter-module-to-app/</id>
        <link href="https://xiejinpeng007.github.io/post/add-flutter-module-to-app/">
        </link>
        <updated>2019-10-09T06:27:24.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>最近 Flutter 很火，相信长得帅的人都已经对它都有了初步的了解。<br>
不过由于目前默认使用 Flutter 作为框架接管整个 App 进行开发，不够灵活：一方面使用纯 Flutter 开发需要在项目开始之前仔细评估是否有难以实现的功能；另一方面现有的 App 想使用 Flutter 的话很难全部转换过去。<br>
很容易想到在现有的 App 的基础上加入 Flutter 作为部分画面/功能的实现是一个理想的方案，也更有利于做技术尝试和风险控制。<br>
实际上目前 Flutter 官方提供了两种方案用于给现有 App 加入 Flutter Module，另外还有一些第三方的方案，最近我做了一些尝试，分享一些成果。<br>
需要注意的是， 给现有 App 引入 Flutter Module 的功能还在实验性的阶段, APIs 和工具链处于未稳定阶段,且需要切换到   <code>master</code>  分支（不稳定）使用。</p>
<p>效果：<br>
<img src="https://xiejinpeng007.github.io/post-images/1570603064756.gif" alt="从原生App中打开 Flutter Module（ Fragment ）" loading="lazy"><br>
从原生App中打开 Flutter Module（ Fragment , Google Pixel3 XL ）</p>
<h2 id="android">Android</h2>
<h3 id="创建一个-flutter-module">创建一个 Flutter module</h3>
<p>假设在 <code>some/path/MyApp</code> 下是 Android 项目目录</p>
<pre><code class="language-shell">cd some/path
flutter create -t module --org com.example flutter_to_app
</code></pre>
<p>会在 <code>some/path/flutter_to_app</code>生成一个 Flutter Module</p>
<h3 id="宿主-app-设置">宿主 App 设置</h3>
<p>需要在<code>app/build.gradle</code>里设置</p>
<pre><code>android {
  //...
  compileOptions {
    sourceCompatibility 1.8
    targetCompatibility 1.8
  }
}
</code></pre>
<h3 id="让-app-依赖-flutter-module">让 App 依赖 Flutter Module</h3>
<p>有两种方案，直接依赖源代码和 aar 产物。</p>
<h4 id="1-依赖生成的-aar">1. 依赖生成的 aar</h4>
<pre><code class="language-shell">cd ~/Documents/Android/flutter_to_app
flutter build aar
</code></pre>
<pre><code>// MyApp/app/build.gradle

android {
  // ...
}

repositories {
  maven {
  //可以使用相对路径或者绝对路径
    url 'some/path/flutter_to_app/build/host/outputs/repo'
  }
}

dependencies {
  // ...
  releaseCompile ('com.example. flutter_to_app:flutter_release:1.0@aar') {
    transitive = true
  }
}
</code></pre>
<p>可以用 <code>flutter build aar --debug</code> 生成 debug 依赖</p>
<pre><code>// MyApp/app/build.gradle

dependencies {
  // ...
  debugCompile ('com.example.my_flutter:flutter_debug:1.0@aar') {
    transitive = true
  }
}
</code></pre>
<h4 id="2直接依赖源码">2.直接依赖源码</h4>
<p>依赖 aar 的方式有点麻烦，还需要到 Module 中编译，所以也可以直接依赖源码编译</p>
<p>在宿主 App <code>settings.gradle</code>加入</p>
<pre><code>// MyApp/settings.gradle
include ':app'
...                                     
setBinding(new Binding([gradle: this]))                                 
evaluate(new File(                                                     
 settingsDir.parentFile,                                                
  'flutter_to_app/.android/include_flutter.groovy'                          
))  
</code></pre>
<p>上面的<code>File()</code>路径是 flutter module 相对 host app 的路径。binding 和 <code>include_flutter.groovy</code> 脚本引入 flutter module 本身和相关的 plugin。</p>
<p>最后，依赖模块:</p>
<pre><code>// MyApp/app/build.gradle
dependencies {
  implementation project(':flutter')
}
</code></pre>
<h3 id="在-android-项目中使用-flutter-module">在 Android 项目中使用 Flutter Module</h3>
<p>目前有两种方式实现，分别在</p>
<ol>
<li><code>io.flutter.facade.*</code></li>
<li><code>io.flutter.embedding.android.*</code></li>
</ol>
<p>两个包下， 第一种已经被 deprecated ,第二种还处于 technical preview 阶段，所以两种版本的 API 都还不稳定，但可以大概看一下两种方式。</p>
<h4 id="以前的方式deprecated-ioflutterfacade">以前的方式（deprecated） ( io.flutter.facade )</h4>
<p>通过使用 <code>Flutter.createView</code>:</p>
<pre><code>fab.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
    View flutterView = Flutter.createView(
      MainActivity.this,
      getLifecycle(),
      &quot;route1&quot;
    );
    FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(600, 800);
    layout.leftMargin = 100;
    layout.topMargin = 200;
    addContentView(flutterView, layout);
  }
});
</code></pre>
<p>通过使用 <code>Flutter.createFragment</code>:</p>
<pre><code>// MyApp/app/src/main/java/some/package/SomeActivity.java
fab.setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
    FragmentTransaction tx = getSupportFragmentManager().beginTransaction();
    tx.replace(R.id.someContainer, Flutter.createFragment(&quot;route1&quot;));
    tx.commit();
  }
});
</code></pre>
<p>创建<code>View</code>和<code>Fragment</code>都非常简单，但是实际测试下来，启动 View (FlutterFragment实际上也是通过 createView 来生成视图的)会有启动时间，体验没那么无缝。</p>
<h3 id="新的方式-ioflutterembeddingandroid">新的方式（ io.flutter.embedding.android.* ）</h3>
<h4 id="通过-flutterview-继承自-framelayout">通过 FlutterView ( 继承自 FrameLayout )</h4>
<pre><code>实例化 FlutterView 嵌入 Native
FlutterView flutterView = new FlutterView(this);
FrameLayout frameLayout = findViewById(R.id.framelayout);
frameLayout.addView(flutterView);
//创建一个 FlutterView 就可以了，这个时候还不会渲染。
//调用下面代码后才会渲染
flutterView.attachToFlutterEngine(flutterEngine);
</code></pre>
<p><img src="https://xiejinpeng007.github.io/post-images/1570602991085.gif" alt="直接在原生App中加入 FlutterView" loading="lazy"><br>
直接在原生App中加入 FlutterView ( Google Pixel3 XL )</p>
<h4 id="通过-flutterfragment-打开">通过 FlutterFragment 打开</h4>
<h5 id="通过-xml">通过 xml</h5>
<pre><code>	&lt;fragment
    android:id=&quot;@+id/flutterfragment&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:name=&quot;io.flutter.embedding.android.FlutterFragment&quot;
    /&gt;
</code></pre>
<h5 id="直接实例化">直接实例化</h5>
<pre><code>flutterFragment = new FlutterFragment.createDefault();
</code></pre>
<h4 id="通过-flutteractivity-打开">通过 FlutterActivity 打开</h4>
<h5 id="在-androidmanifestxml-中注册">在 AndroidManifest.xml 中注册</h5>
<pre><code>    &lt;activity
        android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot;
        android:theme=&quot;@style/LaunchTheme&quot;
        android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density&quot;
        android:hardwareAccelerated=&quot;true&quot;
        android:windowSoftInputMode=&quot;adjustResize&quot;
        android:exported=&quot;true&quot;
        /&gt;
</code></pre>
<h5 id="默认启动方式">默认启动方式</h5>
<pre><code>	//默认路由为 '/'
    Intent defaultFlutter = new FlutterActivity.createDefaultIntent(currentActivity);
    startActivity(defaultFlutter);
</code></pre>
<h5 id="启动到指定路由">启动到指定路由</h5>
<pre><code>    Intent customFlutter = new FlutterActivity.IntentBuilder()
      .initialRoute(&quot;someOtherRoute&quot;)
      .build(currentActivity);
    startActivity(customFlutter);
</code></pre>
<h3 id="flutterengine-缓存机制">FlutterEngine 缓存机制</h3>
<p>实际上，通过 API 和源码可以看出，新版的 Flutter 相关类<code>io.flutter.embedding.android.*</code>完全重新设计了 Native 调用的方式，从包名（embedding）就可以看出是希望嵌入 Native， 其中一个重要的变化是加入了 <code>FlutterEngine</code> 的缓存机制。<br>
通过老的方式启动 Flutter 的响应时间长包括了需要启动<code>FlutterEngine</code>的时间，可以理解为冷启动，而且从原生的不同<code>Activity / ViewController</code> 启动 Flutter 都需要启动一个新的 <code>FlutterEngine</code>，所以不仅第一次启动 Flutter 时间长 ，每次启动都会需要同样的时间。比如下面的情况</p>
<p><code>Native A -&gt; Flutter B -&gt; Native C -&gt; Flutter D</code></p>
<p>这样从<code>Native A</code> 和 <code>Native B</code>启动时会实例化两个<code>FlutterEngine</code>。<br>
<img src="https://xiejinpeng007.github.io/post-images/1570603039285.gif" alt="未使用 FlutterEngineCache 时从原生 App 启动白屏" loading="lazy"><br>
未使用 FlutterEngineCache 时从原生 App 启动白屏 ( Google Pixel3 XL )</p>
<p>这样不仅慢，对资源的开销也更多。<br>
为了解决这个问题，新的解决方案引入了<code>FlutterEngine</code> 缓存机制。</p>
<h4 id="1-使用-flutterenginecache">1. 使用 FlutterEngineCache</h4>
<pre><code>// 实例化 FlutterEngine.
FlutterEngine flutterEngine = new FlutterEngine(context);

// 预热
 flutterEngine
  .getDartExecutor()
  .executeDartEntrypoint(
    DartEntrypoint.createDefault()
  );
  
 //放入 FlutterEngineCache
  FlutterEngineCache
  .getInstance()
  .put(&quot;my_engine_id&quot;, flutterEngine);
  
  //启动 Activity 的时候使用
  Intent intent = FlutterActivity
  .withCachedEngine(&quot;my_engine_id&quot;)
  .build();
  startActivity(intent);
  
  //实例化 Fragment
  FlutterFragment flutterFragment = FlutterFragment
  .withCachedEngine(&quot;my_engine_id&quot;)
  .build();
</code></pre>
<h4 id="2-继承-flutterfragment-flutteractivity">2. 继承 FlutterFragment / FlutterActivity</h4>
<p>自行处理存储 FlutterEngine 的地方</p>
<pre><code>public class MyFlutterFragment extends FlutterFragment {
  @Override
  @Nullable
  protected FlutterEngine provideFlutterEngine(@NonNull Context context) {
    //自行存储 FlutterEngine 实例
    return MyFlutterEngine.getFlutterEngine();

    //比如 Application 中
    return ((MyApp) context.getApplication).getFlutterEngine();
  }
}
</code></pre>
<pre><code>public class MyFlutterActivity extends FlutterActivity {
  @Nullable
  @Override
  public FlutterEngine provideFlutterEngine(@NonNull Context context) {
    FlutterEngine flutterEngine;
    //自行存储 FlutterEngine 实例
    flutterEngine = MyFlutterEngineCache.getFlutterEngine();
    
    //比如 Application 中
    flutterEngine = ((MyApp) getApplication()).getFlutterEngine();

    return flutterEngine;
  }
}
</code></pre>
<h4 id="3-在-activity-实现-flutterengineprovider-接口">3. 在 Activity 实现 FlutterEngineProvider 接口</h4>
<pre><code>public class MyActivity extends Activity implements FlutterEngineProvider {
  @Override
  @Nullable
  FlutterEngine provideFlutterEngine(@NonNull Context context) {
    //自行存储 FlutterEngine 实例
    return MyFlutterEngine.getFlutterEngine();
    
    //比如 Application 中
    return ((MyApp) context.getApplication).getFlutterEngine();
  }
}
</code></pre>
<h3 id="flutterboost-方案">FlutterBoost 方案</h3>
<blockquote>
<p>新一代 Flutter-Native 混合解决方案。 FlutterBoost是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL）。</p>
</blockquote>
<p>FlutterBoost 是闲鱼开源处理 Flutter-Native 混合开发的解决方案，是一个热门的方案，但和官方方案对比我认为有两个重要的异同点：</p>
<ol>
<li>当时闲鱼设计这个库其中的一个重要目的就是为了解决 FlutterEngine 无法重用的问题（当时 Flutter 团队还没有可以处理 FlutterEngine 重用的方案），而现在 Flutter 团队推出的新的解决方案也可以解决这个问题。</li>
<li>目前 Flutter 官方的方案的细粒度更小，可以通过 View 的方式调用 Flutter ，也就是说你可以只将画面中的某一个图表用 Flutter 替换。</li>
</ol>
<p>最后，官方的两种方案一种已经被舍弃一种还处于实验性阶段，目前最新方案的<code>Milestone</code> 是12月，所以到时候再次评估可行性。而国内大厂基本上各自都有自己的解决方案，所以目前使用官方方案的话还需要仔细评估。</p>
<h2 id="ios">iOs</h2>
<p><em>WIP</em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flutter 介绍 & 开发经验总结]]></title>
        <id>https://xiejinpeng007.github.io/post/introducing-the-flutter/</id>
        <link href="https://xiejinpeng007.github.io/post/introducing-the-flutter/">
        </link>
        <updated>2019-08-22T08:05:51.000Z</updated>
        <content type="html"><![CDATA[<h1 id="flutter-介绍-开发经验总结">Flutter 介绍 &amp; 开发经验总结</h1>
<h2 id="前言">前言</h2>
<p>Flutter 已经推出2年了，虽然一直在关注，但还是想等生态成熟一点再去踩坑。近期有一个需要使用跨平台技术的项目，在讨论后，我们选择使用 Flutter。开发完成之后，我这里总结一些重要的点，供大家参考。<br>
当然，要学习的话最后还是需要读一遍文档，然后自己 Coding。</p>
<h2 id="环境配置">环境配置：</h2>
<p>参考<a href="https://flutter-io.cn/docs/get-started/install/macos">官方文档</a></p>
<h2 id="dart-语言">Dart 语言</h2>
<p>Flutter 采用 Dart 语言，我使用之后的感受就是： 语法基本等于 Java + Javascript + 另外一些常见的语法，没太大学习成本，也没太大亮点，下面列一些值得一提的点。</p>
<ul>
<li>
<p>所有变量都是对象</p>
</li>
<li>
<p>静态语言</p>
</li>
<li>
<p>支持闭包</p>
</li>
<li>
<p>方法是顶级的</p>
</li>
<li>
<p>支持反射（Flutter 不支持反射）</p>
</li>
<li>
<p>没有可见性修饰符 属性/类前加<code>_</code>就是 private</p>
</li>
<li>
<p>Stream : 支持 map... 各类操作符，订阅等</p>
</li>
<li>
<p>异步：Dart 的异步操作也通过 <code>Futrue</code>（同 Javascript 中的 <code>Promise</code>） 的方式实现，也支持 <code>async</code> <code>await</code> 语法糖（自动包装为<code>Futrue</code>）。这并不是 Dart 特有的特性，网上有大量资料可以参考。</p>
</li>
<li>
<p>赋值操作符</p>
<ul>
<li>?:</li>
<li>??</li>
<li>??=</li>
</ul>
</li>
<li>
<p>可选方法参数</p>
</li>
</ul>
<pre><code> void setUser(String name,{id = '0'});
 //调用
 setUser('mario',id : '01');
</code></pre>
<ul>
<li>联级操作符</li>
</ul>
<pre><code>   var profit = Profit()
     ..fund = 'fund'
     ..profit = 'profit'
     ..profitValue = 'profitValue';
</code></pre>
<ul>
<li>dynamic 可以指代任何类型，不会进行类型检查。</li>
</ul>
<pre><code>var a = 'test';
(a as dynamic).hello();//编译器不会报错
</code></pre>
<h2 id="flutter">Flutter</h2>
<h3 id="widget-概念">Widget 概念</h3>
<blockquote>
<p>在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于APP主题数据传递的Theme等等，而原生开发中的控件通常只是指UI元素。</p>
</blockquote>
<p>我的理解为 Widget 的工作 = HTML + CSS 的工作。而且很多配置样式的属性名字和 CSS 中的名字差不多。</p>
<p>Widget 分为 <code>StatelessWidget</code> <code>StatefulWidget</code> 两种，他们的核心方法都是通过<code>build()</code>方法返回一个 Widget 。</p>
<pre><code>  @protected
  Widget build(BuildContext context);
</code></pre>
<ul>
<li><code>StatelessWidget</code> 的<code>build()</code>在 Widget 中。</li>
<li><code>StatefulWidget</code>由于必须创建相应的 <code>State&lt;T extends Widget&gt;</code> ,所以包括<code>build()</code>在内的相关生命周期方法都在<code>State</code>中。<br>
下面是<code>State</code>的生命周期，由于一个画面也是一个 Widget 所以也是一个画面的生命周期。</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/widget_lifecyle.jpg?raw=true" alt="widget_lifecyle.jpg" loading="lazy"></figure>
<h3 id="widget-目录-link">Widget 目录 ( <a href="https://flutterchina.club/widgets/material/">link</a> )</h3>
<figure data-type="image" tabindex="2"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/widgets.png?raw=true" alt="widgets.png" loading="lazy"></figure>
<p>上面是官方提供的所有的 Widget，可以看到基本上所有UI相关的内容都是通过不同类型的 Widget 来实现，通过<code>child/children</code>参数进行嵌套。</p>
<h4 id="不同风格的-widget">不同风格的 Widget</h4>
<p>除了基础 Widget 外，官方提供了 Material(Android) + Cupertino(ioS) 两种视觉风格的 Widget。<br>
例如你可以在使用一个 Marterial 风格的<code>RaisedButton</code>或是 Cuptino 风格的<code>CupertinoButton</code>，再也不用担心设计师让 Android 照着 ioS 做成一样了。</p>
<h4 id="layout-widget">Layout Widget</h4>
<p>还有用来控制布局的 Layout Widget ,作为容器来使用，看名字都大概知道什么作用了。</p>
<ul>
<li>Container</li>
<li>Padding</li>
<li>Center</li>
<li>Stack</li>
<li>Column</li>
<li>Row</li>
<li>Expanded</li>
<li>ListView</li>
</ul>
<h4 id="交互模型-widget">交互模型 Widget</h4>
<p>控制点击、滑动等交互的 Widget。<br>
在 Flutter 里点击事件并不是<code>setOnClickListener</code>的方式 ，而是给 Widget 外层加一层交互 Widget ，如点击可使用<code>GestureDetector</code>。<br>
例如给上面 Splash 画面中的<code>Image</code>加一个点击事件。</p>
<pre><code>  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }
  
  ==&gt;
  
  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: GestureDetector(
        onTap: () {
          //点击事件
        },
        child: Image.asset('images/logo.png'),
      ),
    );
  }
</code></pre>
<h4 id="sample">Sample</h4>
<p>所以，一个最基本的 Widget 长什么样？这是一个带有是否 login 检查的 Splash 画面。</p>
<ul>
<li>StatelessWidget</li>
</ul>
<pre><code>class SplashPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    checkLogin();
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }

// 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。
  checkLogin(BuildContext context) async {
    var sp = await SharedPreferences.getInstance();
    var token = sp.getString(&quot;X-Auth-Token&quot;);
    if (token != null &amp;&amp; token != &quot;&quot;)
      Navigator.pushNamedAndRemoveUntil(
          context, HomePage.routeName, (_) =&gt; false);
    else
      Navigator.pushNamed(context, LoginRegisterPage.routeName);
  }
}

</code></pre>
<ul>
<li>StatefulWidget</li>
</ul>
<pre><code>class SplashPage extends StatefulWidget {
  //创建相应的 State
  @override
  State createState() =&gt; _SplashState();
}

class _SplashState extends State&lt;SplashPage&gt; {
  @override
  void initState() {
    super.initState();
    checkLogin(context);
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      height: double.infinity,
      width: double.infinity,
      child: Image.asset('images/logo.png'),
    );
  }

// 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。
  checkLogin(BuildContext context) async {
    var sp = await SharedPreferences.getInstance();
    var token = sp.getString(&quot;X-Auth-Token&quot;);
    if (token != null &amp;&amp; token != &quot;&quot;)
      Navigator.pushNamedAndRemoveUntil(
          context, HomePage.routeName, (_) =&gt; false);
    else
      Navigator.pushNamed(context, LoginRegisterPage.routeName);
  }
  
  @override
  void dispose() {
      super.dispose();
    }
}

</code></pre>
<h3 id="app-结构">App 结构</h3>
<figure data-type="image" tabindex="3"><img src="https://github.com/xiejinpeng007/XLearnNotes/blob/master/Flutter/counterAppwidgertree.jpg?raw=true" alt="counterAppwidgertree.jpg" loading="lazy"></figure>
<p>上图是整个 Flutter App 的结构，从父节点开始分别是：</p>
<ol>
<li><code>MyApp</code>: 整个 App 的入口在<code>main.dart</code>的<code>main()</code>函数中，调用 <code>runApp(MyApp())</code>,而 MyApp 也是一个 Widget，只不过用来定义一些全局的内容，例如主题、多语言，路由</li>
<li><code>MaterialApp</code>: 一个 Material 风格的主题，对应的还有 CupertinoApp。</li>
<li><code>MyHomePage</code> <code>MyHomePageState</code> : 一个画面，也是 Widget。</li>
<li><code>Scaffold</code> : 定义了一个画面的一些基本效果，比如这里 AppBar、滑动效果等采用 Material 风格，另外还有 ioS 风格的 <code>CupertinoPageScaffold</code>。</li>
<li>剩下就是一些基本的组件。</li>
</ol>
<p>一个基本的 main.dart 大概长这样：</p>
<pre><code>void main() async {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  static final navigatorKey = GlobalKey&lt;NavigatorState&gt;();
  static NavigatorState get navigator =&gt; navigatorKey.currentState;

  @override
  Widget build(BuildContext context) {
    return  CupertinoApp(
        title: '',
        theme: CupertinoThemeData(
          primaryColor: Color(0xFFFFFFFF),
          barBackgroundColor: Color(0xFF515669),
          scaffoldBackgroundColor: Color(0xFF3C3B45),
        ),
        navigatorKey: navigatorKey,
        routes: {
          HomePage.routeName: (_) =&gt; HomePage(),
          LoginRegisterPage.routeName: (_) =&gt; LoginRegisterPage(),
          LoginPage.routeName: (_) =&gt; LoginPage(),
          ForgetPswPage.routeName: (_) =&gt; ForgetPswPage(),
          RegisterPage.routeName: (_) =&gt; RegisterPage(),
        },
        ),
        home: SplashPage(),
    );
  }
}

</code></pre>
<ul>
<li><code>theme</code> 定义了一个 ioS 风格的 CupertinoApp 主题（实际开发中可能需要同时使用 Material Cupertino 风格控件所以需要自定义主题）</li>
<li><code>routes</code> 参数注册路由表</li>
<li><code>home</code> 参数设置首次加载的 Splash 画面</li>
</ul>
<h3 id="路由">路由</h3>
<p>和 Web 中的路由类似，通过在路由表注册相应的 url 和画面。基本方法</p>
<ul>
<li>push / pushNamed / pushNamedAndRemoveUntil/...</li>
<li>pop / popUntil / ...</li>
</ul>
<p>基本使用：</p>
<pre><code>// pushNamed 的定义
Future pushNamed(BuildContext context, String routeName,{Object arguments})

//打开一个画面，传一个00
Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: '00');

//新画面接受参数
var arg = ModalRoute.of(context).settings.arguments);

//关闭一个画面，返回一个01
Navigator.of(context).pop(01);

</code></pre>
<ul>
<li>实际上更好的方法来处理传值的问题</li>
<li>可以看到<code>pushNamed</code>方法返回值是一个<code>Future</code> ，说明是一个异步操作，因为可以接受打开的画面<code>pop</code>关闭时返回的<code>result</code> ，此处在<code>pop</code>时返回了一个 01，那么就可以这样接收到。</li>
</ul>
<pre><code>var result = async Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: 'arg');
</code></pre>
<h3 id="网络请求和序列化">网络请求和序列化</h3>
<p>Flutter 的 网络请求库没有特别完美的，目前使用的是 <a href="https://github.com/flutterchina/dio">Dio</a> ,大致是一个简化版的 okhttp 。</p>
<p>由于 Flutter 禁止使用反射，因为运行时反射会干扰 Dart 的 tree shaking，所以类似 Gson 这样通过反射进行序列化的方式就行不通了。<br>
目前大概的解决方案有两种：</p>
<ul>
<li>手写：<code>Dio</code> 会把返回值解析为 Map/List ，所以可以这样手写:</li>
</ul>
<pre><code>  Future&lt;Profits&gt; requestProfits() async {
    var response = await dio.get(&quot;u/profits&quot;);
    var data = response.data;
    print(&quot;requestProfits:$data&quot;);

    var profit = Profit()
      ..fund = data['profit'][&quot;fund&quot;]
      ..profit = data['profit'][&quot;profit&quot;]
      ..profitValue = toMoney(data['profit']['profitValue']);

    return Profits()
      ..miningProfit = data['miningProfit']
      ..lastMiningProfit = data['lastMiningProfit']
      ..shareProfit = data['shareProfit']
      ..lastShareProfit = data['lastShareProfit']
      ..tradeProfit = data['tradeProfit']
      ..lastTradeProfit = data['lastTradeProfit']
      ..vipProfit = data['vipProfit']
      ..lastVipProfit = data['lastVipProfit']
      ..profit = profit;
  }
</code></pre>
<ul>
<li>生成代码：使用 <a href="https://pub.dev/packages/json_serializable">json_serializable</a></li>
</ul>
<pre><code>//user.dart

import 'package:json_annotation/json_annotation.dart';

// user.g.dart 将在我们运行生成命令后自动生成
part 'user.g.dart';

///这个标注是告诉生成器，这个类是需要生成Model类的
@JsonSerializable()

class User{
  User(this.name, this.email);

  String name;
  String email;
  //不同的类使用不同的mixin即可
  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);
  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);  
}
</code></pre>
<p>当然，还是需要写 <code>fromJson</code> <code>toJson</code> 的模板代码，也可以通过生成的方式解决。</p>
<h3 id="平台特定代码">平台特定代码</h3>
<p>Flutter 主要是负责了UI部分的构建，各平台特定的代码还是要通过原生实现，主要用两种方法处理：</p>
<ul>
<li><code>Platform Channel</code> : 大概就是 Flutter 端和原生端注册约定好 <code>platform_channel_name</code> 的 <code>Platform Channel</code>  ，然后调用方法和传参，另一端解析就行了。具有原生能力的 plugin 也就是这样实现的。比如</li>
</ul>
<pre><code>//flutter
MethodChannel('method_channel_mobile').invokeMethod('sendMobile','13000000000')

//Android MainActivity

MethodChannel(flutterView, MOBILE_CHANNEL)
            .setMethodCallHandler { methodCall, result -&gt;
                when {
                    TextUtils.equals(methodCall.method, &quot;mobile&quot;) -&gt; {
                        mobile = methodCall.arguments.toString()
                        result.success(&quot;success&quot;)
                    }
                     result.notImplemented()
                }
            }
</code></pre>
<ul>
<li><code>PlatformView</code> 直接嵌套原生的 View 到 Flutter 中，但这样做效率不高。另外需要注意的是不要传入一个 view 到<code>PlatformView</code>中，否则可能出现 Flutter 端多次调用该<code>PlatformView</code>的时候状态会共存，以及不会销毁。</li>
</ul>
<pre><code>// 定义一个用于的 PlatformView 和 PlatformViewFactory 用于实例化 Native View 
class ButtonFactory(
    private val context: Context
) : PlatformViewFactory(StandardMessageCodec.INSTANCE) {

    override fun create(p0: Context?, p1: Int, p2: Any?): PlatformView {
        return ButtonPlatformView(context)
    }
    class ButtonPlatformView(
        private val context: Context
    ) : PlatformView {

        override fun getView(): Button {
            return Button(context)
        }
        override fun dispose() {
        }
    }
}

//在 MainActivity 中注册
        registrarFor(&quot;native_view&quot;).platformViewRegistry()
            .registerViewFactory(&quot;native_view&quot;,ButtonPlatformFactory)
</code></pre>
<h3 id="widget-嵌套的问题">Widget 嵌套的问题</h3>
<p>网上对 Flutter 嵌套讨论的比较多的问题就是，UI 复杂了以后，嵌套层数太多。<br>
确实有这个问题，之前说了 Widget 不光是 View 还包括配置文件，所以一个类似 Button 这样的 Widget 可能就需要嵌套3 4层。<br>
下面是我写的一个登录画面的登录按钮，感受一下:</p>
<pre><code>  CupertinoButton _loginButton() {
    return CupertinoButton(
      padding: EdgeInsets.all(0),
      child: Container(
          width: double.infinity,
          height: 45,
          decoration: BoxDecoration(
            gradient: LinearGradient(
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
                colors: _isLoginAvailable
                    ? &lt;Color&gt;[Color(0xFF657FF8), Color(0xFF4260E8)]
                    : &lt;Color&gt;[Color(0xFFCBCFE2), Color(0xFF73788F)]),
            borderRadius: BorderRadius.all(Radius.circular(6)),
          ),
          child: Center(
            child: Text(
              &quot;登 录&quot;,
              textAlign: TextAlign.center,
              style: TextStyle(
                fontSize: 18,
                color: _isLoginAvailable ? Colors.white : Color(0x76FFFFFF),
                fontWeight: FontWeight.bold,
              ),
            ),
          )),
//      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
      onPressed: !_isLoginAvailable ? null : _startCustomFlow,
    );
  }
</code></pre>
<p>实际上这还是只是结构+样式部分，不包括点击后的逻辑。<br>
甚至你可以看到 Button 中的文字也是通过嵌套一个 Widget 来实现的，但这也是 Flutter 的一个优势，不再需要写自定义 Widget 的人去提供大量像文字能不能加粗，变色、斜体等等细节的样式，直接让你传一个 Widget 自行处理，类似的情况还有很多。<br>
另外一个问题是 Widget State 的状态可能太多，包括各个 Widget 的状态和画面的状态堆在一起，想起了当年原生 Android 一个 Activity 50个变量的恐惧。<br>
但我认为这些主要还是因为 Flutter 处于发展的初期，还没有太成熟的架构，目前官方提供了状态管理的库 <code>Provider</code>。<br>
我目前的解决方案是尽量提成方法和独立的Widget：</p>
<ul>
<li>对于有整个页面无关局部状态的 Widget 提成一个独立的 <code>StatefulWidget</code>。</li>
<li>对于没有局部状态的，需要重用就提成一个<code>StatelessWidget</code>，不需要就抽成一个方法，返回 Widget，参考上面的 Button 。</li>
<li>最后在<code>build()</code>方法中只描述整个画面的结构。</li>
</ul>
<p>例如一个 login 画面的<code>build()</code>方法我是这样写的：</p>
<pre><code>  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: Scaffold(
        appBar: cusAppBar(context, elevation: 0),
        backgroundColor: $3C3B45,
        body: Stack(
          children: &lt;Widget&gt;[
            SingleChildScrollView(
              child: Container(
                margin: EdgeInsets.only(left: 15, right: 15),
                child: Column(
                  children: &lt;Widget&gt;[
                    _logo(),
                    Form(
                      onChanged: _onFormChanged,
                      child: Column(
                        children: &lt;Widget&gt;[
                          _phoneRow(),
                          _divider(),
                          _passwordColumn(),
                          _forgetPswText(),
                          _loginButton(),
                          _registerText()
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
</code></pre>
<h3 id="热重载hotreload">热重载（HotReload）</h3>
<p>Flutter 的热重载是广受欢迎的一个特性，重要原因则是 Debug 模式采用 JIT 编译，release 模式采用 AOT 编译。实际用下来效果不错。</p>
<h3 id="问题">问题</h3>
<ul>
<li>编译偶尔遇到的一个问题：<br>
问题：Waiting for another flutter command to release the startup lock...<br>
解决：rm ./flutter/bin/cache/lockfile</li>
</ul>
<h5 id="最后以上只是总结一些重要的点最终官方文档肯定是要读一遍的熟悉大部分-widget-的用法-文档">最后，以上只是总结一些重要的点，最终官方文档肯定是要读一遍的,熟悉大部分 Widget 的用法: <a href="https://flutterchina.club/docs/">文档</a></h5>
<h3 id="总结">总结</h3>
<p>优点：</p>
<ul>
<li><code>Android iOs 两端 UI 高度一致</code>：由于 Flutter 使用自己的一套绘制 UI 的引擎和逻辑，完全不使用 Native View，仅仅调用原生的绘制接口，所以几乎可以做到两个平台的 UI 一模一样，这也是 Flutter 还要做 Web maCos 等全平台的原因。我在开发期间一直使用 Android 进行调试，最后在 Ios 上跑的时候，几乎没有什么差别(虽然目前 UI 也不太复杂)。</li>
<li><code>接入原生相对容易</code>：需要原生实现的功能通过<code>PlatformChannel</code>和 <code>PlatformView</code>也大多都能实现，还可以通过<code>PlatformChannel</code>来启动一个原生的<code>Activity/Fragment</code>实现。（比如扫一扫功能）</li>
<li><code>贵族血统</code>：Google 的全力支持，国内大厂也都在积极尝试。</li>
<li><code>初步可用的程度</code>：目前已经完成了一个小项目的开发，在和原生交互不多的情况下还没有遇到太大的坑。</li>
</ul>
<p>缺点：</p>
<ul>
<li><code>基础功能的缺失</code>：很多基础的功能也需要用 plugin 通过原生来实现，比如 Webview Map 这些组件，更不要说一些 SDK ,几乎都需要自己写 plugin。</li>
<li><code>跨平台的通信</code>：对于大量使用<code>MethodChannel</code>进行通信以及各平台间API有差异的情况下，设计和维护的问题。</li>
<li><code>性能</code>：目前原生 Flutter 在帧数上接近原生，用户使用体验接近，但内存开销更大，尤其在视频方面。</li>
</ul>
<p>总的来说：我的看法是，比较看好 Flutter 跨更多平台的前途，目前来说适合用来开发和原生平台 API 交互不那么复杂的 App 。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[配置 Gitlab-CI 触发企业微信群机器人发送通知]]></title>
        <id>https://xiejinpeng007.github.io/post/pei-zhi-gitlab-ci-hong-fa-qi-ye-wei-xin-qun-ji-qi-ren-fa-song-tong-zhi/</id>
        <link href="https://xiejinpeng007.github.io/post/pei-zhi-gitlab-ci-hong-fa-qi-ye-wei-xin-qun-ji-qi-ren-fa-song-tong-zhi/">
        </link>
        <updated>2019-07-02T10:22:15.000Z</updated>
        <content type="html"><![CDATA[<h3 id="配置-gitlab-ci-触发企业微信群机器人发送通知">配置 Gitlab-CI 触发企业微信群机器人发送通知</h3>
<p>最近企业微信增加了群机器人功能，可以拿来在 Gitlab-CI 打包完成后发送通知，分享下配置方法：</p>
<h4 id="配置群机器人">配置群机器人:</h4>
<ol>
<li>
<p>在相应群右键-添加群机器人-设置相关参数</p>
</li>
<li>
<p>可以看到给出了相应的 Webhook 地址和使用文档,本质就是发一个 POST 请求。 url 包含了相关 key , JSON 包含消息内容。<br>
消息内容支持三种类型，具体语法可以参考文档。</p>
<ul>
<li>text</li>
<li>markdown</li>
<li>图文</li>
</ul>
</li>
<li>
<p>然后可以用 Postman 或者 Terminal 来测试能否收到（替换为自己的 WebHook）。</p>
</li>
</ol>
<pre><code>curl 'http://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx' \
   -H 'Content-Type: application/json' \
   -d '
   {
        &quot;msgtype&quot;: &quot;text&quot;,
        &quot;text&quot;: {
            &quot;content&quot;: &quot;hello world&quot;
        }
   }'
</code></pre>
<h4 id="配置到-gitlab-ci">配置到 Gitlab-CI:</h4>
<p>在原来正常的打包流程基础上，写一个打包成功(失败)后触发的脚本，放在和 gitlab-ci.yml 同级，传入不同参数，发送不同数据，我这里通过第一个参数判断成功失败：</p>
<ul>
<li>成功的参数: on_success branch_name commit_hash apk_name</li>
<li>失败的参数：on_failure</li>
</ul>
<pre><code>#!/usr/bin/env bash

if [[ $1 == &quot;on_success&quot; ]];
then
curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \
      -H 'Content-Type: application/json' \
      -d '
      {
        &quot;msgtype&quot;: &quot;markdown&quot;,
        &quot;markdown&quot;: {
          &quot;content&quot;: &quot;分支:'$2'   提交:'$3'
          '$4'.apk 打包完成！
          [点击查看](https://your_url/pipelines)&quot;
        }
      }'
elif [[ $1 == &quot;on_failure&quot; ]];
then
curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \
      -H 'Content-Type: application/json' \
      -d '
      {
        &quot;msgtype&quot;: &quot;markdown&quot;,
        &quot;markdown&quot;: {
          &quot;content&quot;: &quot;打包失败！
          [点击查看](https://your_url/pipelines)&quot;
        }
      }'
fi
</code></pre>
<p>改一下 gitlab-ci.yml 文件中的配置调用脚本:</p>
<pre><code>...
build_production_release:
  stage: build_production_release
  script:
    - ./gradlew assembleProductionRelease
    - mv app/build/outputs/apk/production/release/*.apk .
    - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;
  artifacts:
    name: &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;
    paths:
      - ./*.apk
    expire_in: 2 weeks
  when: manual
    # except:
    # - feature/CI-CD

clean_build_job:
  stage: clean
  script:
    - ./gradlew clean
    - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot;
  when: on_failure
  ...
</code></pre>
<ul>
<li>
<p>在打包的 job ( build_production_release ) <code>./gradle assemblexxx</code> 之后传入相关参数调用脚本成功的代码<br>
<code>sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot;</code></p>
</li>
<li>
<p>打包失败时的 job ( clean_build_job ) 传入 on_failure 调用脚本失败的代码<br>
<code>sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot;</code></p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用 XDslPagerAdapter 快速创建 ViewPager]]></title>
        <id>https://xiejinpeng007.github.io/post/shi-yong-xdslpageradapter-kuai-su-chuang-jian-viewpager/</id>
        <link href="https://xiejinpeng007.github.io/post/shi-yong-xdslpageradapter-kuai-su-chuang-jian-viewpager/">
        </link>
        <updated>2019-04-09T09:24:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="使用-xdslpageradapter-快速创建-viewpager">使用 XDslPagerAdapter 快速创建 ViewPager</h2>
<p>在 Android 开发中经常需要使用 ViewPager ，大多数的功能类似但每次都需要写 Adapter 和一堆模板代码。<br>
目前我们很多项目都使用了 Kotlin 和 Databinding,为了简洁快速地构建 ViewPager，我使用 DSL 和 Databinding 的特性写了一个用于快速创建 PagerAdapter 的工具<code>XDslPagerAdapter</code>。</p>
<p>下面通过创建一个欢迎画面举例说明：</p>
<pre><code>        binding.guideViewPager.run {
            xDslPagerAdapter {
                item(R.layout.pager_guide) {
                    model(BR.model to Page(0, R.drawable.img_tutorial01, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 1 })
                    action { binding -&gt;
                        (binding as? PagerGuideBinding)?.run {
                            (nextPageButton.layoutParams as? ViewGroup.MarginLayoutParams)?.run {
                                marginStart = dp2px(30F)
                                marginEnd = dp2px(30F)
                            }
                        }
                    }
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(1, R.drawable.img_tutorial02, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 2 })
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(2, R.drawable.img_tutorial03, &quot;下一页&quot;))
                    click(BR.click to { _: Page -&gt; currentItem = 3 })
                }
                item(R.layout.pager_guide) {
                    model(BR.model to Page(3, R.drawable.img_tutorial04, &quot;开始使用&quot;))
                    click(BR.click to { _: Page -&gt;
                        SharedPrefModel.isFistTime = false
                        startActivity(Intent(context, MainActivity::class.java))
                        finish()
                    })
                }
            }
        }
</code></pre>
<ol>
<li>首先调用 ViewPager 的拓展方法<code>xDslPagerAdapter()</code>开始创建<code>PagerAdapter</code></li>
<li>在<code>PagerAdapter</code>内部使用 <code>item()</code>开始创建<code>Item</code>，其中<code>layout</code>是必须的参数。</li>
<li>在<code>Item</code>内部可以使用的方法有<code>model()``click()``action</code>
<ul>
<li><code>model()</code>传入包含 DataBinding 的 <code>BR.Id</code> 和对应的 <code>Model</code>（类型为你 ViewModel 的类型，用来绑定显示相关数据）</li>
<li><code>click()</code>传入包含 DataBinding 的 <code>BR.Id</code> 和对应的 <code>Click</code>（类型为<code>Function&lt;Any&gt;</code>用来绑定点击事件），多个点击事件可多次调用。</li>
<li><code>action()</code>可用来获取 Databinding 为 layout 的 ViewDataBinding 类,用来处理其它的内容，例如动态改变布局等。</li>
</ul>
</li>
</ol>
<p>源码也很简单 源码地址 <a href="https://github.com/xiejinpeng007/XDslPagerAdapter">https://github.com/xiejinpeng007/XDslPagerAdapter</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[RxJava2.x 从源码分析原理]]></title>
        <id>https://xiejinpeng007.github.io/post/rxjava2x-cong-yuan-ma-fen-xi-yuan-li/</id>
        <link href="https://xiejinpeng007.github.io/post/rxjava2x-cong-yuan-ma-fen-xi-yuan-li/">
        </link>
        <updated>2019-02-11T09:24:07.000Z</updated>
        <content type="html"><![CDATA[<p>RxJava 相信各位已经使用了很久，大部分人在刚学习 RxJava 感叹切换线程的方便，调用逻辑清晰的同时，并不知道其中的原理，主要是靠记住运行的顺序。<br>
随着我们设计出的 RxJava流 越来越复杂，一些复杂的问题并不能靠着记住的运行顺序就能解决。<br>
下面，就通过最常用的操作符的源码来看看所谓的<code>流</code>是什么运行的。</p>
<p>首先我们用<code>Single</code>举例，设计一个最基本的 RxJava 流，只有一个 <code>Observable(ColdObservable)</code> 和<code>Obsever</code>：</p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
              			.subscribe(it -&gt; Log.i(&quot;subscribe&quot;, it));
</code></pre>
<p>上游发送一个<code>&quot;wtf&quot;</code> ，下游接受时将其打印出来。上游发送端使用 <code>Single.just</code> 作为创建方法,<br>
看一下 <code>just()</code> 方法里做了什么。</p>
<pre><code>    public static &lt;T&gt; Single&lt;T&gt; just(final T item) {
        ObjectHelper.requireNonNull(item, &quot;value is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item));
    }
    
    public static &lt;T&gt; Single&lt;T&gt; onAssembly(@NonNull Single&lt;T&gt; source) {
    Function&lt;? super Single, ? extends Single&gt; f = onSingleAssembly;
    if (f != null) {
        return apply(f, source);
    }
    return source;
}
</code></pre>
<p>其中 <code>ObjectHelper.requireNonNull</code> 只是空检查。<br>
<code>RxJavaPlugins.onAssembly</code> 方法，这个方法其实就是通过一个全局的变量 <code>onSingleAssembly</code> 来对方法进行 Hook ，这一系列<code>xxxAssembly</code>全局变量默认为空，所以实际上当我们没有设置的时候其实 <code>just</code> 方法是直接返回了一个 新实例化的<code>SingleJust</code>对象。</p>
<p>再看看<code>SingleJust</code>内部：</p>
<pre><code>public final class SingleJust&lt;T&gt; extends Single&lt;T&gt; {

    final T value;
    public SingleJust(T value) {
        this.value = value;
    }

    @Override
    protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) {
        observer.onSubscribe(Disposables.disposed());
        observer.onSuccess(value);
    }

}

</code></pre>
<p>实例化的时候只是将值保存了下来，没有其它操作。<br>
下一步调用<code>subscribe()</code>来启动这个流<code>(ColdObservable)</code>，然后看看<code>subscribe</code>中做了什么：</p>
<pre><code>    public final void subscribe(SingleObserver&lt;? super T&gt; subscriber) {
        ObjectHelper.requireNonNull(subscriber, &quot;subscriber is null&quot;);
        subscriber = RxJavaPlugins.onSubscribe(this, subscriber);
        ObjectHelper.requireNonNull(subscriber, &quot;subscriber returned by the RxJavaPlugins hook is null&quot;);

        try {
 	         //核心逻辑
            subscribeActual(subscriber);
        } catch (NullPointerException ex) {
            throw ex;
        } catch (Throwable ex) {
            Exceptions.throwIfFatal(ex);
            NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;);
            npe.initCause(ex);
            throw npe;
        }
    }
</code></pre>
<p>同样 <code>RxJavaPlugins.onSubscribe</code>  默认没有作用,实际的核心逻辑是调用了<code>subscribeActual(SingleObserver)</code>。<br>
对于我们上面设计的流，则是调用了 SingleJust 中的 <code>subscribeActual(SingleObserver)</code></p>
<p>回顾上面 <code>SingleJust</code> 中 <code>subscribeActual(SingleObserver)</code> 的实现：</p>
<pre><code>        observer.onSubscribe(Disposables.disposed());
        observer.onSuccess(value);
</code></pre>
<p>得到两个信息</p>
<ul>
<li>首先调用下游观察者 <code>SingleObserver</code> 的 <code>OnSubscribe</code> 方法并传递用于取消操作的 <code>Disposable</code></li>
<li>调用<code>OnSuccess</code> 方法并传递之前保存下来的 <code>value</code></li>
</ul>
<h3 id="map-操作符">Map 操作符</h3>
<p>现在我们加入一个常用且重要的<code>Map</code>操作到流中</p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .map(it-&gt; 0)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it)));
</code></pre>
<p>上面这个流包括了三种典型的操作 创建<code>Creation</code> 操作符<code>Transformation</code>和 订阅<code>Subscribe</code>。</p>
<p>依然先检查<code>map()</code> 方法，可以看到其中实例化了一个<code>SingleMap</code></p>
<pre><code>    public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) {
        ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper));
    }
</code></pre>
<p>再看看 <code>SingleMap</code></p>
<pre><code>public final class SingleMap&lt;T, R&gt; extends Single&lt;R&gt; {
    final SingleSource&lt;? extends T&gt; source;
    final Function&lt;? super T, ? extends R&gt; mapper;

    public SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? super T, ? extends R&gt; mapper) {
        this.source = source;
        this.mapper = mapper;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) {
        source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper));
    }

    static final class MapSingleObserver&lt;T, R&gt; implements SingleObserver&lt;T&gt; {

        final SingleObserver&lt;? super R&gt; t;
        final Function&lt;? super T, ? extends R&gt; mapper;

        MapSingleObserver(SingleObserver&lt;? super R&gt; t, Function&lt;? super T, ? extends R&gt; mapper) {
            this.t = t;
            this.mapper = mapper;
        }

        @Override
        public void onSubscribe(Disposable d) {
            t.onSubscribe(d);
        }

        @Override
        public void onSuccess(T value) {
            R v;
            try {
                v = ObjectHelper.requireNonNull(mapper.apply(value), &quot;The mapper function returned a null value.&quot;);
            } catch (Throwable e) {
                Exceptions.throwIfFatal(e);
                onError(e);
                return;
            }

            t.onSuccess(v);
        }

        @Override
        public void onError(Throwable e) {
            t.onError(e);
        }
    }
}
</code></pre>
<p>类中信息稍微复杂一些：</p>
<ol>
<li>首先我们关注在<code>SingleMap</code>实例化的时候也是只做了保存数据的操作，而没有实际逻辑：将流的上游保存为 <code>source</code> 将数据转换的方法保存为 <code>mapper</code></li>
<li>第二步我们知道下游观察者 <code>SingleObserver</code> 会调用核心逻辑 <code>subscribeActual</code>方法来启动流</li>
<li>在这里的<code>subscribeActual</code>方法中可以看到几个重要的信息
<ul>
<li><code>MapSingleObserver</code>是一个观察者</li>
<li><code>MapSingleObserver</code> 保存了下游的观察者 <code>SingleObserver</code> 以及 <code>mapper</code></li>
<li>上游 <code>source</code> 被 <code>MapSingleObserver</code> 订阅</li>
</ul>
</li>
</ol>
<p>由此可以看出在<code>SingleMap</code>被下游观察者订阅了之后，实例化了一个新的观察者<code>MapSingleObserver</code>并保存下游观察者<code>SingleObserver</code>的信息，再去订阅上游<code>SingleJust</code>。<br>
这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能的设计模式称为<code>装饰者模式</code>。</p>
<p>总结上面的执行顺序：</p>
<ol>
<li>在<code>Rx流</code>的最后一步调用 <code>subscribe</code>启动流<code>(ColdObservable)</code></li>
<li>首先执行<code>SingleMap</code>中的<code>subscribeActual</code>方法，其中包括生成新的<code>MapSingleObserver</code>并订阅 <code>SingleJust</code></li>
<li>执行<code>SingleJust</code>中的<code>subscribeActual</code>：调用下游<code>MapSingleObserver</code>的<code>onSubscribe</code> <code>onSuccess</code>方法</li>
<li><code>MapSingleObserver</code>中的<code>onSubsribe</code> <code>onSuccess</code>方法也很简单，分别调用下游 <code>Observer</code>的 <code>onSubsribe``onSuccess(异常时 onError)</code>方法</li>
</ol>
<h3 id="observeon-操作符">observeOn 操作符</h3>
<p>Rxjava首先被大家津津乐道之处是可以方便的切换线程，避免<code>Callback Hell</code>，现在来看看线程切换操作符。<br>
我们加入线程切换操作符 <code>observeOn</code></p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .map(it-&gt; 0)
				 .observeOn(Schedulers.io())
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it)));
</code></pre>
<p>同样的，在 <code>observeOn</code>方法中实例化了一个<code>SingleObserveOn</code></p>
<pre><code>    public final Single&lt;T&gt; observeOn(final Scheduler scheduler) {
        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
        return RxJavaPlugins.onAssembly(new SingleObserveOn&lt;T&gt;(this, scheduler));
    }
</code></pre>
<p>继续看<code>SingleObserveOn</code>类中信息</p>
<pre><code>public final class SingleObserveOn&lt;T&gt; extends Single&lt;T&gt; {

    final SingleSource&lt;T&gt; source;
    final Scheduler scheduler;

    public SingleObserveOn(SingleSource&lt;T&gt; source, Scheduler scheduler) {
        this.source = source;
        this.scheduler = scheduler;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) {
        source.subscribe(new ObserveOnSingleObserver&lt;T&gt;(s, scheduler));
    }

    static final class ObserveOnSingleObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt;
    implements SingleObserver&lt;T&gt;, Disposable, Runnable {
        private static final long serialVersionUID = 3528003840217436037L;

        final SingleObserver&lt;? super T&gt; actual;
        final Scheduler scheduler;

        T value;
        Throwable error;

        ObserveOnSingleObserver(SingleObserver&lt;? super T&gt; actual, Scheduler scheduler) {
            this.actual = actual;
            this.scheduler = scheduler;
        }

        @Override
        public void onSubscribe(Disposable d) {
            if (DisposableHelper.setOnce(this, d)) {
                actual.onSubscribe(this);
            }
        }

        @Override
        public void onSuccess(T value) {
            this.value = value;
            Disposable d = scheduler.scheduleDirect(this);
            DisposableHelper.replace(this, d);
        }

        @Override
        public void onError(Throwable e) {
            this.error = e;
            Disposable d = scheduler.scheduleDirect(this);
            DisposableHelper.replace(this, d);
        }

        @Override
        public void run() {
            Throwable ex = error;
            if (ex != null) {
                actual.onError(ex);
            } else {
                actual.onSuccess(value);
            }
        }

        @Override
        public void dispose() {
            DisposableHelper.dispose(this);
        }

        @Override
        public boolean isDisposed() {
            return DisposableHelper.isDisposed(get());
        }
    }
}


</code></pre>
<p>类似的</p>
<ul>
<li>构造函数中保存了上游和线程切换的信息</li>
<li><code>subscribeActual</code> 实例化了一个新的观察者<code>ObserveOnSingleObserver</code></li>
</ul>
<p>不同的</p>
<ul>
<li><code>ObserveOnSingleObserver</code> 还继承了<code>AtomicReference&lt;Disposable&gt;</code>、实现了<code>Disposable``Runnable</code>接口</li>
<li><code>onSuccess``onError</code>中都没有直接调用下游的<code>onSuccess</code> <code>onError</code>方法，而是调用了<code>Disposable d = scheduler.scheduleDirect(this);</code>来执行<code>run</code>方法中的逻辑，而<code>run</code>方法中的逻辑则是调用下游的<code>onSuccess</code> <code>onError</code>方法</li>
</ul>
<p>查看<code>schedulerDirect</code>内部信息</p>
<pre><code>    public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {
        final Worker w = createWorker();
        final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);
        DisposeTask task = new DisposeTask(decoratedRun, w);
        w.schedule(task, delay, unit);
        return task;
    }
</code></pre>
<p>创建了一个对应线程的<code>Worker</code>和一个可用于取消的<code>DisposeTask</code>并执行，对于<code>IoScheduler</code>则是创建了<code>EventLoopWorker</code>，再看看<code>EventLoopWorker</code>中的信息。</p>
<pre><code>    @Override
    public Worker createWorker() {
        return new EventLoopWorker(pool.get());
    }
</code></pre>
<pre><code>    static final class EventLoopWorker extends Scheduler.Worker {
        private final CompositeDisposable tasks;
        private final CachedWorkerPool pool;
        private final ThreadWorker threadWorker;

        final AtomicBoolean once = new AtomicBoolean();

        EventLoopWorker(CachedWorkerPool pool) {
            this.pool = pool;
            this.tasks = new CompositeDisposable();
            this.threadWorker = pool.get();
        }

        @Override
        public void dispose() {
            if (once.compareAndSet(false, true)) {
                tasks.dispose();

                // releasing the pool should be the last action
                pool.release(threadWorker);
            }
        }

        @Override
        public boolean isDisposed() {
            return once.get();
        }

        @NonNull
        @Override
        public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) {
            if (tasks.isDisposed()) {
                // don't schedule, we are unsubscribed
                return EmptyDisposable.INSTANCE;
            }

            return threadWorker.scheduleActual(action, delayTime, unit, tasks);
        }
    }
</code></pre>
<p><code>EventLoopWorker</code>中则是维护了一套包含相应的<code>线程池</code>、可取消的<code>CompositeDisposable</code>、以及用于运行<code>Runable</code>的<code>ThreadWorker</code>。总的来说就是一套可以在相应线程运行且可取消的类和逻辑。</p>
<ul>
<li>上面则解释了为什么<code>observeOn</code>可以切换下游的线程(<code>onSuccess</code> <code>onError</code>)</li>
<li>同样解释了为什么不会改变<code>onSubsribe</code>的调用线程，因为可以看到<code>onSubscribe</code>方法中直接调用了下游的<code>onSucsribe</code>，并没有受到线程切换的影响。</li>
</ul>
<h3 id="subscribeon">SubscribeOn</h3>
<p>实际上，<code>subsribeOn</code> 是 RxJava2.x 中比较复杂也是相较于 RxJava1.x 改动比较大的一个操作符,它甚至会影响流的执行顺序。（可以参见唐雪茂写的 <a href="https://lexiangla.com/teams/k100002/docs/d00dcc362b2311e8a1c75254004b6d18?company_from=1656b36e07d011e8b7a85254005b9a60">Rxjava流的设计</a> 中的<code>1</code> <code>2</code>两个流）</p>
<p>我们现在设计两个<code>Rx流</code></p>
<pre><code>Disposable disposable = Single.just(&quot;wtf&quot;)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4);
</code></pre>
<pre><code>Disposable disposable2 = Single.just(&quot;wtf&quot;)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1)
				 .subscribeOn(Schedulers.io())
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2)
				 .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3)
                 .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4);
</code></pre>
<p>你可能已经知道并记住了两个流的打印的顺序分别是 <code>01234</code> <code>23014</code>，但是为什么<code>doOnSubsribe</code>方法和<code>RxJava1</code>中调用顺序完全不一样，为什么通过<code>subscribeOn</code>切换线程会影响执行顺序？</p>
<p>先找到 <code>SingleSubscribeOn</code> 类</p>
<pre><code>public final class SingleSubscribeOn&lt;T&gt; extends Single&lt;T&gt; {
    final SingleSource&lt;? extends T&gt; source;
    final Scheduler scheduler;
    
    public SingleSubscribeOn(SingleSource&lt;? extends T&gt; source, Scheduler scheduler) {
        this.source = source;
        this.scheduler = scheduler;
    }

    @Override
    protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) {
        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s, source);
        //直接调用下游 onSubscribe
        s.onSubscribe(parent);
        //再执行订阅上游的方法
        Disposable f = scheduler.scheduleDirect(parent);
        parent.task.replace(f);
    }

    static final class SubscribeOnObserver&lt;T&gt;
    extends AtomicReference&lt;Disposable&gt;
    implements SingleObserver&lt;T&gt;, Disposable, Runnable {

        private static final long serialVersionUID = 7000911171163930287L;
        final SingleObserver&lt;? super T&gt; actual;
        final SequentialDisposable task;
        final SingleSource&lt;? extends T&gt; source;
        
        SubscribeOnObserver(SingleObserver&lt;? super T&gt; actual, SingleSource&lt;? extends T&gt; source) {
            this.actual = actual;
            this.source = source;
            this.task = new SequentialDisposable();
        }

        @Override
        public void onSubscribe(Disposable d) {
        	  //没有继续调用下游的 onSubscribe 方法
            DisposableHelper.setOnce(this, d);
        }

        @Override
        public void onSuccess(T value) {
            actual.onSuccess(value);
        }

        @Override
        public void onError(Throwable e) {
            actual.onError(e);
        }

        @Override
        public void dispose() {
            DisposableHelper.dispose(this);
            task.dispose();
        }

        @Override
        public boolean isDisposed() {
            return DisposableHelper.isDisposed(get());
        }

        @Override
        public void run() {
            source.subscribe(this);
        }
    }

}
</code></pre>
<p>同样的直接看<code>subscribeActual</code>方法及<code>onSubscribe</code>方法，发现事情并没有那么简单，和之前的操作符的逻辑区别很大：</p>
<ul>
<li><code>SubscribeOnObserver</code>同样还继承了<code>AtomicReference&lt;Disposable&gt;</code>，实现了<code>Disposable``Runnable</code>接口</li>
<li>并没有直接调用<code>subscribe</code>订阅上游，而是执行了其它操作符在 <code>onSubscribe</code>中订阅下游的操作</li>
<li>然后再结合<code>Disposable f = scheduler.scheduleDirect(parent);</code>和<code>run</code>方法可以知道在新的线程中执行了订阅上游的操作 <code>source.subscribe(this);</code></li>
<li><code>onSubsribe</code>中并没有再继续调用下游的 <code>onSubsribe</code></li>
</ul>
<p>综合起来可以知道，本来应该在整个流从下至上订阅完成后按照从上至下的顺序执行 <code>onSubscribe</code>的流，在使用<code>subsribeOn</code>操作符的后，在订阅的时(执行<code>subscribeActual</code>)，就开始执行下游的<code>onSubscribe</code>且在当前线程！然后才在指定的<code>io</code>线程执行之下而上的操作，这也是为什么<code>subsribeOn</code>影响的是上游的线程。</p>
<h3 id="小结">小结：</h3>
<p>我认为实际上 Rx 使用了很多优秀的设计将我们各种常用的操作进行了封装，让我们自由组合使用，其本身并没有用什么黑科技。例如切换线程本质上则是帮我们启用了一个新的线程并把接下来的代码放进去执行。<br>
当然，其中还有很多更深入的内容需要我们继续发现和学习。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kotlin 中的依赖注入 KODEIN]]></title>
        <id>https://xiejinpeng007.github.io/post/kotlin-zhong-de-yi-lai-zhu-ru-kodein/</id>
        <link href="https://xiejinpeng007.github.io/post/kotlin-zhong-de-yi-lai-zhu-ru-kodein/">
        </link>
        <updated>2018-06-08T09:23:31.000Z</updated>
        <content type="html"><![CDATA[<p>用 Java 进行 Android 开发的话，依赖注入这一块一般使用 Dagger ,转用 Kotlin 之后有更多的选择，Kodein 是个不错的库， 4.0 5.0 都使用过了，相对于 Dagger 有很多好处。</p>
<ul>
<li>用 Kotlin 编写利用了更优秀的语言特性 比如类型推断，Dagger 在编写 Component 的时候需要知道注入类的类型</li>
<li>无需像 Dagger 一样编写大量模板代码</li>
<li>不会像 Dagger 一样在编译期因为其它的编译错误导致无法生成所需文件从而报一堆错。</li>
<li>...</li>
</ul>
<h3 id="最基本的使用步骤">最基本的使用步骤</h3>
<ol>
<li>在 Application 继承 <code>KodeinAware</code> 并绑定依赖</li>
</ol>
<pre><code>class MyApp : Application(), KodeinAware {
	override val kodein = Kodein.lazy { 
	    /* bindings */
	}
}
</code></pre>
<ol start="2">
<li>在 context aware 的 Android 类中通过 <code>closestKodein</code> 方法获取</li>
<li>加载依赖</li>
</ol>
<pre><code>class MyApp : Application(), KodeinAware {

    //实例化 Application 级的 kodein 通过 DSL 绑定 module
	override val kodein = Kodein.lazy { 
        //导入预设的 android 组件
        import(androidModule(this@MainApplication))
        //绑定或者导入自定义依赖
	}
}
</code></pre>
<h3 id="相关基本概念">相关基本概念</h3>
<h4 id="在-application-定义-application-级的-kodein">在 Application 定义 Application 级的 <code>Kodein</code></h4>
<pre><code>class MyApp : Application(), KodeinAware {

    //实例化 Application 级的 kodein 通过 DSL 绑定 module
	override val kodein = Kodein.lazy { 
        //导入预设的 android 组件
        import(androidModule(this@MainApplication))
        //绑定或者导入自定义依赖
	}
}
</code></pre>
<h4 id="通过-closestkodein-恢复-application-级的-kodein-然后通过-kodein-加载依赖">通过 closestKodein 恢复 Application 级的 <code>Kodein</code>  然后通过 <code>Kodein</code> 加载依赖</h4>
<p>#####kodein &amp; ds 默认都是懒加载</p>
<pre><code>class MyActivity : Activity(), KodeinAware {
    override val kodein by closestKodein()
    val ds: DataSource by instance()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        ds.connect() 
        /* ... */
    }
}
</code></pre>
<h4 id="使用-trigger-在-oncreate-中手动触发加载依赖取消懒加载">使用 Trigger 在 onCreate() 中手动触发加载依赖（取消懒加载）</h4>
<p>同样可以避免依赖死循环（除非加载依赖的方式只有 instance）</p>
<pre><code>class MyActivity : Activity(), KodeinAware {
    override val kodein by closestKodein()
    override val kodeinTrigger = KodeinTrigger()
    val ds: DataSource by instance()
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        kodeinTrigger.trigger() 
        /* ... */
    }
}
</code></pre>
<h4 id="在没有-non-context-aware-的类中加载-kodein">在没有 Non-Context-Aware 的类中加载 Kodein</h4>
<pre><code>class MyController(androidContext: Context) : KodeinAware {
    override val kodein by androidContext.closestKodein()
    override val kodeinContext = kcontext(androidContext)
    val inflater: LayoutInflater by instance()
}
</code></pre>
<h4 id="多级-kodin-依赖">多级 Kodin 依赖</h4>
<h5 id="定义-activity-级的-kodein-继承自-application-级">定义 Activity 级的 <code>Kodein</code> 继承自 Application 级</h5>
<pre><code>class MyActivity : Activity(), KodeinAware {
    private val _parentKodein by closestKodein() 
    override val kodein: Kodein = Kodein {
        extend(_parentKodein) 
        /* activity specific bindings */
    }
}
</code></pre>
<h4 id="activity-retained-kodein">Activity Retained Kodein</h4>
<h5 id="使用-retainedkodein-在-activity-重启的时候不会重新创建-kodein">使用 retainedKodein 在 Activity 重启的时候不会重新创建 Kodein</h5>
<pre><code>class MyActivity : Activity(), KodeinAware {
    private val _parentKodein by closestKodein()
    override val kodein: Kodein by retainedKodein { 
        extend(_parentKodein)
        /* activity specific bindings */
    }
}
</code></pre>
<h4 id="android-scopes-作用域">Android scopes 作用域</h4>
<pre><code>//每个 Activity 一个单例
val kodein = Kodein {
    bind&lt;Controller&gt;() with scoped(androidScope&lt;Activity&gt;()).singleton { ControllerImpl(context) } 
}
</code></pre>
<h4 id="activity-retained-scope">Activity retained scope</h4>
<h4 id="同样-activityretainedscope-在-activity-重启时不会重新创建依赖">同样 activityRetainedScope 在 Activity 重启时不会重新创建依赖</h4>
<pre><code>val kodein = Kodein {
    bind&lt;Controller&gt;() with scoped(activityRetainedScope).singleton { ControllerImpl() } 
}
</code></pre>
<h4 id="bindings-declaring-dependencies-申明依赖的一些重要的参数">Bindings: Declaring dependencies 申明依赖的一些重要的参数</h4>
<h5 id="绑定的方式">绑定的方式</h5>
<ul>
<li>Provider binding : 每次加载都生成新的实例，无参， 传入<code>() -&gt; T</code></li>
<li>Singleton binding : 单例 传入 <code>() → T</code></li>
<li>Eager singleton : 单例 创建了 Kodein 实例后立即实例化 传入 <code>() -&gt; T</code></li>
<li>Factory binding : 每次加载都生成新的实例，需要参数，传入<code>(A) -&gt; T</code></li>
<li>Multiton binding : 有参的单例，同样参数同样实例，传入 <code>(A) -&gt; T</code></li>
<li>Tagged bindings : 通过 tag 来区分同类型不同的实例 例如</li>
</ul>
<pre><code>val kodein = Kodein {
    bind&lt;Die&gt;() with ... 
    bind&lt;Die&gt;(tag = &quot;DnD10&quot;) with ... 
    bind&lt;Die&gt;(tag = &quot;DnD20&quot;) with ... 
}
</code></pre>
<h5 id="基本上以上的参数涵盖了大部分的通用使用场景kodein-还有很多复杂的高级用法">基本上以上的参数涵盖了大部分的通用使用场景，Kodein 还有很多复杂的高级用法</h5>
<h4 id="jvm-soft-weak-两种引用回收机制">JVM: Soft &amp; Weak 两种引用回收机制</h4>
<ol>
<li>使用 WeakReference 在<code>OutOfMemoryException</code>之前 JVM 执行 GC</li>
<li>使用 SoftReference 在没有引用的时候就 JVM 执行 GC</li>
</ol>
<pre><code>val kodein = Kodein {
    bind&lt;Map&gt;() with refSingleton(ref = softReference) { WorldMap() } 
    bind&lt;Client&gt;() with refSingleton(ref = weakReference) { id -&gt; clientFromDB(id) } 
}
</code></pre>
<h4 id="transitive-dependencies-依赖传递">Transitive dependencies 依赖传递</h4>
<h5 id="依赖中使用依赖的情况kotlin-的类型推断系统可以很简单的实现">依赖中使用依赖的情况，Kotlin 的类型推断系统可以很简单的实现。</h5>
<pre><code>class Die(private val random: Random, private val sides: Int) {
/*...*/
}

val kodein = Kodein {
    bind&lt;Die&gt;() with singleton { Die(instance(), instance(tag = &quot;max&quot;)) } 

    bind&lt;Random&gt;() with provider { SecureRandom() } 
    constant(tag &quot;max&quot;) with 5 
}
</code></pre>
<h5 id="更多高级用法">更多高级用法...</h5>
<ul>
<li><a href="http://kodein.org/Kodein-DI/?5.0">KODEIN DI: KOtlin DEpendency INjection: 5.0.0</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/android">Kodein on Android</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/getting-started">Getting started</a></li>
<li><a href="http://kodein.org/Kodein-DI/?5.0/core">Core documentation</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SQLite 笔记]]></title>
        <id>https://xiejinpeng007.github.io/post/sqlite-bi-ji/</id>
        <link href="https://xiejinpeng007.github.io/post/sqlite-bi-ji/">
        </link>
        <updated>2018-03-01T09:22:49.000Z</updated>
        <content type="html"><![CDATA[<p>一些笔记</p>
<ul>
<li>
<p>ROWID :<br>
隐藏的 Column 用于作为行的唯一标识。<br>
ROWID 可以看做一个隐式的 INTEGER PRIMARY KEY ,实际上这才是真正的主键，如果创建了一个 INTEGER PRIMARY KEY 的话，<br>
它会作为 ROWID 的别名(alias) ,而非 INTEGER PRIMARY KEY 实际上只是建立了一个索引。<br>
算法是单调递增，如果达到最大整型(9223372036854775807) 那么会重新查找前面已经删除的 ROWID。</p>
</li>
<li>
<p>Index 索引:<br>
Index 是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。<br>
索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。<br>
索引可以创建或删除，但不会影响数据。<br>
每个主键会自动生成一个 Index</p>
</li>
<li>
<p>AUTOINCREMENT ：<br>
作用于主键，算法是单调递增,算法上和 ROWID 的区别是达到最大整型了之后不会重新查找前面没使用的值。<br>
如果 AUTOINCREMENT 关键字出现在 INTEGER PRIMARY KEY后面，则会更改自动 ROWID 分配算法(因为INTEGER PRIMARY KEY 就是 ROWID 别名)，<br>
以防止在数据库的整个生命周期内重用 ROWID。</p>
</li>
<li>
<p>WITHOUT ROWID:<br>
实际上可以指定不生成 ROWID ,那么必须要指定主键。<br>
关于是否需要 ROWID 的问题，总的来说是空间时间的影响，大概是这样的逻辑：<br>
在普通的SQLite表中，PRIMARY KEY实际上只是一个 UNIQUE索引。用于在磁盘上查找记录的键是 ROWID。<br>
普通SQLite表中的特殊“ INTEGER PRIMARY KEY ”列类型使该列成为 ROWID 的别名，因此 INTEGER PRIMARY KEY 是真正的 PRIMARY KEY。</p>
</li>
<li>
<p>SQLite 的表是以 B-Tree 实现的， 在 ROWID 表中如果有 非INTEGER PRIMARY KEY 实际上会建立两个 B-Tree ,<br>
一个是以 ROWID 为主键其余 column 为数据的 B-Tree;另一个 是以 非INTEGER PRIMARY KEY 为主键 ROWID 为数据的索引。<br>
查询的时候 首先在索引中根据找到匹配的 ROWID 然后再在主表中根据 ROWID 查找数据，所以进行了两次独立的二进制搜索。</p>
</li>
<li>
<p>关于 SQLite 查询的结果的顺序：<br>
首先如果要保证查询结果的顺序最好就使用 ORDER BY ，否则会按照 Index 进行，没有或关闭 Index 的话会按照 ROWID 顺序查询。</p>
</li>
</ul>
<p>https://www.sqlite.org/lang_createindex.html<br>
https://www.sqlite.org/lang_createtable.html<br>
https://www.sqlite.org/withoutrowid.html<br>
https://sqlite.org/autoinc.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Swagger (YAML OpenAPI) 从放弃到入门]]></title>
        <id>https://xiejinpeng007.github.io/post/swagger-yaml-openapi-cong-fang-qi-dao-ru-men/</id>
        <link href="https://xiejinpeng007.github.io/post/swagger-yaml-openapi-cong-fang-qi-dao-ru-men/">
        </link>
        <updated>2017-10-12T09:22:03.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>Swagger 是一个统一前后端用于生成文档和代码的工具，它使用 yaml / json 作为描述语言 通过 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#exampleObject">OpenAPI Specification</a> 来描述 API，最后使用 Codegen 根据不同的配置来生成各种 language、library 的 Code、Docs.</p>
</blockquote>
<h5 id="其最理想的情况则是只需一份描述文件yamljson-生成-后端-前端android-ios-web的代码和文档这样的话保证了前后端的统一且需要升级改动也只需要修改-yaml-文件">其最理想的情况则是只需一份描述文件(yaml/json) 生成 后端、前端（android ios web...）的代码和文档，这样的话保证了前后端的统一，且需要升级改动也只需要修改 yaml 文件。</h5>
<h3 id="yaml">YAML</h3>
<p>JSON 都已经很熟悉了，虽然 Swagger 可以使用 JSON 作为描述语言，但是因为 YAML 更为简洁直观，所以更推荐 YAML。<br>
YAML 的基本语法并不复杂，这里介绍一些基本语法：</p>
<ul>
<li>
<p>yaml 文件 以<code>---</code>开始 <code>...</code>结尾</p>
</li>
<li>
<p>同一级别的成员（如 list 成员）可以通过<code>&quot;- &quot;</code>来辨识</p>
</li>
<li>
<p>注释以<code>#</code>开头的一行</p>
</li>
<li>
<p>list:</p>
</li>
</ul>
<pre><code>fruits:
    - Apple
    - Orange
    - Strawberry
    - Mango
</code></pre>
<ul>
<li>key / value</li>
</ul>
<pre><code>martin:
    name: Martin D'vloper
    job: Developer
    skill: Elite
</code></pre>
<ul>
<li>list / map 混合使用</li>
</ul>
<pre><code>-  martin:
    name: Martin D'vloper
    job: Developer
    skills:
      - python
      - perl
      - pascal
-  tabitha:
    name: Tabitha Bitumen
    job: Developer
    skills:
      - lisp
      - fortran
      - erlang
</code></pre>
<ul>
<li>list / map 的简写</li>
</ul>
<pre><code>martin: {name: Martin D'vloper, job: Developer, skill: Elite}
fruits: ['Apple', 'Orange', 'Strawberry', 'Mango']
</code></pre>
<ul>
<li>boolean 值的写法没有严格限制</li>
</ul>
<pre><code>create_key: yes
needs_agent: no
knows_oop: True
likes_emacs: TRUE
uses_cvs: false
</code></pre>
<ul>
<li><code>|</code>使用换行 <code>&gt;</code>忽略换行</li>
</ul>
<pre><code>include_newlines: |
            exactly as you see
            will appear these three
            lines of poetry

ignore_newlines: &gt;
            this is really a
            single line of text
            despite appearances
</code></pre>
<h3 id="openapi-specification">OpenAPI-Specification</h3>
<blockquote>
<p>OpenAPI 是一套用于描述 RESTful APIs 的规范。</p>
<p>The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.</p>
<p>An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p>
</blockquote>
<p>只要符合 OpenAPI 规范的都可以生成各类代码、文档、工具。<br>
目前 OpenAPI 最新 3.0.0 ,对比 2.0 对 API 结构进行了调整。<br>
文档内容繁多请参考 <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md">OpenAPI-Specification 3.0.0</a></p>
<p>下面是 Uber API 的 example</p>
<pre><code># this is an example of the Uber API
# as a demonstration of an API spec in YAML
openapi: &quot;3.0.0&quot;
info:
  title: Uber API
  description: Move your app forward with the Uber API
  version: &quot;1.0.0&quot;
servers:
  - url: https://api.uber.com/v1
paths:
  /products:
    get:
      summary: Product Types
      description: The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.
      parameters:
        - name: latitude
          in: query
          description: Latitude component of location.
          required: true
          schema:
            type: number
            format: double
        - name: longitude
          in: query
          description: Longitude component of location.
          required: true
          schema:
            type: number
            format: double
      security: 
        - apikey: []
      tags: 
        - Products
      responses:  
        '200':
          description: An array of products
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/ProductList&quot;
        default:
          description: Unexpected error
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Error&quot;
  /estimates/price:
    get:
      summary: Price Estimates
      description: The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.&lt;br&gt;&lt;br&gt;The response also includes low and high estimates, and the [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code for situations requiring currency conversion. When surge is active for a particular product, its surge_multiplier will be greater than 1, but the price estimate already factors in this multiplier.
      parameters:
        - name: start_latitude
          in: query
          description: Latitude component of start location.
          required: true
          schema:
            type: number
            format: double
        - name: start_longitude
          in: query
          description: Longitude component of start location.
          required: true
          schema:
            type: number
            format: double
        - name: end_latitude
          in: query
          description: Latitude component of end location.
          required: true
          schema:
            type: number
            format: double
        - name: end_longitude
          in: query
          description: Longitude component of end location.
          required: true
          schema:
            type: number
            format: double
      tags: 
        - Estimates
      responses:  
        '200':
          description: An array of price estimates by product
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: &quot;#/components/schemas/PriceEstimate&quot;
        default:
          description: Unexpected error
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Error&quot;
  /estimates/time:
    get:
      summary: Time Estimates
      description: The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.
      parameters:
        - name: start_latitude
          in: query
          description: Latitude component of start location.
          required: true
          schema:
            type: number
            format: double
        - name: start_longitude
          in: query
          description: Longitude component of start location.
          required: true
          schema:
            type: number
            format: double
        - name: customer_uuid
          in: query
          schema:
            type: string
            format: uuid
          description: Unique customer identifier to be used for experience customization.
        - name: product_id
          in: query
          schema:
            type: string
          description: Unique identifier representing a specific product for a given latitude &amp; longitude.
      tags: 
        - Estimates
      responses:  
        '200':
          description: An array of products
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: &quot;#/components/schemas/Product&quot;
        default:
          description: Unexpected error
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Error&quot;
  /me:
    get:
      summary: User Profile
      description: The User Profile endpoint returns information about the Uber user that has authorized with the application.
      tags: 
        - User
      responses:
        '200':
          description: Profile information for a user
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Profile&quot;
        default:
          description: Unexpected error
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Error&quot;
  /history:
    get:
      summary: User Activity
      description: The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.&lt;br&gt;&lt;br&gt;The history array in the response will have a maximum length based on the limit parameter. The response value count may exceed limit, therefore subsequent API requests may be necessary.
      parameters:
        - name: offset
          in: query
          schema:
            type: integer
            format: int32
          description: Offset the list of returned results by this amount. Default is zero.
        - name: limit
          in: query
          schema:
            type: integer
            format: int32 
          description: Number of items to retrieve. Default is 5, maximum is 100.
      tags: 
        - User
      responses:
        '200':
          description: History information for the given user
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Activities&quot;
        default:
          description: Unexpected error
          content:
            application/json:
              schema:
                $ref: &quot;#/components/schemas/Error&quot;
components:
  securitySchemes:
    apikey:
      type: apiKey
      name: server_token
      in: query
  schemas:
    Product:
      properties:
        product_id:
          type: string
          description: Unique identifier representing a specific product for a given latitude &amp; longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
        description:
          type: string
          description: Description of product.
        display_name:
          type: string
          description: Display name of product.
        capacity:
          type: integer
          description: Capacity of product. For example, 4 people.
        image:
          type: string
          description: Image URL representing the product.
    ProductList:
      properties:
        products:
          description: Contains the list of products
          type: array
          items: 
            $ref: &quot;#/components/schemas/Product&quot;
    PriceEstimate:
      properties:
        product_id:
          type: string
          description: Unique identifier representing a specific product for a given latitude &amp; longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles
        currency_code:
          type: string
          description: &quot;[ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code.&quot;
        display_name:
          type: string
          description: Display name of product.
        estimate: 
          type: string
          description: Formatted string of estimate in local currency of the start location. Estimate could be a range, a single number (flat rate) or &quot;Metered&quot; for TAXI.
        low_estimate:
          type: number
          description: Lower bound of the estimated price.
        high_estimate:
          type: number
          description: Upper bound of the estimated price.
        surge_multiplier:
          type: number
          description: Expected surge multiplier. Surge is active if surge_multiplier is greater than 1. Price estimate already factors in the surge multiplier.
    Profile:
      properties:
        first_name:
          type: string
          description: First name of the Uber user.
        last_name:
          type: string
          description: Last name of the Uber user.
        email:
          type: string
          description: Email address of the Uber user
        picture:
          type: string
          description: Image URL of the Uber user.
        promo_code:
          type: string
          description: Promo code of the Uber user.   
    Activity:
      properties:
        uuid:
          type: string
          description: Unique identifier for the activity
    Activities:
      properties:
        offset:
          type: integer
          format: int32
          description: Position in pagination.
        limit:
          type: integer
          format: int32
          description: Number of items to retrieve (100 max).
        count:
          type: integer
          format: int32
          description: Total number of items available.
        history:
          type: array
          items:
            $ref: &quot;#/components/schemas/Activity&quot;
    Error:
      properties:
        code:
          type: string
        message:
          type: string
        fields:
          type: string
</code></pre>
<p>这里将 OpenAPI 3.0 规范中把重点使用的 api 整理了一张思维导图（还不完善，会持续更新）</p>
<figure data-type="image" tabindex="1"><img src="http://upload-images.jianshu.io/upload_images/1447881-03d1619fc6f6f670.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OpenAPI 3.0.0.png" loading="lazy"></figure>
<h3 id="swagger">Swagger</h3>
<p>Swagger 实际上包含了一系列的工具 Editor Codegen UI ...</p>
<ul>
<li>Editor 用于使用 OpenAPI 编辑 yaml</li>
<li>Codegen 用于生成不同的 language library 的代码</li>
<li>UI 用于生成文档</li>
</ul>
<p>下面介绍一下 Codegen 的使用：</p>
<ol>
<li>
<p>首先下载 <a href="https://oss.sonatype.org/content/repositories/snapshots/io/swagger/swagger-codegen-cli/3.0.0-SNAPSHOT/">swagger-codegen-cli.jar</a></p>
</li>
<li>
<p>确保装好了 maven</p>
</li>
<li>
<p>准备 swagger.yaml</p>
</li>
<li>
<p>编写 config.json 配置文件<br>
因为之前提到 Swagger 可以生成各种 lang lib 的代码，所以这里便是进行此类配置:<br>
查看配置 help</p>
<pre><code>java -jar swagger-codegen-cli.jar config-help -l java
</code></pre>
<pre><code>CONFIG OPTIONS
     sortParamsByRequiredFlag
         Sort method arguments to place required parameters before optional parameters. (Default: true)
     ensureUniqueParams
         Whether to ensure parameter names are unique in an operation (rename parameters that are not). (Default: true)
     allowUnicodeIdentifiers
         boolean, toggles whether unicode identifiers are allowed in names or not, default is false (Default: false)
     modelPackage
         package for generated models
     apiPackage
         package for generated api classes
     invokerPackage
         root package for generated code
     groupId
         groupId in generated pom.xml
     artifactId
         artifactId in generated pom.xml
     artifactVersion
         artifact version in generated pom.xml
     artifactUrl
         artifact URL in generated pom.xml
     artifactDescription
         artifact description in generated pom.xml
     scmConnection
         SCM connection in generated pom.xml
     scmDeveloperConnection
         SCM developer connection in generated pom.xml
     scmUrl
         SCM URL in generated pom.xml
     developerName
         developer name in generated pom.xml
     developerEmail
         developer email in generated pom.xml
     developerOrganization
         developer organization in generated pom.xml
     developerOrganizationUrl
         developer organization URL in generated pom.xml
     licenseName
         The name of the license
     licenseUrl
         The URL of the license
     sourceFolder
         source folder for generated code
     localVariablePrefix
         prefix for generated code members and local variables
     serializableModel
         boolean - toggle &quot;implements Serializable&quot; for generated models (Default: false)
     bigDecimalAsString
         Treat BigDecimal values as Strings to avoid precision loss. (Default: false)
     fullJavaUtil
         whether to use fully qualified name for classes under java.util. This option only works for Java API client (Default: false)
     hideGenerationTimestamp
         hides the timestamp when files were generated
     withXml
         whether to include support for application/xml content type. This option only works for Java API client (resttemplate) (Default: false)
     dateLibrary
         Option. Date library to use
             joda - Joda (for legacy app only)
             legacy - Legacy java.util.Date (if you really have a good reason not to use threetenbp
             java8-localdatetime - Java 8 using LocalDateTime (for legacy app only)
             java8 - Java 8 native JSR310 (preferred for jdk 1.8+) - note: this also sets &quot;java8&quot; to true
             threetenbp - Backport of JSR310 (preferred for jdk &lt; 1.8)
     java8
         Option. Use Java8 classes instead of third party equivalents
             true - Use Java 8 classes such as Base64
             false - Various third party libraries as needed
     useRxJava
         Whether to use the RxJava adapter with the retrofit2 library. (Default: false)
     useRxJava2
         Whether to use the RxJava2 adapter with the retrofit2 library. (Default: false)
     parcelableModel
         Whether to generate models for Android that implement Parcelable with the okhttp-gson library. (Default: false)
     usePlay24WS
         Use Play! 2.4 Async HTTP client (Play WS API) (Default: false)
     supportJava6
         Whether to support Java6 with the Jersey1 library. (Default: false)
     useBeanValidation
         Use BeanValidation API annotations (Default: false)
     performBeanValidation
         Perform BeanValidation (Default: false)
     useGzipFeature
         Send gzip-encoded requests (Default: false)
     useRuntimeException
         Use RuntimeException instead of Exception (Default: false)
     library
         library template (sub-template) to use (Default: okhttp-gson)
             jersey1 - HTTP client: Jersey client 1.19.4. JSON processing: Jackson 2.8.9. Enable Java6 support using '-DsupportJava6=true'. Enable gzip request encoding using '-DuseGzipFeature=true'.
             feign - HTTP client: OpenFeign 9.4.0. JSON processing: Jackson 2.8.9
             jersey2 - HTTP client: Jersey client 2.25.1. JSON processing: Jackson 2.8.9
             okhttp-gson - HTTP client: OkHttp 2.7.5. JSON processing: Gson 2.8.1. Enable Parcelable models on Android using '-DparcelableModel=true'. Enable gzip request encoding using '-DuseGzipFeature=true'.
             retrofit - HTTP client: OkHttp 2.7.5. JSON processing: Gson 2.3.1 (Retrofit 1.9.0). IMPORTANT NOTE: retrofit1.x is no longer actively maintained so please upgrade to 'retrofit2' instead.
             retrofit2 - HTTP client: OkHttp 3.8.0. JSON processing: Gson 2.6.1 (Retrofit 2.3.0). Enable the RxJava adapter using '-DuseRxJava[2]=true'. (RxJava 1.x or 2.x)
             resttemplate - HTTP client: Spring RestTemplate 4.3.9-RELEASE. JSON processing: Jackson 2.8.9
             resteasy - HTTP client: Resteasy client 3.1.3.Final. JSON processing: Jackson 2.8.9

</code></pre>
<p>几个主要的配置参数：</p>
<ul>
<li>library，生成的代码支付的类，有jersey1、jersey2、okhttp-gson、resttemplate、resteasy、feign、retrofit、retrofit2等几种类型，我们选择的retrofit2</li>
<li>developerName，开发者名字，会出现在代码文件里</li>
<li>developerEmail，开发者邮箱，会出现在代码文件里</li>
<li>developrOrganization，开发者组织，会出现在代码里</li>
<li>invokerPackage，项目的包名</li>
<li>apiPackage，生成的***Api.java文件的包名</li>
<li>modelPackage，生成的数据模型java文件包名</li>
<li>dateLibrary，时间使用的类开</li>
<li>useRxJava，是否使用rxjava生成api接口</li>
<li>useRxJava2，是否使用rxjava2的方式调用接口</li>
</ul>
</li>
<li>
<p>generate 生成代码<br>
首先打印参数信息</p>
<pre><code>java -jar swagger-codegen-cli.jar generate help
</code></pre>
<pre><code>NAME
     swagger-codegen-cli generate - Generate code with chosen lang
 SYNOPSIS
     swagger-codegen-cli generate
             [(-a &lt;authorization&gt; | --auth &lt;authorization&gt;)]
             [--additional-properties &lt;additional properties&gt;...]
             [--api-package &lt;api package&gt;] [--artifact-id &lt;artifact id&gt;]
             [--artifact-version &lt;artifact version&gt;]
             [(-c &lt;configuration file&gt; | --config &lt;configuration file&gt;)]
             [-D &lt;system properties&gt;...] [--git-repo-id &lt;git repo id&gt;]
             [--git-user-id &lt;git user id&gt;] [--group-id &lt;group id&gt;]
             [--http-user-agent &lt;http user agent&gt;]
             (-i &lt;spec file&gt; | --input-spec &lt;spec file&gt;)
             [--ignore-file-override &lt;ignore file override location&gt;]
             [--import-mappings &lt;import mappings&gt;...]
             [--instantiation-types &lt;instantiation types&gt;...]
             [--invoker-package &lt;invoker package&gt;]
             (-l &lt;language&gt; | --lang &lt;language&gt;)
             [--language-specific-primitives &lt;language specific primitives&gt;...]
             [--library &lt;library&gt;] [--model-name-prefix &lt;model name prefix&gt;]
             [--model-name-suffix &lt;model name suffix&gt;]
             [--model-package &lt;model package&gt;]
             [(-o &lt;output directory&gt; | --output &lt;output directory&gt;)]
             [--release-note &lt;release note&gt;] [--remove-operation-id-prefix]
             [--reserved-words-mappings &lt;reserved word mappings&gt;...]
             [(-s | --skip-overwrite)]
             [(-t &lt;template directory&gt; | --template-dir &lt;template directory&gt;)]
             [--type-mappings &lt;type mappings&gt;...] [(-v | --verbose)]
OPTIONS
     -a &lt;authorization&gt;, --auth &lt;authorization&gt;
         adds authorization headers when fetching the swagger definitions
         remotely. Pass in a URL-encoded string of name:header with a comma
         separating multiple values
     --additional-properties &lt;additional properties&gt;
         sets additional properties that can be referenced by the mustache
         templates in the format of name=value,name=value. You can also have
         multiple occurrences of this option.
     --api-package &lt;api package&gt;
         package for generated api classes
     --artifact-id &lt;artifact id&gt;
         artifactId in generated pom.xml
     --artifact-version &lt;artifact version&gt;
         artifact version in generated pom.xml
     -c &lt;configuration file&gt;, --config &lt;configuration file&gt;
         Path to json configuration file. File content should be in a json
         format {&quot;optionKey&quot;:&quot;optionValue&quot;, &quot;optionKey1&quot;:&quot;optionValue1&quot;...}
         Supported options can be different for each language. Run
         config-help -l {lang} command for language specific config options.
     -D &lt;system properties&gt;
         sets specified system properties in the format of
         name=value,name=value (or multiple options, each with name=value)
     --git-repo-id &lt;git repo id&gt;
         Git repo ID, e.g. swagger-codegen.
     --git-user-id &lt;git user id&gt;
         Git user ID, e.g. swagger-api.
     --group-id &lt;group id&gt;
         groupId in generated pom.xml
     --http-user-agent &lt;http user agent&gt;
         HTTP user agent, e.g. codegen_csharp_api_client, default to
         'Swagger-Codegen/{packageVersion}}/{language}'
     -i &lt;spec file&gt;, --input-spec &lt;spec file&gt;
         location of the swagger spec, as URL or file (required)
     --ignore-file-override &lt;ignore file override location&gt;
         Specifies an override location for the .swagger-codegen-ignore file.
         Most useful on initial generation.
     --import-mappings &lt;import mappings&gt;
         specifies mappings between a given class and the import that should
         be used for that class in the format of type=import,type=import. You
         can also have multiple occurrences of this option.
     --instantiation-types &lt;instantiation types&gt;
         sets instantiation type mappings in the format of
         type=instantiatedType,type=instantiatedType.For example (in Java):
         array=ArrayList,map=HashMap. In other words array types will get
         instantiated as ArrayList in generated code. You can also have
         multiple occurrences of this option.
     --invoker-package &lt;invoker package&gt;
         root package for generated code
     -l &lt;language&gt;, --lang &lt;language&gt;
         client language to generate (maybe class name in classpath,
         required)
     --language-specific-primitives &lt;language specific primitives&gt;
         specifies additional language specific primitive types in the format
         of type1,type2,type3,type3. For example:
         String,boolean,Boolean,Double. You can also have multiple
         occurrences of this option.
     --library &lt;library&gt;
         library template (sub-template)
     --model-name-prefix &lt;model name prefix&gt;
         Prefix that will be prepended to all model names. Default is the
         empty string.
     --model-name-suffix &lt;model name suffix&gt;
         Suffix that will be appended to all model names. Default is the
         empty string.
     --model-package &lt;model package&gt;
         package for generated models
     -o &lt;output directory&gt;, --output &lt;output directory&gt;
         where to write the generated files (current dir by default)
     --release-note &lt;release note&gt;
         Release note, default to 'Minor update'.
     --remove-operation-id-prefix
         Remove prefix of operationId, e.g. config_getId =&gt; getId
     --reserved-words-mappings &lt;reserved word mappings&gt;
         specifies how a reserved name should be escaped to. Otherwise, the
         default _&lt;name&gt; is used. For example id=identifier. You can also
         have multiple occurrences of this option.
     -s, --skip-overwrite
         specifies if the existing files should be overwritten during the
         generation.
     -t &lt;template directory&gt;, --template-dir &lt;template directory&gt;
         folder containing the template files
     --type-mappings &lt;type mappings&gt;
         sets mappings between swagger spec types and generated code types in
         the format of swaggerType=generatedType,swaggerType=generatedType.
         For example: array=List,map=Map,string=String. You can also have
         multiple occurrences of this option.
     -v, --verbose
         verbose mode
</code></pre>
<p>几个主要参数：</p>
<ul>
<li>-i 表示输入的文件，editor生成的设计文件路径，如：-i ~/Desktop/swagger.yaml</li>
<li>-o 代码生成目录，swagger codegen 把代码生成到什么地方，如：-o ~/Desktop</li>
<li>-l 生成代码语言，我们是生成java，如：-l java</li>
<li>-c 配置文件，配制文件路径，如：-c ~/Desktop/config.json</li>
</ul>
<p>最后生成代码</p>
<pre><code>java -jar swagger-codegen-cli.jar generate -i swagger.yaml -o client -l java -c config.json
</code></pre>
<p>成功在 ~/Desktop 下生成了相应的 code 和 doc</p>
<p>参考资料以及推荐阅读的资料<br>
<a href="http://docs.ansible.com/ansible/latest/YAMLSyntax.html">http://docs.ansible.com/ansible/latest/YAMLSyntax.html</a><br>
<a href="https://swagger.io/docs/specification/about/">https://swagger.io/docs/specification/about/</a><br>
<a href="http://www.jianshu.com/p/c178c18aaf43">http://www.jianshu.com/p/c178c18aaf43</a><br>
<a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md">https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md</a><br>
<a href="https://github.com/swagger-api">https://github.com/swagger-api</a><br>
<a href="https://www.gitbook.com/book/huangwenchao/swagger/details">https://www.gitbook.com/book/huangwenchao/swagger/details</a></p>
</li>
</ol>
]]></content>
    </entry>
</feed>