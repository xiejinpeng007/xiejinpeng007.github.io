{"posts":[{"title":"Android 10(Q)/11(R) 分区存储适配","content":"大部分应用都会请求 ( READ_EXTERNAL_STORAGE ) ( WRITE_EXTERNAL_STORAGE ) 存储权限，来做一些诸如在 SD 卡中存储文件或者读取多媒体文件等常规操作。这些应用可能会在磁盘中存储大量文件，即使应用被卸载了还会依然存在。另外，这些应用还可能会读取其他应用的一些敏感文件数据。 为此，Google 终于下定决心在 Android 10 中引入了分区存储，对权限进行场景的细分，按需索取，并在 Android 11 中进行了进一步的调整。 Android 存储分区情况 Android 中存储可以分为两大类：私有存储和共享存储 私有存储 (Private Storage) : 每个应用在都拥有自己的私有目录，其它应用看不到，彼此也无法访问到该目录： 内部存储私有目录(/data/data/packageName) ； 外部存储私有目录 (/sdcard/Android/data/packageName)， 共享存储 (Shared Storage) : 存储其他应用可访问文件， 包含媒体文件、文档文件以及其他文件，对应设备DCIM、Pictures、Alarms、Music、Notifications、Podcasts、Ringtones、Movies、Download等目录。 Android 10(Q) 行为变更： Android 10 中主要对共享目录进行了权限详细的划分，不再能通过绝对路径访问。 受影响的接口： 访问不同分区的方式： 私有目录：和以前的版本一致，可通过 File() API 访问，无需申请权限。 共享目录：需要通过MediaStore和Storage Access Framework API 访问，视具体情况申请权限，下面详细介绍。 其中，对共享目录的权限进行了细分： 无需申请权限的操作： 通过 MediaStore API对媒体集、文件集进行媒体/文件的添加、对 自身APP 创建的 媒体/文件 进行查询、修改、删除的操作。 需要申请READ_EXTERNAL_STORAGE权限： 通过 MediaStore API对所有的媒体集进行查询、修改、删除的操作。 调用 Storage Access Framework API ： 会启动系统的文件选择器向用户申请操作指定的文件 新的访问方式： Android 11 (R) 行为变更 : Android 11 (R) 在 Android 10 (Q) 中分区存储的基础上进行了调整 1. 新增执行批量操作 为实现各种设备之间的一致性并增加用户便利性，Android 11 向 MediaStore API 中添加了多种方法。对于希望简化特定媒体文件更改流程（例如在原位置编辑照片）的应用而言，这些方法尤为有用。 MediaStore API 新增的方法 方法 说明 createWriteRequest (ContentResolver, Collection) 用户向应用授予对指定媒体文件组的写入访问权限的请求。 createFavoriteRequest (ContentResolver, Collection, boolean) 用户将设备上指定的媒体文件标记为 “收藏” 的请求。对该文件具有读取访问权限的任何应用都可以看到用户已将该文件标记为 “收藏”。 createTrashRequest (ContentResolver, Collection, boolean) 用户将指定的媒体文件放入设备垃圾箱的请求。垃圾箱中的内容在特定时间段（默认为 7 天）后会永久删除。 createDeleteRequest (ContentResolver, Collection) 用户立即永久删除指定的媒体文件（而不是先将其放入垃圾箱）的请求。 系统在调用以上任何一个方法后，会构建一个 PendingIntent 对象。应用调用此 intent 后，用户会看到一个对话框，请求用户同意应用更新或删除指定的媒体文件。 2. 使用直接文件路径和原生库访问文件 为了帮助您的应用更顺畅地使用第三方媒体库，Android 11 允许您使用除 MediaStore API 之外的 API 访问共享存储空间中的媒体文件。不过，您也可以转而选择使用以下任一 API 直接访问媒体文件： File API。 原生库，例如 fopen()。 简单来说就是，可以通过 File() 等API 访问有权限访问的媒体集了。 性能： 通过 File () 等直接通过路径访问的 API 实际上也会映射为MediaStore API 。 按文件路径顺序读取的时候性能相当；随机读取和写入的时候则会更慢，所以还是推荐直接使用 MediaStoreAPI。 3. 新增权限 MANAGE_EXTERNAL_STORAGE : 类似以前的 READ_EXTERNAL_STORAGE + WRITE_EXTERNAL_STORAGE，除了应用专有目录都可以访问。 应用可通过执行以下操作向用户请求名为所有文件访问权限的特殊应用访问权限： 在清单中声明 MANAGE_EXTERNAL_STORAGE 权限。 使用 ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION intent 操作将用户引导至一个系统设置页面，在该页面上，用户可以为您的应用启用以下选项：授予所有文件的管理权限。 在 Google Play 上架的话，需要提交使用此权限的说明，只有指定的几种类型的 APP 才能使用。 Sample 使用 MediaStore 增删改查媒体集 使用 Storage Access Framework 访问文件集 1. 媒体集 1） 查询媒体集（需要 READ_EXTERNAL_STORAGE 权限） 实际上 MediaStore 是以前就有的 API ，不同的是过去主要通过 MediaStore.Video.Media._DATA 这个 colum 请求原始数据，可以得到绝对Uri，现在需要请求MediaStore.Video.Media._ID来得到相对Uri`再进行处理。 // Need the READ_EXTERNAL_STORAGE permission if accessing video files that your // app didn't create. // Container for information about each video. data class Video( val uri: Uri, val name: String, val duration: Int, val size: Int ) val videoList = mutableListOf&lt;Video&gt;() val projection = arrayOf( MediaStore.Video.Media._ID, MediaStore.Video.Media.DISPLAY_NAME, MediaStore.Video.Media.DURATION, MediaStore.Video.Media.SIZE ) // Show only videos that are at least 5 minutes in duration. val selection = &quot;${MediaStore.Video.Media.DURATION} &gt;= ?&quot; val selectionArgs = arrayOf( TimeUnit.MILLISECONDS.convert(5, TimeUnit.MINUTES).toString() ) // Display videos in alphabetical order based on their display name. val sortOrder = &quot;${MediaStore.Video.Media.DISPLAY_NAME} ASC&quot; val query = ContentResolver.query( MediaStore.Video.Media.EXTERNAL_CONTENT_URI, projection, selection, selectionArgs, sortOrder ) query?.use { cursor -&gt; // Cache column indices. val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media._ID) val nameColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DISPLAY_NAME) val durationColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.DURATION) val sizeColumn = cursor.getColumnIndexOrThrow(MediaStore.Video.Media.SIZE) while (cursor.moveToNext()) { // Get values of columns for a given video. val id = cursor.getLong(idColumn) val name = cursor.getString(nameColumn) val duration = cursor.getInt(durationColumn) val size = cursor.getInt(sizeColumn) val contentUri: Uri = ContentUris.withAppendedId( MediaStore.Video.Media.EXTERNAL_CONTENT_URI, id ) // Stores column values and the contentUri in a local object // that represents the media file. videoList += Video(contentUri, name, duration, size) } } 2）插入媒体集（无需权限） // Add a media item that other apps shouldn't see until the item is // fully written to the media store. val resolver = applicationContext.contentResolver // Find all audio files on the primary external storage device. // On API &lt;= 28, use VOLUME_EXTERNAL instead. val audioCollection = MediaStore.Audio.Media .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY) val songDetails = ContentValues().apply { put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Workout Playlist.mp3&quot;) put(MediaStore.Audio.Media.IS_PENDING, 1) } val songContentUri = resolver.insert(audioCollection, songDetails) resolver.openFileDescriptor(songContentUri, &quot;w&quot;, null).use { pfd -&gt; // Write data into the pending audio file. } // Now that we're finished, release the &quot;pending&quot; status, and allow other apps // to play the audio track. songDetails.clear() songDetails.put(MediaStore.Audio.Media.IS_PENDING, 0) resolver.update(songContentUri, songDetails, null, null) 3）更新自己创建的媒体集（无需权限） 删除类似 // Updates an existing media item. val mediaId = // MediaStore.Audio.Media._ID of item to update. val resolver = applicationContext.contentResolver // When performing a single item update, prefer using the ID val selection = &quot;${MediaStore.Audio.Media._ID} = ?&quot; // By using selection + args we protect against improper escaping of // values. val selectionArgs = arrayOf(mediaId.toString()) // Update an existing song. val updatedSongDetails = ContentValues().apply { put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Favorite Song.mp3&quot;) } // Use the individual song's URI to represent the collection that's // updated. val numSongsUpdated = resolver.update( myFavoriteSongUri, updatedSongDetails, selection, selectionArgs) 4）更新/删除其它媒体创建的媒体集 若已经开启分区存储则会抛出 RecoverableSecurityException，捕获并通过SAF请求权限 // Apply a grayscale filter to the image at the given content URI. try { contentResolver.openFileDescriptor(image-content-uri, &quot;w&quot;)?.use { setGrayscaleFilter(it) } } catch (securityException: SecurityException) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) { val recoverableSecurityException = securityException as? RecoverableSecurityException ?: throw RuntimeException(securityException.message, securityException) val intentSender = recoverableSecurityException.userAction.actionIntent.intentSender intentSender?.let { startIntentSenderForResult(intentSender, image-request-code, null, 0, 0, 0, null) } } else { throw RuntimeException(securityException.message, securityException) } } 2. 文件集 （通过 SAF） 1）创建文档 注：创建操作若重名的话不会覆盖原文档，会添加 (1) 最为后缀，如 document.pdf -&gt; document(1).pdf // Request code for creating a PDF document. const val CREATE_FILE = 1 private fun createFile(pickerInitialUri: Uri) { val intent = Intent(Intent.ACTION_CREATE_DOCUMENT).apply { addCategory(Intent.CATEGORY_OPENABLE) type = &quot;application/pdf&quot; putExtra(Intent.EXTRA_TITLE, &quot;invoice.pdf&quot;) // Optionally, specify a URI for the directory that should be opened in // the system file picker before your app creates the document. putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri) } startActivityForResult(intent, CREATE_FILE) } 2）打开文档 建议使用 type 设置 MIME 类型 // Request code for selecting a PDF document. const val PICK_PDF_FILE = 2 fun openFile(pickerInitialUri: uri) { val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply { addCategory(Intent.CATEGORY_OPENABLE) type = &quot;application/pdf&quot; // Optionally, specify a URI for the file that should appear in the // system file picker when it loads. putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri) } startActivityForResult(intent, PICK_PDF_FILE) } 3）授予对目录内容的访问权限 用户选择目录后，可访问该目录下的所有内容 Android 11 中无法访问 Downloads fun openDirectory(pickerInitialUri: Uri) { // Choose a directory using the system's file picker. val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply { // Provide read access to files and sub-directories in the user-selected // directory. flags = Intent.FLAG_GRANT_READ_URI_PERMISSION // Optionally, specify a URI for the directory that should be opened in // the system file picker when it loads. putExtra(DocumentsContract.EXTRA_INITIAL_URI, pickerInitialUri) } startActivityForResult(intent, your-request-code) } 4）永久获取目录访问权限 上面提到的授权是临时性的，重启后则会失效。可以通过下面的方法获取相应目录永久性的权限 val contentResolver = applicationContext.contentResolver val takeFlags: Int = Intent.FLAG_GRANT_READ_URI_PERMISSION or Intent.FLAG_GRANT_WRITE_URI_PERMISSION // Check for the freshest data. contentResolver.takePersistableUriPermission(uri, takeFlags) 5）SAF API 响应 SAF API 调用后都是通过 onActivityResult来相应动作 override fun onActivityResult( requestCode: Int, resultCode: Int, resultData: Intent?) { if (requestCode == your-request-code &amp;&amp; resultCode == Activity.RESULT_OK) { // The result data contains a URI for the document or directory that // the user selected. resultData?.data?.also { uri -&gt; // Perform operations on the document using its URI. } } } 6) 其它操作 除了上面的操作之外，对文档其它的复制、移动等操作都是通过设置不同的 FLAG 来实现，见 Document.COLUMN_FLAGS 3. 批量操作媒体集 构建一个媒体集的写入操作 createWriteRequest() val urisToModify = /* A collection of content URIs to modify. */ val editPendingIntent = MediaStore.createWriteRequest(contentResolver, urisToModify) // Launch a system prompt requesting user permission for the operation. startIntentSenderForResult(editPendingIntent.intentSender, EDIT_REQUEST_CODE, null, 0, 0, 0) //相应 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { ... when (requestCode) { EDIT_REQUEST_CODE -&gt; if (resultCode == Activity.RESULT_OK) { /* Edit request granted; proceed. */ } else { /* Edit request not granted; explain to the user. */ } } } createFavoriteRequest() createTrashRequest() createDeleteRequest() 同理 适配和兼容 在 targetSDK = 29 APP 中，在 AndroidManifes 设置 requestLegacyExternalStorage=&quot;true&quot; 启用兼容模式，以传统分区模式运行。 &lt;manifest ... &gt; &lt;!-- This attribute is &quot;false&quot; by default on apps targeting Android 10 or higher. --&gt; &lt;application android:requestLegacyExternalStorage=&quot;true&quot; ... &gt; ... &lt;/application&gt; &lt;/manifest&gt; 注意：如果某个应用在安装时启用了传统外部存储，则该应用会保持此模式，直到卸载为止。无论设备后续是否升级为搭载 Android 10 或更高版本，或者应用后续是否更新为以 Android 10 或更高版本为目标平台，此兼容性行为均适用。 意思就是在新系统新安装的应用才会启用，覆盖安装会保持传统分区模式，例如： 系统通过 OTA 升级到 Android 10/11 应用通过更新升级到 targetSdkVersion &gt;= 29 补充 Q：之前讨论过一些问题，APP 无需权限可以访问自己创建的媒体，那么系统如何进行判断？ A：创建媒体时系统会给媒体打上 packageName tag，应用被卸载则会清除 tag ，所以不会存在使用同样 packageName 进行欺骗的情况。 Q：我可以在媒体集文件夹下创建文档，就可以避开权限的问题了？ A：官方文档上写了只能创建相应类型的媒体/文件，具体如何限制的，没有说明。 总结 从 Android 10提出分区存储之后到现在已经一年多了，所以Google 从强制推行的态度到现在 targetSDK &gt;=30 才强制启用分区存储来看，Google 还是渐渐地选择给开发者留更多的时间。缺点当然是不强制启用的话，国内 APP 适配进度估计得延后了。不过好消息是在查资料的时候，看到了国内大厂的相关适配文章，至少说明大厂在跟进了。 去年（19年）的文档描述是无论 targetSDK 多少，明年（20年）高版本强制启用。 今年（20）文档描述是 targetSDK &gt;=30 才强制启用 关于适配的难度： 对绝对路径相关接口依赖比较深的 APP 适配还是改动挺多的；其次权限的划分很细，什么时候需要什么权限以及调用哪个接口，理解起来需要一定时间；MediaStore API SAF API 这类接口以前就设计好了，我也觉得也不算特别友好；最后测试也需要重新进行。 所以虽然明年才会强制执行分区存储，但还是建议尽早理解和 review 项目中需要适配的代码。 参考文档： https://developer.android.com/preview/privacy/storage (Android 11 中的存储机制更新) https://developer.android.com/training/data-storage/shared/documents-files (从共享存储空间访问文档和其他文件) https://developer.android.com/training/data-storage/files/external-scoped?hl=zh-cn (管理分区外部存储访问) https://developer.android.com/guide/topics/providers/document-provider (使用存储访问框架打开文件) https://juejin.im/post/6844904063432130568 (Android 10 分区存储介绍及百度APP适配实践) [https://github.com/android/storage-samples ","link":"https://xiejinpeng007.github.io/post/android-10q11r-fen-qu-cun-chu-gua-pei/"},{"title":"WebRTC 原理和网络视频通话的实现(Android+服务器端)","content":"近期由于疫情原因，国内外线上会议使用率攀升，很多公司都推出了相关服务， Google 也把本来付费会议服务 Meeting 变为免费，实际上现在很多的网络视频软件都使用到了 WebRTC 这个核心的技术。 之前调查过一个摄像头监控功能的 App ，也用到了 WebRTC 相关的技术，于是做成了一个可以视频通话的客户端和服务器端，并做了一些技术的总结分享一下。 简介： WebRTC（Web Real-Time Communication）是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。 虽然叫 WebRTC ，实际上目前主流浏览器和操作系统都已经支持了相关API。它通过点对点（Point-to-Point）的方式进行通话，但也需要信令服务器来进行相关配置信息的交换。 注：下面的原理介绍和 demo 实现，都按照最标准易懂的流程来设计，实际的业务开发会根据情况进行调整。 原理： 基本的图示： 从上图可以看AB互相呼叫的相关流程需要通过信令服务器中转，而视频/音频等流量数据是点对点直接传输的。 重要 API 和相关协议： Network Stream API MediaStream：MediaStream 用来表示一个媒体数据流。 MediaStreamTrack 在浏览器中表示一个媒体源。 RTCPeerConnection RTCPeerConnection：一个RTCPeerConnection对象允许用户在两个终端之间直接通讯。 RTCIceCandidate：表示一个ICE协议的候选者。 RTCIceServer：表示一个ICE Server。 Peer-to-peer Data API DataChannel：数据通道（DataChannel）接口表示一个在两个节点之间的双向的数据通道。 Session Description Protocol :一种用于描述在设备之间共享媒体的连接的数据格式. Interactive Connectivity Establishment (ICE) : 一个用于网络穿透的框架，其中使用 TURN/STUN 服务来实现。 Session Traversal Utilities for NAT (STUN): 用于获取公网地址的协议 Traversal Using Relays around NAT (TURN) : 用于中继数据的协议 建立连接的基本流程： 两端进行相关初始化（Socket 、ICE、流媒体等的配置） A： 发起呼叫:创建用于连接的 PeerConnection(PC) 和自己的配置文件 SessionDescription(SDP) 将 SDP 设置为 LocalDescription ,然后通过信令服务器将 SDP 转发给 B ,这个流程称之为 Offer 。 B 收到 SDP 后设置为 RemoteDescription ,创建自己的 SDP ，设置为 LocalDescription,然后通过信令服务器将 SDP 转发 给 A,这个过程称之为 Answer。 A 收到 SDP 后设置为 RemoteDescription 在初始化时会进行 ICE 服务的配置，所以 ICE 服务成功后有回调，A B 在回调后将 ICE 的配置发送给对方，收到后分别设置到 ICE 配置中，则会进行最终的连接。 连接成功后若已设置 DataChannel MediaStream ...等配置，那么相关回调会执行，此时即可获取数据。 期间，因为需要点对点的通信，而在公网上由于 NAT/firewalls 的限制，无法直接进行通讯，所以需要使用 ICE 框架来进行，ICE 框架内部使用 STUN / TURN 协议来实现。 STUN： 上面已经解释了是用于获取公网IP的服务，Google 也提供了公共的服务器 stun:stun.l.google.com:19302 TURN： 主要是用于客户端即使知道了互相的 IP ，由于 Symmetric NAT 的限制无法直接建立连接时用于转发媒体流数据的服务，这个一般来说需要自己搭建。 Android 客户端的实现 客户端的功能包括了自定义服务器地址连接服务器、查看在线设备、选择设备进行视频通话 依赖库中 Webrtc 使用 Google 官方提供的， 服务器端和 Android 端使用了同样的 Socket 库，若服务器端没有什么限制推荐使用 OkHttp 自带的 Socket 通信功能。 implementation 'org.webrtc:google-webrtc:1.0.28513' implementation 'com.github.nkzawa:socket.io-client:0.4.2' WebRtcClient 的初始化 init { //初始化 PeerConnectionFactory 配置 PeerConnectionFactory.initialize( PeerConnectionFactory .InitializationOptions .builder(app) .createInitializationOptions() ) //初始化视频编码/解码信息 factory = PeerConnectionFactory.builder() .setVideoDecoderFactory( DefaultVideoDecoderFactory(eglContext) ) .setVideoEncoderFactory( DefaultVideoEncoderFactory( eglContext, true, true ) ) .createPeerConnectionFactory() // 初始化 Socket 通信 val messageHandler = MessageHandler() try { socket = IO.socket(url) } catch (e: URISyntaxException) { e.printStackTrace() } socket?.on(&quot;id&quot;, messageHandler.onId) socket?.on(&quot;message&quot;, messageHandler.onMessage) socket?.on(&quot;ids&quot;, messageHandler.onIdsChanged) socket?.connect() //初始化 ICE 服务器创建 PC 时使用 iceServers.add(PeerConnection.IceServer(&quot;stun:23.21.150.121&quot;)) iceServers.add(PeerConnection.IceServer(&quot;stun:stun.l.google.com:19302&quot;)) //初始化本地的 MediaConstraints 创建 PC 时使用，是流媒体的配置信息 pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveAudio&quot;, &quot;true&quot;)) pcConstraints.mandatory.add(MediaConstraints.KeyValuePair(&quot;OfferToReceiveVideo&quot;, &quot;true&quot;)) pcConstraints.optional.add(MediaConstraints.KeyValuePair(&quot;DtlsSrtpKeyAgreement&quot;, &quot;true&quot;)) } 开始建立连接 上面介绍的建立连接的基本流程提到了 A 呼叫 B 的话是由 A 开启 Offer 流程，由于我希望创建 PC 的时候知道自己的 id 和获取所有在线客户端，所以修改了一些流程，增加了init readyToStream的动作。 初始化 Socket 连接上服务器后会返回相应 clientId, 此时进行本地摄像头的初始化和本地媒体流的初始化最后进行向服务器发送准备初始化成功的指令。 private fun getVideoCapturer() = Camera2Enumerator(app).run { deviceNames.find { isFrontFacing(it) }?.let { createCapturer(it, null) } ?: throw IllegalStateException() } fun startLocalCamera(name: String, context: Context) { //init local media stream val localVideoSource = factory.createVideoSource(false) val surfaceTextureHelper = SurfaceTextureHelper.create( Thread.currentThread().name, eglContext ) (vc as VideoCapturer).initialize( surfaceTextureHelper, context, localVideoSource.capturerObserver ) vc.startCapture(320, 240, 60) localMS = factory.createLocalMediaStream(&quot;LOCALMEDIASTREAM&quot;) localMS?.addTrack(factory.createVideoTrack(&quot;LOCALMEDIASTREAM&quot;, localVideoSource)) webrtcListener.onLocalStream(localMS!!) try { val message = JSONObject() message.put(&quot;name&quot;, name) socket?.emit(&quot;readyToStream&quot;, message) } catch (e: JSONException) { e.printStackTrace() } } 此时已连上服务器并配置完毕，调用 refreshIds 获取已连接上服务器客户端，选择 id 进行呼叫 //发送消息的方法 private fun sendMessage(to: String, type: String, payload: JSONObject) { val message = JSONObject() message.put(&quot;to&quot;, to) message.put(&quot;type&quot;, type) message.put(&quot;payload&quot;, payload) socket?.emit(&quot;message&quot;, message) } fun refreshIds() { socket?.emit(&quot;refreshids&quot;, null) } fun callByClientId(clientId: String) { sendMessage(clientId, &quot;init&quot;, JSONObject()) } readyToStream refreshIds是为了实现查看在线设备相关功能，并非 WebRTC 的标准，下面的建立连接的基本流程是必要的流程。 接收消息后根据消息进入不同的响应流程以及具体的实现。 private inner class MessageHandler { //建立 PC 交换 SDP ICE 等配置的事件 val onMessage = Emitter.Listener { args -&gt; val data = args[0] as JSONObject try { val from = data.getString(&quot;from&quot;) val type = data.getString(&quot;type&quot;) var payload: JSONObject? = null if (type != &quot;init&quot;) { payload = data.getJSONObject(&quot;payload&quot;) } //用于检查是否 PC 是否已存在已经是否达到最大的2个 PC 的限制 if (!peers.containsKey(from)) { val endPoint = findEndPoint() if (endPoint == MAX_PEER) return@Listener else addPeer(from, endPoint) } //根据不同的指令类型和数据响应相应步骤的方法 when (type) { &quot;init&quot; -&gt; createOffer(from) &quot;offer&quot; -&gt; createAnswer(from, payload) &quot;answer&quot; -&gt; setRemoteSdp(from, payload) &quot;candidate&quot; -&gt; addIceCandidate(from, payload) } } catch (e: JSONException) { e.printStackTrace() } } //连接上服务器会返回自己的 clientId 的事件，可开始呼叫。 val onId = Emitter.Listener { args -&gt; val id = args[0] as String webrtcListener.onCallReady(id) } //获取在线客户端的事件 val onIdsChanged = Emitter.Listener { args -&gt; Log.d(TAG, args.toString()) val ids = args[0] as JSONArray webrtcListener.onOnlineIdsChanged(ids) } } //开始 Offer 流程 private fun createOffer(peerId: String) { Log.d(TAG, &quot;CreateOffer&quot;) val peer = peers[peerId] peer?.pc?.createOffer(peer, pcConstraints) } //开始 Answer 流程 private fun createAnswer(peerId: String, payload: JSONObject?) { Log.d(TAG, &quot;CreateAnswer&quot;) val peer = peers[peerId] val sdp = SessionDescription( SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)), payload?.getString(&quot;sdp&quot;) ) peer?.pc?.setRemoteDescription(peer, sdp) peer?.pc?.createAnswer(peer, pcConstraints) } //设置 SDP 后无需操作等待 ICE 成功后响应 private fun setRemoteSdp(peerId: String, payload: JSONObject?) { Log.d(TAG, &quot;SetRemoteSDP&quot;) val peer = peers[peerId] val sdp = SessionDescription( SessionDescription.Type.fromCanonicalForm(payload?.getString(&quot;type&quot;)), payload?.getString(&quot;sdp&quot;) ) peer?.pc?.setRemoteDescription(peer, sdp) } //收到 ICE 后添加到 PC private fun addIceCandidate(peerId: String, payload: JSONObject?) { Log.d(TAG, &quot;AddIceCandidate&quot;) val pc = peers[peerId]!!.pc if (pc!!.remoteDescription != null) { val candidate = IceCandidate( payload!!.getString(&quot;id&quot;), payload.getInt(&quot;label&quot;), payload.getString(&quot;candidate&quot;) ) pc.addIceCandidate(candidate) } } 基本流程中的一些细节补充： 建立 PeerConnection 时需绑定本地媒体流 init { Log.d(TAG, &quot;new Peer: $id $endPoint&quot;) this.pc = factory.createPeerConnection(iceServers, pcConstraints, this) pc?.addStream(localMS!!) //, new MediaConstraints() webrtcListener.onStatusChanged(&quot;CONNECTING&quot;) } 需要实现 SdpObserver PeerConnection.Observer 接口，用于监听 PeerConnection SDP 关键的回调。 // SDP 创建成功后回调，发送给服务器。 override fun onCreateSuccess(sdp: SessionDescription) { // TODO: modify sdp to use pcParams prefered codecs try { val payload = JSONObject() payload.put(&quot;type&quot;, sdp.type.canonicalForm()) payload.put(&quot;sdp&quot;, sdp.description) sendMessage(id, sdp.type.canonicalForm(), payload) pc!!.setLocalDescription(this@Peer, sdp) } catch (e: JSONException) { e.printStackTrace() } } // ICE 框架获取候选者成功后的回调，发送给服务器。 override fun onIceCandidate(candidate: IceCandidate) { try { val payload = JSONObject() payload.put(&quot;label&quot;, candidate.sdpMLineIndex) payload.put(&quot;id&quot;, candidate.sdpMid) payload.put(&quot;candidate&quot;, candidate.sdp) sendMessage(id, &quot;candidate&quot;, payload) } catch (e: JSONException) { e.printStackTrace() } } // ICE 连接状态变化时的回调 override fun onIceConnectionChange(iceConnectionState: PeerConnection.IceConnectionState) { webrtcListener.onStatusChanged(iceConnectionState.name) Log.d(TAG, &quot;onIceConnectionChange ${iceConnectionState.name}&quot;) if (iceConnectionState == PeerConnection.IceConnectionState.DISCONNECTED) { removePeer(id) } } //连接成功后，最后获取到媒体流，发给 View 层进行视频/音频的播放。 override fun onAddStream(mediaStream: MediaStream) { Log.d(TAG, &quot;onAddStream &quot; + mediaStream.id) // remote streams are displayed from 1 to MAX_PEER (0 is localStream) webrtcListener.onAddRemoteStream(mediaStream, endPoint + 1) } //媒体流断开 override fun onRemoveStream(mediaStream: MediaStream) { Log.d(TAG, &quot;onRemoveStream &quot; + mediaStream.id) removePeer(id) } 在onAddStream中将 MediaStream 发给 View 层后 WebRtcClient 中的连接的工作基本完成。 View 层中将 MediaStream 绑定到 View 中 //使用 org.webrtc.SurfaceViewRenderer &lt;org.webrtc.SurfaceViewRenderer android:id=&quot;@+id/remote_renderer&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; //初始化 override fun onCreate(savedInstanceState: Bundle?) { binding.remoteRenderer.apply { setEnableHardwareScaler(true) init(eglBase.eglBaseContext, null) } } //绑定从 WebRtcClent 中转发 MediaStream override fun onAddRemoteStream(remoteStream: MediaStream, endPoint: Int) { remoteStream.videoTracks[0].addSink(binding.remoteRenderer) } 此外，上面只是展示了关键步骤，但实际编码中回调较多，还是比较繁杂。 完整代码参考 https://github.com/xiejinpeng007/WebRTC-Android-Server 信令服务器端（NodeJS） 负责转发信令等功能 部署： 在 SignalServer 根目录下执行 node app.js 会部署在 3000 端口，并监听客户端的连接情况。 使用和演示 输入信令服务器地址（公网和局域网皆可）连接服务器后， 根据在线用户进行呼叫，由于 STUN 服务器用了 Google 的，所以需要梯子。 设定服务器地址查看在线用户 选择用户进行拨号连接,可以看到成功了。 总结 优点： 当然是大部分流量不经过服务器直接点对点(P2P)传输，可以大大的节省服务商的带宽资源。 缺点: 原生只支持1对1的通信，要实现多人通信需要借助服务端的其它方案例如中转。 复杂的网络场景连接质量无法保证，比如跨国等情况，也需要服务商进行优化。 大多使用 WebRTC 技术的都根据具体业务都在此基础上进行了二次封装， Google 自家应用上也看到在使用相关的技术，所以总的来说 WebRTC 确实是一套实际可用的技术。 参考: https://github.com/xiejinpeng007/WebRTC-Android-Server (Demo) https://webrtc.github.io/webrtc-org/native-code/android/ https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols ","link":"https://xiejinpeng007.github.io/post/webrtc/"},{"title":"给现有 App 引入 Flutter Module","content":"前言 最近 Flutter 很火，相信长得帅的人都已经对它都有了初步的了解。 不过由于目前默认使用 Flutter 作为框架接管整个 App 进行开发，不够灵活：一方面使用纯 Flutter 开发需要在项目开始之前仔细评估是否有难以实现的功能；另一方面现有的 App 想使用 Flutter 的话很难全部转换过去。 很容易想到在现有的 App 的基础上加入 Flutter 作为部分画面/功能的实现是一个理想的方案，也更有利于做技术尝试和风险控制。 实际上目前 Flutter 官方提供了两种方案用于给现有 App 加入 Flutter Module，另外还有一些第三方的方案，最近我做了一些尝试，分享一些成果。 需要注意的是， 给现有 App 引入 Flutter Module 的功能还在实验性的阶段, APIs 和工具链处于未稳定阶段,且需要切换到 master 分支（不稳定）使用。 效果： 从原生App中打开 Flutter Module（ Fragment , Google Pixel3 XL ） Android 创建一个 Flutter module 假设在 some/path/MyApp 下是 Android 项目目录 cd some/path flutter create -t module --org com.example flutter_to_app 会在 some/path/flutter_to_app生成一个 Flutter Module 宿主 App 设置 需要在app/build.gradle里设置 android { //... compileOptions { sourceCompatibility 1.8 targetCompatibility 1.8 } } 让 App 依赖 Flutter Module 有两种方案，直接依赖源代码和 aar 产物。 1. 依赖生成的 aar cd ~/Documents/Android/flutter_to_app flutter build aar // MyApp/app/build.gradle android { // ... } repositories { maven { //可以使用相对路径或者绝对路径 url 'some/path/flutter_to_app/build/host/outputs/repo' } } dependencies { // ... releaseCompile ('com.example. flutter_to_app:flutter_release:1.0@aar') { transitive = true } } 可以用 flutter build aar --debug 生成 debug 依赖 // MyApp/app/build.gradle dependencies { // ... debugCompile ('com.example.my_flutter:flutter_debug:1.0@aar') { transitive = true } } 2.直接依赖源码 依赖 aar 的方式有点麻烦，还需要到 Module 中编译，所以也可以直接依赖源码编译 在宿主 App settings.gradle加入 // MyApp/settings.gradle include ':app' ... setBinding(new Binding([gradle: this])) evaluate(new File( settingsDir.parentFile, 'flutter_to_app/.android/include_flutter.groovy' )) 上面的File()路径是 flutter module 相对 host app 的路径。binding 和 include_flutter.groovy 脚本引入 flutter module 本身和相关的 plugin。 最后，依赖模块: // MyApp/app/build.gradle dependencies { implementation project(':flutter') } 在 Android 项目中使用 Flutter Module 目前有两种方式实现，分别在 io.flutter.facade.* io.flutter.embedding.android.* 两个包下， 第一种已经被 deprecated ,第二种还处于 technical preview 阶段，所以两种版本的 API 都还不稳定，但可以大概看一下两种方式。 以前的方式（deprecated） ( io.flutter.facade ) 通过使用 Flutter.createView: fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { View flutterView = Flutter.createView( MainActivity.this, getLifecycle(), &quot;route1&quot; ); FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(600, 800); layout.leftMargin = 100; layout.topMargin = 200; addContentView(flutterView, layout); } }); 通过使用 Flutter.createFragment: // MyApp/app/src/main/java/some/package/SomeActivity.java fab.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { FragmentTransaction tx = getSupportFragmentManager().beginTransaction(); tx.replace(R.id.someContainer, Flutter.createFragment(&quot;route1&quot;)); tx.commit(); } }); 创建View和Fragment都非常简单，但是实际测试下来，启动 View (FlutterFragment实际上也是通过 createView 来生成视图的)会有启动时间，体验没那么无缝。 新的方式（ io.flutter.embedding.android.* ） 通过 FlutterView ( 继承自 FrameLayout ) 实例化 FlutterView 嵌入 Native FlutterView flutterView = new FlutterView(this); FrameLayout frameLayout = findViewById(R.id.framelayout); frameLayout.addView(flutterView); //创建一个 FlutterView 就可以了，这个时候还不会渲染。 //调用下面代码后才会渲染 flutterView.attachToFlutterEngine(flutterEngine); 直接在原生App中加入 FlutterView ( Google Pixel3 XL ) 通过 FlutterFragment 打开 通过 xml &lt;fragment android:id=&quot;@+id/flutterfragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:name=&quot;io.flutter.embedding.android.FlutterFragment&quot; /&gt; 直接实例化 flutterFragment = new FlutterFragment.createDefault(); 通过 FlutterActivity 打开 在 AndroidManifest.xml 中注册 &lt;activity android:name=&quot;io.flutter.embedding.android.FlutterActivity&quot; android:theme=&quot;@style/LaunchTheme&quot; android:configChanges=&quot;orientation|keyboardHidden|keyboard|screenSize|locale|layoutDirection|fontScale|screenLayout|density&quot; android:hardwareAccelerated=&quot;true&quot; android:windowSoftInputMode=&quot;adjustResize&quot; android:exported=&quot;true&quot; /&gt; 默认启动方式 //默认路由为 '/' Intent defaultFlutter = new FlutterActivity.createDefaultIntent(currentActivity); startActivity(defaultFlutter); 启动到指定路由 Intent customFlutter = new FlutterActivity.IntentBuilder() .initialRoute(&quot;someOtherRoute&quot;) .build(currentActivity); startActivity(customFlutter); FlutterEngine 缓存机制 实际上，通过 API 和源码可以看出，新版的 Flutter 相关类io.flutter.embedding.android.*完全重新设计了 Native 调用的方式，从包名（embedding）就可以看出是希望嵌入 Native， 其中一个重要的变化是加入了 FlutterEngine 的缓存机制。 通过老的方式启动 Flutter 的响应时间长包括了需要启动FlutterEngine的时间，可以理解为冷启动，而且从原生的不同Activity / ViewController 启动 Flutter 都需要启动一个新的 FlutterEngine，所以不仅第一次启动 Flutter 时间长 ，每次启动都会需要同样的时间。比如下面的情况 Native A -&gt; Flutter B -&gt; Native C -&gt; Flutter D 这样从Native A 和 Native B启动时会实例化两个FlutterEngine。 未使用 FlutterEngineCache 时从原生 App 启动白屏 ( Google Pixel3 XL ) 这样不仅慢，对资源的开销也更多。 为了解决这个问题，新的解决方案引入了FlutterEngine 缓存机制。 1. 使用 FlutterEngineCache // 实例化 FlutterEngine. FlutterEngine flutterEngine = new FlutterEngine(context); // 预热 flutterEngine .getDartExecutor() .executeDartEntrypoint( DartEntrypoint.createDefault() ); //放入 FlutterEngineCache FlutterEngineCache .getInstance() .put(&quot;my_engine_id&quot;, flutterEngine); //启动 Activity 的时候使用 Intent intent = FlutterActivity .withCachedEngine(&quot;my_engine_id&quot;) .build(); startActivity(intent); //实例化 Fragment FlutterFragment flutterFragment = FlutterFragment .withCachedEngine(&quot;my_engine_id&quot;) .build(); 2. 继承 FlutterFragment / FlutterActivity 自行处理存储 FlutterEngine 的地方 public class MyFlutterFragment extends FlutterFragment { @Override @Nullable protected FlutterEngine provideFlutterEngine(@NonNull Context context) { //自行存储 FlutterEngine 实例 return MyFlutterEngine.getFlutterEngine(); //比如 Application 中 return ((MyApp) context.getApplication).getFlutterEngine(); } } public class MyFlutterActivity extends FlutterActivity { @Nullable @Override public FlutterEngine provideFlutterEngine(@NonNull Context context) { FlutterEngine flutterEngine; //自行存储 FlutterEngine 实例 flutterEngine = MyFlutterEngineCache.getFlutterEngine(); //比如 Application 中 flutterEngine = ((MyApp) getApplication()).getFlutterEngine(); return flutterEngine; } } 3. 在 Activity 实现 FlutterEngineProvider 接口 public class MyActivity extends Activity implements FlutterEngineProvider { @Override @Nullable FlutterEngine provideFlutterEngine(@NonNull Context context) { //自行存储 FlutterEngine 实例 return MyFlutterEngine.getFlutterEngine(); //比如 Application 中 return ((MyApp) context.getApplication).getFlutterEngine(); } } FlutterBoost 方案 新一代 Flutter-Native 混合解决方案。 FlutterBoost是一个Flutter插件，它可以轻松地为现有原生应用程序提供Flutter混合集成方案。FlutterBoost的理念是将Flutter像Webview那样来使用。在现有应用程序中同时管理Native页面和Flutter页面并非易事。 FlutterBoost帮你处理页面的映射和跳转，你只需关心页面的名字和参数即可（通常可以是URL）。 FlutterBoost 是闲鱼开源处理 Flutter-Native 混合开发的解决方案，是一个热门的方案，但和官方方案对比我认为有两个重要的异同点： 当时闲鱼设计这个库其中的一个重要目的就是为了解决 FlutterEngine 无法重用的问题（当时 Flutter 团队还没有可以处理 FlutterEngine 重用的方案），而现在 Flutter 团队推出的新的解决方案也可以解决这个问题。 目前 Flutter 官方的方案的细粒度更小，可以通过 View 的方式调用 Flutter ，也就是说你可以只将画面中的某一个图表用 Flutter 替换。 最后，官方的两种方案一种已经被舍弃一种还处于实验性阶段，目前最新方案的Milestone 是12月，所以到时候再次评估可行性。而国内大厂基本上各自都有自己的解决方案，所以目前使用官方方案的话还需要仔细评估。 iOs WIP ","link":"https://xiejinpeng007.github.io/post/add-flutter-module-to-app/"},{"title":"Flutter 介绍 & 开发经验总结","content":"Flutter 介绍 &amp; 开发经验总结 前言 Flutter 已经推出2年了，虽然一直在关注，但还是想等生态成熟一点再去踩坑。近期有一个需要使用跨平台技术的项目，在讨论后，我们选择使用 Flutter。开发完成之后，我这里总结一些重要的点，供大家参考。 当然，要学习的话最后还是需要读一遍文档，然后自己 Coding。 环境配置： 参考官方文档 Dart 语言 Flutter 采用 Dart 语言，我使用之后的感受就是： 语法基本等于 Java + Javascript + 另外一些常见的语法，没太大学习成本，也没太大亮点，下面列一些值得一提的点。 所有变量都是对象 静态语言 支持闭包 方法是顶级的 支持反射（Flutter 不支持反射） 没有可见性修饰符 属性/类前加_就是 private Stream : 支持 map... 各类操作符，订阅等 异步：Dart 的异步操作也通过 Futrue（同 Javascript 中的 Promise） 的方式实现，也支持 async await 语法糖（自动包装为Futrue）。这并不是 Dart 特有的特性，网上有大量资料可以参考。 赋值操作符 ?: ?? ??= 可选方法参数 void setUser(String name,{id = '0'}); //调用 setUser('mario',id : '01'); 联级操作符 var profit = Profit() ..fund = 'fund' ..profit = 'profit' ..profitValue = 'profitValue'; dynamic 可以指代任何类型，不会进行类型检查。 var a = 'test'; (a as dynamic).hello();//编译器不会报错 Flutter Widget 概念 在Flutter中几乎所有的对象都是一个Widget。与原生开发中“控件”不同的是，Flutter中的Widget的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector widget、用于APP主题数据传递的Theme等等，而原生开发中的控件通常只是指UI元素。 我的理解为 Widget 的工作 = HTML + CSS 的工作。而且很多配置样式的属性名字和 CSS 中的名字差不多。 Widget 分为 StatelessWidget StatefulWidget 两种，他们的核心方法都是通过build()方法返回一个 Widget 。 @protected Widget build(BuildContext context); StatelessWidget 的build()在 Widget 中。 StatefulWidget由于必须创建相应的 State&lt;T extends Widget&gt; ,所以包括build()在内的相关生命周期方法都在State中。 下面是State的生命周期，由于一个画面也是一个 Widget 所以也是一个画面的生命周期。 Widget 目录 ( link ) 上面是官方提供的所有的 Widget，可以看到基本上所有UI相关的内容都是通过不同类型的 Widget 来实现，通过child/children参数进行嵌套。 不同风格的 Widget 除了基础 Widget 外，官方提供了 Material(Android) + Cupertino(ioS) 两种视觉风格的 Widget。 例如你可以在使用一个 Marterial 风格的RaisedButton或是 Cuptino 风格的CupertinoButton，再也不用担心设计师让 Android 照着 ioS 做成一样了。 Layout Widget 还有用来控制布局的 Layout Widget ,作为容器来使用，看名字都大概知道什么作用了。 Container Padding Center Stack Column Row Expanded ListView 交互模型 Widget 控制点击、滑动等交互的 Widget。 在 Flutter 里点击事件并不是setOnClickListener的方式 ，而是给 Widget 外层加一层交互 Widget ，如点击可使用GestureDetector。 例如给上面 Splash 画面中的Image加一个点击事件。 @override Widget build(BuildContext context) { return Container( height: double.infinity, width: double.infinity, child: Image.asset('images/logo.png'), ); } ==&gt; @override Widget build(BuildContext context) { return Container( height: double.infinity, width: double.infinity, child: GestureDetector( onTap: () { //点击事件 }, child: Image.asset('images/logo.png'), ), ); } Sample 所以，一个最基本的 Widget 长什么样？这是一个带有是否 login 检查的 Splash 画面。 StatelessWidget class SplashPage extends StatelessWidget { @override Widget build(BuildContext context) { checkLogin(); return Container( height: double.infinity, width: double.infinity, child: Image.asset('images/logo.png'), ); } // 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。 checkLogin(BuildContext context) async { var sp = await SharedPreferences.getInstance(); var token = sp.getString(&quot;X-Auth-Token&quot;); if (token != null &amp;&amp; token != &quot;&quot;) Navigator.pushNamedAndRemoveUntil( context, HomePage.routeName, (_) =&gt; false); else Navigator.pushNamed(context, LoginRegisterPage.routeName); } } StatefulWidget class SplashPage extends StatefulWidget { //创建相应的 State @override State createState() =&gt; _SplashState(); } class _SplashState extends State&lt;SplashPage&gt; { @override void initState() { super.initState(); checkLogin(context); } @override Widget build(BuildContext context) { return Container( height: double.infinity, width: double.infinity, child: Image.asset('images/logo.png'), ); } // 使用 async 语法自动包装为 Futrue，也就是说这个方法是异步的。 checkLogin(BuildContext context) async { var sp = await SharedPreferences.getInstance(); var token = sp.getString(&quot;X-Auth-Token&quot;); if (token != null &amp;&amp; token != &quot;&quot;) Navigator.pushNamedAndRemoveUntil( context, HomePage.routeName, (_) =&gt; false); else Navigator.pushNamed(context, LoginRegisterPage.routeName); } @override void dispose() { super.dispose(); } } App 结构 上图是整个 Flutter App 的结构，从父节点开始分别是： MyApp: 整个 App 的入口在main.dart的main()函数中，调用 runApp(MyApp()),而 MyApp 也是一个 Widget，只不过用来定义一些全局的内容，例如主题、多语言，路由 MaterialApp: 一个 Material 风格的主题，对应的还有 CupertinoApp。 MyHomePage MyHomePageState : 一个画面，也是 Widget。 Scaffold : 定义了一个画面的一些基本效果，比如这里 AppBar、滑动效果等采用 Material 风格，另外还有 ioS 风格的 CupertinoPageScaffold。 剩下就是一些基本的组件。 一个基本的 main.dart 大概长这样： void main() async { runApp(MyApp()); } class MyApp extends StatelessWidget { static final navigatorKey = GlobalKey&lt;NavigatorState&gt;(); static NavigatorState get navigator =&gt; navigatorKey.currentState; @override Widget build(BuildContext context) { return CupertinoApp( title: '', theme: CupertinoThemeData( primaryColor: Color(0xFFFFFFFF), barBackgroundColor: Color(0xFF515669), scaffoldBackgroundColor: Color(0xFF3C3B45), ), navigatorKey: navigatorKey, routes: { HomePage.routeName: (_) =&gt; HomePage(), LoginRegisterPage.routeName: (_) =&gt; LoginRegisterPage(), LoginPage.routeName: (_) =&gt; LoginPage(), ForgetPswPage.routeName: (_) =&gt; ForgetPswPage(), RegisterPage.routeName: (_) =&gt; RegisterPage(), }, ), home: SplashPage(), ); } } theme 定义了一个 ioS 风格的 CupertinoApp 主题（实际开发中可能需要同时使用 Material Cupertino 风格控件所以需要自定义主题） routes 参数注册路由表 home 参数设置首次加载的 Splash 画面 路由 和 Web 中的路由类似，通过在路由表注册相应的 url 和画面。基本方法 push / pushNamed / pushNamedAndRemoveUntil/... pop / popUntil / ... 基本使用： // pushNamed 的定义 Future pushNamed(BuildContext context, String routeName,{Object arguments}) //打开一个画面，传一个00 Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: '00'); //新画面接受参数 var arg = ModalRoute.of(context).settings.arguments); //关闭一个画面，返回一个01 Navigator.of(context).pop(01); 实际上更好的方法来处理传值的问题 可以看到pushNamed方法返回值是一个Future ，说明是一个异步操作，因为可以接受打开的画面pop关闭时返回的result ，此处在pop时返回了一个 01，那么就可以这样接收到。 var result = async Navigator.of(context).pushNamed(&quot;home_page&quot;, arguments: 'arg'); 网络请求和序列化 Flutter 的 网络请求库没有特别完美的，目前使用的是 Dio ,大致是一个简化版的 okhttp 。 由于 Flutter 禁止使用反射，因为运行时反射会干扰 Dart 的 tree shaking，所以类似 Gson 这样通过反射进行序列化的方式就行不通了。 目前大概的解决方案有两种： 手写：Dio 会把返回值解析为 Map/List ，所以可以这样手写: Future&lt;Profits&gt; requestProfits() async { var response = await dio.get(&quot;u/profits&quot;); var data = response.data; print(&quot;requestProfits:$data&quot;); var profit = Profit() ..fund = data['profit'][&quot;fund&quot;] ..profit = data['profit'][&quot;profit&quot;] ..profitValue = toMoney(data['profit']['profitValue']); return Profits() ..miningProfit = data['miningProfit'] ..lastMiningProfit = data['lastMiningProfit'] ..shareProfit = data['shareProfit'] ..lastShareProfit = data['lastShareProfit'] ..tradeProfit = data['tradeProfit'] ..lastTradeProfit = data['lastTradeProfit'] ..vipProfit = data['vipProfit'] ..lastVipProfit = data['lastVipProfit'] ..profit = profit; } 生成代码：使用 json_serializable //user.dart import 'package:json_annotation/json_annotation.dart'; // user.g.dart 将在我们运行生成命令后自动生成 part 'user.g.dart'; ///这个标注是告诉生成器，这个类是需要生成Model类的 @JsonSerializable() class User{ User(this.name, this.email); String name; String email; //不同的类使用不同的mixin即可 factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this); } 当然，还是需要写 fromJson toJson 的模板代码，也可以通过生成的方式解决。 平台特定代码 Flutter 主要是负责了UI部分的构建，各平台特定的代码还是要通过原生实现，主要用两种方法处理： Platform Channel : 大概就是 Flutter 端和原生端注册约定好 platform_channel_name 的 Platform Channel ，然后调用方法和传参，另一端解析就行了。具有原生能力的 plugin 也就是这样实现的。比如 //flutter MethodChannel('method_channel_mobile').invokeMethod('sendMobile','13000000000') //Android MainActivity MethodChannel(flutterView, MOBILE_CHANNEL) .setMethodCallHandler { methodCall, result -&gt; when { TextUtils.equals(methodCall.method, &quot;mobile&quot;) -&gt; { mobile = methodCall.arguments.toString() result.success(&quot;success&quot;) } result.notImplemented() } } PlatformView 直接嵌套原生的 View 到 Flutter 中，但这样做效率不高。另外需要注意的是不要传入一个 view 到PlatformView中，否则可能出现 Flutter 端多次调用该PlatformView的时候状态会共存，以及不会销毁。 // 定义一个用于的 PlatformView 和 PlatformViewFactory 用于实例化 Native View class ButtonFactory( private val context: Context ) : PlatformViewFactory(StandardMessageCodec.INSTANCE) { override fun create(p0: Context?, p1: Int, p2: Any?): PlatformView { return ButtonPlatformView(context) } class ButtonPlatformView( private val context: Context ) : PlatformView { override fun getView(): Button { return Button(context) } override fun dispose() { } } } //在 MainActivity 中注册 registrarFor(&quot;native_view&quot;).platformViewRegistry() .registerViewFactory(&quot;native_view&quot;,ButtonPlatformFactory) Widget 嵌套的问题 网上对 Flutter 嵌套讨论的比较多的问题就是，UI 复杂了以后，嵌套层数太多。 确实有这个问题，之前说了 Widget 不光是 View 还包括配置文件，所以一个类似 Button 这样的 Widget 可能就需要嵌套3 4层。 下面是我写的一个登录画面的登录按钮，感受一下: CupertinoButton _loginButton() { return CupertinoButton( padding: EdgeInsets.all(0), child: Container( width: double.infinity, height: 45, decoration: BoxDecoration( gradient: LinearGradient( begin: Alignment.topCenter, end: Alignment.bottomCenter, colors: _isLoginAvailable ? &lt;Color&gt;[Color(0xFF657FF8), Color(0xFF4260E8)] : &lt;Color&gt;[Color(0xFFCBCFE2), Color(0xFF73788F)]), borderRadius: BorderRadius.all(Radius.circular(6)), ), child: Center( child: Text( &quot;登 录&quot;, textAlign: TextAlign.center, style: TextStyle( fontSize: 18, color: _isLoginAvailable ? Colors.white : Color(0x76FFFFFF), fontWeight: FontWeight.bold, ), ), )), // shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)), onPressed: !_isLoginAvailable ? null : _startCustomFlow, ); } 实际上这还是只是结构+样式部分，不包括点击后的逻辑。 甚至你可以看到 Button 中的文字也是通过嵌套一个 Widget 来实现的，但这也是 Flutter 的一个优势，不再需要写自定义 Widget 的人去提供大量像文字能不能加粗，变色、斜体等等细节的样式，直接让你传一个 Widget 自行处理，类似的情况还有很多。 另外一个问题是 Widget State 的状态可能太多，包括各个 Widget 的状态和画面的状态堆在一起，想起了当年原生 Android 一个 Activity 50个变量的恐惧。 但我认为这些主要还是因为 Flutter 处于发展的初期，还没有太成熟的架构，目前官方提供了状态管理的库 Provider。 我目前的解决方案是尽量提成方法和独立的Widget： 对于有整个页面无关局部状态的 Widget 提成一个独立的 StatefulWidget。 对于没有局部状态的，需要重用就提成一个StatelessWidget，不需要就抽成一个方法，返回 Widget，参考上面的 Button 。 最后在build()方法中只描述整个画面的结构。 例如一个 login 画面的build()方法我是这样写的： @override Widget build(BuildContext context) { return MaterialApp( home: Scaffold( appBar: cusAppBar(context, elevation: 0), backgroundColor: $3C3B45, body: Stack( children: &lt;Widget&gt;[ SingleChildScrollView( child: Container( margin: EdgeInsets.only(left: 15, right: 15), child: Column( children: &lt;Widget&gt;[ _logo(), Form( onChanged: _onFormChanged, child: Column( children: &lt;Widget&gt;[ _phoneRow(), _divider(), _passwordColumn(), _forgetPswText(), _loginButton(), _registerText() ], ), ), ], ), ), ), ], ), ), ); } 热重载（HotReload） Flutter 的热重载是广受欢迎的一个特性，重要原因则是 Debug 模式采用 JIT 编译，release 模式采用 AOT 编译。实际用下来效果不错。 问题 编译偶尔遇到的一个问题： 问题：Waiting for another flutter command to release the startup lock... 解决：rm ./flutter/bin/cache/lockfile 最后，以上只是总结一些重要的点，最终官方文档肯定是要读一遍的,熟悉大部分 Widget 的用法: 文档 总结 优点： Android iOs 两端 UI 高度一致：由于 Flutter 使用自己的一套绘制 UI 的引擎和逻辑，完全不使用 Native View，仅仅调用原生的绘制接口，所以几乎可以做到两个平台的 UI 一模一样，这也是 Flutter 还要做 Web maCos 等全平台的原因。我在开发期间一直使用 Android 进行调试，最后在 Ios 上跑的时候，几乎没有什么差别(虽然目前 UI 也不太复杂)。 接入原生相对容易：需要原生实现的功能通过PlatformChannel和 PlatformView也大多都能实现，还可以通过PlatformChannel来启动一个原生的Activity/Fragment实现。（比如扫一扫功能） 贵族血统：Google 的全力支持，国内大厂也都在积极尝试。 初步可用的程度：目前已经完成了一个小项目的开发，在和原生交互不多的情况下还没有遇到太大的坑。 缺点： 基础功能的缺失：很多基础的功能也需要用 plugin 通过原生来实现，比如 Webview Map 这些组件，更不要说一些 SDK ,几乎都需要自己写 plugin。 跨平台的通信：对于大量使用MethodChannel进行通信以及各平台间API有差异的情况下，设计和维护的问题。 性能：目前原生 Flutter 在帧数上接近原生，用户使用体验接近，但内存开销更大，尤其在视频方面。 总的来说：我的看法是，比较看好 Flutter 跨更多平台的前途，目前来说适合用来开发和原生平台 API 交互不那么复杂的 App 。 ","link":"https://xiejinpeng007.github.io/post/introducing-the-flutter/"},{"title":"配置 Gitlab-CI 触发企业微信群机器人发送通知","content":"配置 Gitlab-CI 触发企业微信群机器人发送通知 最近企业微信增加了群机器人功能，可以拿来在 Gitlab-CI 打包完成后发送通知，分享下配置方法： 配置群机器人: 在相应群右键-添加群机器人-设置相关参数 可以看到给出了相应的 Webhook 地址和使用文档,本质就是发一个 POST 请求。 url 包含了相关 key , JSON 包含消息内容。 消息内容支持三种类型，具体语法可以参考文档。 text markdown 图文 然后可以用 Postman 或者 Terminal 来测试能否收到（替换为自己的 WebHook）。 curl 'http://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxx' \\ -H 'Content-Type: application/json' \\ -d ' { &quot;msgtype&quot;: &quot;text&quot;, &quot;text&quot;: { &quot;content&quot;: &quot;hello world&quot; } }' 配置到 Gitlab-CI: 在原来正常的打包流程基础上，写一个打包成功(失败)后触发的脚本，放在和 gitlab-ci.yml 同级，传入不同参数，发送不同数据，我这里通过第一个参数判断成功失败： 成功的参数: on_success branch_name commit_hash apk_name 失败的参数：on_failure #!/usr/bin/env bash if [[ $1 == &quot;on_success&quot; ]]; then curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \\ -H 'Content-Type: application/json' \\ -d ' { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;content&quot;: &quot;分支:'$2' 提交:'$3' '$4'.apk 打包完成！ [点击查看](https://your_url/pipelines)&quot; } }' elif [[ $1 == &quot;on_failure&quot; ]]; then curl 'https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=48d51802-bf41-4641-b0aa-33d67a2c9ed8' \\ -H 'Content-Type: application/json' \\ -d ' { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;content&quot;: &quot;打包失败！ [点击查看](https://your_url/pipelines)&quot; } }' fi 改一下 gitlab-ci.yml 文件中的配置调用脚本: ... build_production_release: stage: build_production_release script: - ./gradlew assembleProductionRelease - mv app/build/outputs/apk/production/release/*.apk . - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot; artifacts: name: &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot; paths: - ./*.apk expire_in: 2 weeks when: manual # except: # - feature/CI-CD clean_build_job: stage: clean script: - ./gradlew clean - sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot; when: on_failure ... 在打包的 job ( build_production_release ) ./gradle assemblexxx 之后传入相关参数调用脚本成功的代码 sh ./Android_Gitlab_Ci_Notification.sh &quot;on_success&quot; ${CI_COMMIT_REF_SLUG} ${CI_COMMIT_SHA:0:8} &quot;PackageName_productionRelease_${CI_COMMIT_REF_SLUG}_${CI_COMMIT_SHA:0:8}&quot; 打包失败时的 job ( clean_build_job ) 传入 on_failure 调用脚本失败的代码 sh ./Android_Gitlab_Ci_Notification.sh &quot;on_failure&quot; ","link":"https://xiejinpeng007.github.io/post/pei-zhi-gitlab-ci-hong-fa-qi-ye-wei-xin-qun-ji-qi-ren-fa-song-tong-zhi/"},{"title":"使用 XDslPagerAdapter 快速创建 ViewPager","content":"使用 XDslPagerAdapter 快速创建 ViewPager 在 Android 开发中经常需要使用 ViewPager ，大多数的功能类似但每次都需要写 Adapter 和一堆模板代码。 目前我们很多项目都使用了 Kotlin 和 Databinding,为了简洁快速地构建 ViewPager，我使用 DSL 和 Databinding 的特性写了一个用于快速创建 PagerAdapter 的工具XDslPagerAdapter。 下面通过创建一个欢迎画面举例说明： binding.guideViewPager.run { xDslPagerAdapter { item(R.layout.pager_guide) { model(BR.model to Page(0, R.drawable.img_tutorial01, &quot;下一页&quot;)) click(BR.click to { _: Page -&gt; currentItem = 1 }) action { binding -&gt; (binding as? PagerGuideBinding)?.run { (nextPageButton.layoutParams as? ViewGroup.MarginLayoutParams)?.run { marginStart = dp2px(30F) marginEnd = dp2px(30F) } } } } item(R.layout.pager_guide) { model(BR.model to Page(1, R.drawable.img_tutorial02, &quot;下一页&quot;)) click(BR.click to { _: Page -&gt; currentItem = 2 }) } item(R.layout.pager_guide) { model(BR.model to Page(2, R.drawable.img_tutorial03, &quot;下一页&quot;)) click(BR.click to { _: Page -&gt; currentItem = 3 }) } item(R.layout.pager_guide) { model(BR.model to Page(3, R.drawable.img_tutorial04, &quot;开始使用&quot;)) click(BR.click to { _: Page -&gt; SharedPrefModel.isFistTime = false startActivity(Intent(context, MainActivity::class.java)) finish() }) } } } 首先调用 ViewPager 的拓展方法xDslPagerAdapter()开始创建PagerAdapter 在PagerAdapter内部使用 item()开始创建Item，其中layout是必须的参数。 在Item内部可以使用的方法有model()``click()``action model()传入包含 DataBinding 的 BR.Id 和对应的 Model（类型为你 ViewModel 的类型，用来绑定显示相关数据） click()传入包含 DataBinding 的 BR.Id 和对应的 Click（类型为Function&lt;Any&gt;用来绑定点击事件），多个点击事件可多次调用。 action()可用来获取 Databinding 为 layout 的 ViewDataBinding 类,用来处理其它的内容，例如动态改变布局等。 源码也很简单 源码地址 https://github.com/xiejinpeng007/XDslPagerAdapter ","link":"https://xiejinpeng007.github.io/post/shi-yong-xdslpageradapter-kuai-su-chuang-jian-viewpager/"},{"title":"RxJava2.x 从源码分析原理","content":"RxJava 相信各位已经使用了很久，大部分人在刚学习 RxJava 感叹切换线程的方便，调用逻辑清晰的同时，并不知道其中的原理，主要是靠记住运行的顺序。 随着我们设计出的 RxJava流 越来越复杂，一些复杂的问题并不能靠着记住的运行顺序就能解决。 下面，就通过最常用的操作符的源码来看看所谓的流是什么运行的。 首先我们用Single举例，设计一个最基本的 RxJava 流，只有一个 Observable(ColdObservable) 和Obsever： Disposable disposable = Single.just(&quot;wtf&quot;) .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, it)); 上游发送一个&quot;wtf&quot; ，下游接受时将其打印出来。上游发送端使用 Single.just 作为创建方法, 看一下 just() 方法里做了什么。 public static &lt;T&gt; Single&lt;T&gt; just(final T item) { ObjectHelper.requireNonNull(item, &quot;value is null&quot;); return RxJavaPlugins.onAssembly(new SingleJust&lt;T&gt;(item)); } public static &lt;T&gt; Single&lt;T&gt; onAssembly(@NonNull Single&lt;T&gt; source) { Function&lt;? super Single, ? extends Single&gt; f = onSingleAssembly; if (f != null) { return apply(f, source); } return source; } 其中 ObjectHelper.requireNonNull 只是空检查。 RxJavaPlugins.onAssembly 方法，这个方法其实就是通过一个全局的变量 onSingleAssembly 来对方法进行 Hook ，这一系列xxxAssembly全局变量默认为空，所以实际上当我们没有设置的时候其实 just 方法是直接返回了一个 新实例化的SingleJust对象。 再看看SingleJust内部： public final class SingleJust&lt;T&gt; extends Single&lt;T&gt; { final T value; public SingleJust(T value) { this.value = value; } @Override protected void subscribeActual(SingleObserver&lt;? super T&gt; observer) { observer.onSubscribe(Disposables.disposed()); observer.onSuccess(value); } } 实例化的时候只是将值保存了下来，没有其它操作。 下一步调用subscribe()来启动这个流(ColdObservable)，然后看看subscribe中做了什么： public final void subscribe(SingleObserver&lt;? super T&gt; subscriber) { ObjectHelper.requireNonNull(subscriber, &quot;subscriber is null&quot;); subscriber = RxJavaPlugins.onSubscribe(this, subscriber); ObjectHelper.requireNonNull(subscriber, &quot;subscriber returned by the RxJavaPlugins hook is null&quot;); try { //核心逻辑 subscribeActual(subscriber); } catch (NullPointerException ex) { throw ex; } catch (Throwable ex) { Exceptions.throwIfFatal(ex); NullPointerException npe = new NullPointerException(&quot;subscribeActual failed&quot;); npe.initCause(ex); throw npe; } } 同样 RxJavaPlugins.onSubscribe 默认没有作用,实际的核心逻辑是调用了subscribeActual(SingleObserver)。 对于我们上面设计的流，则是调用了 SingleJust 中的 subscribeActual(SingleObserver) 回顾上面 SingleJust 中 subscribeActual(SingleObserver) 的实现： observer.onSubscribe(Disposables.disposed()); observer.onSuccess(value); 得到两个信息 首先调用下游观察者 SingleObserver 的 OnSubscribe 方法并传递用于取消操作的 Disposable 调用OnSuccess 方法并传递之前保存下来的 value Map 操作符 现在我们加入一个常用且重要的Map操作到流中 Disposable disposable = Single.just(&quot;wtf&quot;) .map(it-&gt; 0) .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it))); 上面这个流包括了三种典型的操作 创建Creation 操作符Transformation和 订阅Subscribe。 依然先检查map() 方法，可以看到其中实例化了一个SingleMap public final &lt;R&gt; Single&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper) { ObjectHelper.requireNonNull(mapper, &quot;mapper is null&quot;); return RxJavaPlugins.onAssembly(new SingleMap&lt;T, R&gt;(this, mapper)); } 再看看 SingleMap public final class SingleMap&lt;T, R&gt; extends Single&lt;R&gt; { final SingleSource&lt;? extends T&gt; source; final Function&lt;? super T, ? extends R&gt; mapper; public SingleMap(SingleSource&lt;? extends T&gt; source, Function&lt;? super T, ? extends R&gt; mapper) { this.source = source; this.mapper = mapper; } @Override protected void subscribeActual(final SingleObserver&lt;? super R&gt; t) { source.subscribe(new MapSingleObserver&lt;T, R&gt;(t, mapper)); } static final class MapSingleObserver&lt;T, R&gt; implements SingleObserver&lt;T&gt; { final SingleObserver&lt;? super R&gt; t; final Function&lt;? super T, ? extends R&gt; mapper; MapSingleObserver(SingleObserver&lt;? super R&gt; t, Function&lt;? super T, ? extends R&gt; mapper) { this.t = t; this.mapper = mapper; } @Override public void onSubscribe(Disposable d) { t.onSubscribe(d); } @Override public void onSuccess(T value) { R v; try { v = ObjectHelper.requireNonNull(mapper.apply(value), &quot;The mapper function returned a null value.&quot;); } catch (Throwable e) { Exceptions.throwIfFatal(e); onError(e); return; } t.onSuccess(v); } @Override public void onError(Throwable e) { t.onError(e); } } } 类中信息稍微复杂一些： 首先我们关注在SingleMap实例化的时候也是只做了保存数据的操作，而没有实际逻辑：将流的上游保存为 source 将数据转换的方法保存为 mapper 第二步我们知道下游观察者 SingleObserver 会调用核心逻辑 subscribeActual方法来启动流 在这里的subscribeActual方法中可以看到几个重要的信息 MapSingleObserver是一个观察者 MapSingleObserver 保存了下游的观察者 SingleObserver 以及 mapper 上游 source 被 MapSingleObserver 订阅 由此可以看出在SingleMap被下游观察者订阅了之后，实例化了一个新的观察者MapSingleObserver并保存下游观察者SingleObserver的信息，再去订阅上游SingleJust。 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能的设计模式称为装饰者模式。 总结上面的执行顺序： 在Rx流的最后一步调用 subscribe启动流(ColdObservable) 首先执行SingleMap中的subscribeActual方法，其中包括生成新的MapSingleObserver并订阅 SingleJust 执行SingleJust中的subscribeActual：调用下游MapSingleObserver的onSubscribe onSuccess方法 MapSingleObserver中的onSubsribe onSuccess方法也很简单，分别调用下游 Observer的 onSubsribe``onSuccess(异常时 onError)方法 observeOn 操作符 Rxjava首先被大家津津乐道之处是可以方便的切换线程，避免Callback Hell，现在来看看线程切换操作符。 我们加入线程切换操作符 observeOn Disposable disposable = Single.just(&quot;wtf&quot;) .map(it-&gt; 0) .observeOn(Schedulers.io()) .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, String.of(it))); 同样的，在 observeOn方法中实例化了一个SingleObserveOn public final Single&lt;T&gt; observeOn(final Scheduler scheduler) { ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;); return RxJavaPlugins.onAssembly(new SingleObserveOn&lt;T&gt;(this, scheduler)); } 继续看SingleObserveOn类中信息 public final class SingleObserveOn&lt;T&gt; extends Single&lt;T&gt; { final SingleSource&lt;T&gt; source; final Scheduler scheduler; public SingleObserveOn(SingleSource&lt;T&gt; source, Scheduler scheduler) { this.source = source; this.scheduler = scheduler; } @Override protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) { source.subscribe(new ObserveOnSingleObserver&lt;T&gt;(s, scheduler)); } static final class ObserveOnSingleObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements SingleObserver&lt;T&gt;, Disposable, Runnable { private static final long serialVersionUID = 3528003840217436037L; final SingleObserver&lt;? super T&gt; actual; final Scheduler scheduler; T value; Throwable error; ObserveOnSingleObserver(SingleObserver&lt;? super T&gt; actual, Scheduler scheduler) { this.actual = actual; this.scheduler = scheduler; } @Override public void onSubscribe(Disposable d) { if (DisposableHelper.setOnce(this, d)) { actual.onSubscribe(this); } } @Override public void onSuccess(T value) { this.value = value; Disposable d = scheduler.scheduleDirect(this); DisposableHelper.replace(this, d); } @Override public void onError(Throwable e) { this.error = e; Disposable d = scheduler.scheduleDirect(this); DisposableHelper.replace(this, d); } @Override public void run() { Throwable ex = error; if (ex != null) { actual.onError(ex); } else { actual.onSuccess(value); } } @Override public void dispose() { DisposableHelper.dispose(this); } @Override public boolean isDisposed() { return DisposableHelper.isDisposed(get()); } } } 类似的 构造函数中保存了上游和线程切换的信息 subscribeActual 实例化了一个新的观察者ObserveOnSingleObserver 不同的 ObserveOnSingleObserver 还继承了AtomicReference&lt;Disposable&gt;、实现了Disposable``Runnable接口 onSuccess``onError中都没有直接调用下游的onSuccess onError方法，而是调用了Disposable d = scheduler.scheduleDirect(this);来执行run方法中的逻辑，而run方法中的逻辑则是调用下游的onSuccess onError方法 查看schedulerDirect内部信息 public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) { final Worker w = createWorker(); final Runnable decoratedRun = RxJavaPlugins.onSchedule(run); DisposeTask task = new DisposeTask(decoratedRun, w); w.schedule(task, delay, unit); return task; } 创建了一个对应线程的Worker和一个可用于取消的DisposeTask并执行，对于IoScheduler则是创建了EventLoopWorker，再看看EventLoopWorker中的信息。 @Override public Worker createWorker() { return new EventLoopWorker(pool.get()); } static final class EventLoopWorker extends Scheduler.Worker { private final CompositeDisposable tasks; private final CachedWorkerPool pool; private final ThreadWorker threadWorker; final AtomicBoolean once = new AtomicBoolean(); EventLoopWorker(CachedWorkerPool pool) { this.pool = pool; this.tasks = new CompositeDisposable(); this.threadWorker = pool.get(); } @Override public void dispose() { if (once.compareAndSet(false, true)) { tasks.dispose(); // releasing the pool should be the last action pool.release(threadWorker); } } @Override public boolean isDisposed() { return once.get(); } @NonNull @Override public Disposable schedule(@NonNull Runnable action, long delayTime, @NonNull TimeUnit unit) { if (tasks.isDisposed()) { // don't schedule, we are unsubscribed return EmptyDisposable.INSTANCE; } return threadWorker.scheduleActual(action, delayTime, unit, tasks); } } EventLoopWorker中则是维护了一套包含相应的线程池、可取消的CompositeDisposable、以及用于运行Runable的ThreadWorker。总的来说就是一套可以在相应线程运行且可取消的类和逻辑。 上面则解释了为什么observeOn可以切换下游的线程(onSuccess onError) 同样解释了为什么不会改变onSubsribe的调用线程，因为可以看到onSubscribe方法中直接调用了下游的onSucsribe，并没有受到线程切换的影响。 SubscribeOn 实际上，subsribeOn 是 RxJava2.x 中比较复杂也是相较于 RxJava1.x 改动比较大的一个操作符,它甚至会影响流的执行顺序。（可以参见唐雪茂写的 Rxjava流的设计 中的1 2两个流） 我们现在设计两个Rx流 Disposable disposable = Single.just(&quot;wtf&quot;) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3) .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4); Disposable disposable2 = Single.just(&quot;wtf&quot;) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 0) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 1) .subscribeOn(Schedulers.io()) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 2) .doOnSubsribe(it-&gt; Log.i(&quot;doOnSubsribe&quot;, 3) .subscribe(it -&gt; Log.i(&quot;subscribe&quot;, 4); 你可能已经知道并记住了两个流的打印的顺序分别是 01234 23014，但是为什么doOnSubsribe方法和RxJava1中调用顺序完全不一样，为什么通过subscribeOn切换线程会影响执行顺序？ 先找到 SingleSubscribeOn 类 public final class SingleSubscribeOn&lt;T&gt; extends Single&lt;T&gt; { final SingleSource&lt;? extends T&gt; source; final Scheduler scheduler; public SingleSubscribeOn(SingleSource&lt;? extends T&gt; source, Scheduler scheduler) { this.source = source; this.scheduler = scheduler; } @Override protected void subscribeActual(final SingleObserver&lt;? super T&gt; s) { final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(s, source); //直接调用下游 onSubscribe s.onSubscribe(parent); //再执行订阅上游的方法 Disposable f = scheduler.scheduleDirect(parent); parent.task.replace(f); } static final class SubscribeOnObserver&lt;T&gt; extends AtomicReference&lt;Disposable&gt; implements SingleObserver&lt;T&gt;, Disposable, Runnable { private static final long serialVersionUID = 7000911171163930287L; final SingleObserver&lt;? super T&gt; actual; final SequentialDisposable task; final SingleSource&lt;? extends T&gt; source; SubscribeOnObserver(SingleObserver&lt;? super T&gt; actual, SingleSource&lt;? extends T&gt; source) { this.actual = actual; this.source = source; this.task = new SequentialDisposable(); } @Override public void onSubscribe(Disposable d) { //没有继续调用下游的 onSubscribe 方法 DisposableHelper.setOnce(this, d); } @Override public void onSuccess(T value) { actual.onSuccess(value); } @Override public void onError(Throwable e) { actual.onError(e); } @Override public void dispose() { DisposableHelper.dispose(this); task.dispose(); } @Override public boolean isDisposed() { return DisposableHelper.isDisposed(get()); } @Override public void run() { source.subscribe(this); } } } 同样的直接看subscribeActual方法及onSubscribe方法，发现事情并没有那么简单，和之前的操作符的逻辑区别很大： SubscribeOnObserver同样还继承了AtomicReference&lt;Disposable&gt;，实现了Disposable``Runnable接口 并没有直接调用subscribe订阅上游，而是执行了其它操作符在 onSubscribe中订阅下游的操作 然后再结合Disposable f = scheduler.scheduleDirect(parent);和run方法可以知道在新的线程中执行了订阅上游的操作 source.subscribe(this); onSubsribe中并没有再继续调用下游的 onSubsribe 综合起来可以知道，本来应该在整个流从下至上订阅完成后按照从上至下的顺序执行 onSubscribe的流，在使用subsribeOn操作符的后，在订阅的时(执行subscribeActual)，就开始执行下游的onSubscribe且在当前线程！然后才在指定的io线程执行之下而上的操作，这也是为什么subsribeOn影响的是上游的线程。 小结： 我认为实际上 Rx 使用了很多优秀的设计将我们各种常用的操作进行了封装，让我们自由组合使用，其本身并没有用什么黑科技。例如切换线程本质上则是帮我们启用了一个新的线程并把接下来的代码放进去执行。 当然，其中还有很多更深入的内容需要我们继续发现和学习。 ","link":"https://xiejinpeng007.github.io/post/rxjava2x-cong-yuan-ma-fen-xi-yuan-li/"},{"title":"Kotlin 中的依赖注入 KODEIN","content":"用 Java 进行 Android 开发的话，依赖注入这一块一般使用 Dagger ,转用 Kotlin 之后有更多的选择，Kodein 是个不错的库， 4.0 5.0 都使用过了，相对于 Dagger 有很多好处。 用 Kotlin 编写利用了更优秀的语言特性 比如类型推断，Dagger 在编写 Component 的时候需要知道注入类的类型 无需像 Dagger 一样编写大量模板代码 不会像 Dagger 一样在编译期因为其它的编译错误导致无法生成所需文件从而报一堆错。 ... 最基本的使用步骤 在 Application 继承 KodeinAware 并绑定依赖 class MyApp : Application(), KodeinAware { override val kodein = Kodein.lazy { /* bindings */ } } 在 context aware 的 Android 类中通过 closestKodein 方法获取 加载依赖 class MyApp : Application(), KodeinAware { //实例化 Application 级的 kodein 通过 DSL 绑定 module override val kodein = Kodein.lazy { //导入预设的 android 组件 import(androidModule(this@MainApplication)) //绑定或者导入自定义依赖 } } 相关基本概念 在 Application 定义 Application 级的 Kodein class MyApp : Application(), KodeinAware { //实例化 Application 级的 kodein 通过 DSL 绑定 module override val kodein = Kodein.lazy { //导入预设的 android 组件 import(androidModule(this@MainApplication)) //绑定或者导入自定义依赖 } } 通过 closestKodein 恢复 Application 级的 Kodein 然后通过 Kodein 加载依赖 #####kodein &amp; ds 默认都是懒加载 class MyActivity : Activity(), KodeinAware { override val kodein by closestKodein() val ds: DataSource by instance() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ds.connect() /* ... */ } } 使用 Trigger 在 onCreate() 中手动触发加载依赖（取消懒加载） 同样可以避免依赖死循环（除非加载依赖的方式只有 instance） class MyActivity : Activity(), KodeinAware { override val kodein by closestKodein() override val kodeinTrigger = KodeinTrigger() val ds: DataSource by instance() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) kodeinTrigger.trigger() /* ... */ } } 在没有 Non-Context-Aware 的类中加载 Kodein class MyController(androidContext: Context) : KodeinAware { override val kodein by androidContext.closestKodein() override val kodeinContext = kcontext(androidContext) val inflater: LayoutInflater by instance() } 多级 Kodin 依赖 定义 Activity 级的 Kodein 继承自 Application 级 class MyActivity : Activity(), KodeinAware { private val _parentKodein by closestKodein() override val kodein: Kodein = Kodein { extend(_parentKodein) /* activity specific bindings */ } } Activity Retained Kodein 使用 retainedKodein 在 Activity 重启的时候不会重新创建 Kodein class MyActivity : Activity(), KodeinAware { private val _parentKodein by closestKodein() override val kodein: Kodein by retainedKodein { extend(_parentKodein) /* activity specific bindings */ } } Android scopes 作用域 //每个 Activity 一个单例 val kodein = Kodein { bind&lt;Controller&gt;() with scoped(androidScope&lt;Activity&gt;()).singleton { ControllerImpl(context) } } Activity retained scope 同样 activityRetainedScope 在 Activity 重启时不会重新创建依赖 val kodein = Kodein { bind&lt;Controller&gt;() with scoped(activityRetainedScope).singleton { ControllerImpl() } } Bindings: Declaring dependencies 申明依赖的一些重要的参数 绑定的方式 Provider binding : 每次加载都生成新的实例，无参， 传入() -&gt; T Singleton binding : 单例 传入 () → T Eager singleton : 单例 创建了 Kodein 实例后立即实例化 传入 () -&gt; T Factory binding : 每次加载都生成新的实例，需要参数，传入(A) -&gt; T Multiton binding : 有参的单例，同样参数同样实例，传入 (A) -&gt; T Tagged bindings : 通过 tag 来区分同类型不同的实例 例如 val kodein = Kodein { bind&lt;Die&gt;() with ... bind&lt;Die&gt;(tag = &quot;DnD10&quot;) with ... bind&lt;Die&gt;(tag = &quot;DnD20&quot;) with ... } 基本上以上的参数涵盖了大部分的通用使用场景，Kodein 还有很多复杂的高级用法 JVM: Soft &amp; Weak 两种引用回收机制 使用 WeakReference 在OutOfMemoryException之前 JVM 执行 GC 使用 SoftReference 在没有引用的时候就 JVM 执行 GC val kodein = Kodein { bind&lt;Map&gt;() with refSingleton(ref = softReference) { WorldMap() } bind&lt;Client&gt;() with refSingleton(ref = weakReference) { id -&gt; clientFromDB(id) } } Transitive dependencies 依赖传递 依赖中使用依赖的情况，Kotlin 的类型推断系统可以很简单的实现。 class Die(private val random: Random, private val sides: Int) { /*...*/ } val kodein = Kodein { bind&lt;Die&gt;() with singleton { Die(instance(), instance(tag = &quot;max&quot;)) } bind&lt;Random&gt;() with provider { SecureRandom() } constant(tag &quot;max&quot;) with 5 } 更多高级用法... KODEIN DI: KOtlin DEpendency INjection: 5.0.0 Kodein on Android Getting started Core documentation ","link":"https://xiejinpeng007.github.io/post/kotlin-zhong-de-yi-lai-zhu-ru-kodein/"},{"title":"SQLite 笔记","content":"一些笔记 ROWID : 隐藏的 Column 用于作为行的唯一标识。 ROWID 可以看做一个隐式的 INTEGER PRIMARY KEY ,实际上这才是真正的主键，如果创建了一个 INTEGER PRIMARY KEY 的话， 它会作为 ROWID 的别名(alias) ,而非 INTEGER PRIMARY KEY 实际上只是建立了一个索引。 算法是单调递增，如果达到最大整型(9223372036854775807) 那么会重新查找前面已经删除的 ROWID。 Index 索引: Index 是一种特殊的查找表，数据库搜索引擎用来加快数据检索。简单地说，索引是一个指向表中数据的指针。 索引有助于加快 SELECT 查询和 WHERE 子句，但它会减慢使用 UPDATE 和 INSERT 语句时的数据输入。 索引可以创建或删除，但不会影响数据。 每个主键会自动生成一个 Index AUTOINCREMENT ： 作用于主键，算法是单调递增,算法上和 ROWID 的区别是达到最大整型了之后不会重新查找前面没使用的值。 如果 AUTOINCREMENT 关键字出现在 INTEGER PRIMARY KEY后面，则会更改自动 ROWID 分配算法(因为INTEGER PRIMARY KEY 就是 ROWID 别名)， 以防止在数据库的整个生命周期内重用 ROWID。 WITHOUT ROWID: 实际上\b可以指定不生成 ROWID ,那么必须要指定主键。 关于是否需要 ROWID 的问题，总的来说是空间时间的影响，大概是这样的逻辑： 在普通的SQLite表中，PRIMARY KEY实际上只是一个 UNIQUE索引。用于在磁盘上查找记录的键是 ROWID。 普通SQLite表中的特殊“ INTEGER PRIMARY KEY ”列类型使该列成为 ROWID 的别名，因此 INTEGER PRIMARY KEY 是真正的 PRIMARY KEY。 SQLite 的表是以 B-Tree 实现的， 在 ROWID 表中如果有 非INTEGER PRIMARY KEY 实际上会建立两个 B-Tree , 一个是以 ROWID 为主键其余 column 为数据的 B-Tree;另一个 是以 非INTEGER PRIMARY KEY 为主键 ROWID 为数据的索引。 查询的时候 首先在索引中根据找到匹配的 ROWID 然后再在主表中根据 ROWID 查找数据，所以进行了两次独立的二进制搜索。 关于 SQLite 查询的结果的顺序： 首先如果\b要保证\b\b查询结果的顺序最好就使用 ORDER BY ，否则会按照 Index 进行，没有或关闭 Index 的话会按照 ROWID 顺序查询。 https://www.sqlite.org/lang_createindex.html https://www.sqlite.org/lang_createtable.html https://www.sqlite.org/withoutrowid.html https://sqlite.org/autoinc.html ","link":"https://xiejinpeng007.github.io/post/sqlite-bi-ji/"},{"title":"Swagger (YAML OpenAPI) 从放弃到入门","content":" Swagger 是一个统一前后端用于生成文档和代码的工具，它使用 yaml / json 作为描述语言 通过 OpenAPI Specification 来描述 API，最后使用 Codegen 根据不同的配置来生成各种 language、library 的 Code、Docs. 其最理想的情况则是只需一份描述文件(yaml/json) 生成 后端、前端（android ios web...）的代码和文档，这样的话保证了前后端的统一，且需要升级改动也只需要修改 yaml 文件。 YAML JSON 都已经很熟悉了，虽然 Swagger 可以使用 JSON 作为描述语言，但是因为 YAML 更为简洁直观，所以更推荐 YAML。 YAML 的基本语法并不复杂，这里介绍一些基本语法： yaml 文件 以---开始 ...结尾 同一级别的成员（如 list 成员）可以通过&quot;- &quot;来辨识 注释以#开头的一行 list: fruits: - Apple - Orange - Strawberry - Mango key / value martin: name: Martin D'vloper job: Developer skill: Elite list / map 混合使用 - martin: name: Martin D'vloper job: Developer skills: - python - perl - pascal - tabitha: name: Tabitha Bitumen job: Developer skills: - lisp - fortran - erlang list / map 的简写 martin: {name: Martin D'vloper, job: Developer, skill: Elite} fruits: ['Apple', 'Orange', 'Strawberry', 'Mango'] boolean 值的写法没有严格限制 create_key: yes needs_agent: no knows_oop: True likes_emacs: TRUE uses_cvs: false |使用换行 &gt;忽略换行 include_newlines: | exactly as you see will appear these three lines of poetry ignore_newlines: &gt; this is really a single line of text despite appearances OpenAPI-Specification OpenAPI 是一套用于描述 RESTful APIs 的规范。 The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic. An OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases. 只要符合 OpenAPI 规范的都可以生成各类代码、文档、工具。 目前 OpenAPI 最新 3.0.0 ,对比 2.0 对 API 结构进行了调整。 文档内容繁多请参考 OpenAPI-Specification 3.0.0 下面是 Uber API 的 example # this is an example of the Uber API # as a demonstration of an API spec in YAML openapi: &quot;3.0.0&quot; info: title: Uber API description: Move your app forward with the Uber API version: &quot;1.0.0&quot; servers: - url: https://api.uber.com/v1 paths: /products: get: summary: Product Types description: The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order. parameters: - name: latitude in: query description: Latitude component of location. required: true schema: type: number format: double - name: longitude in: query description: Longitude component of location. required: true schema: type: number format: double security: - apikey: [] tags: - Products responses: '200': description: An array of products content: application/json: schema: $ref: &quot;#/components/schemas/ProductList&quot; default: description: Unexpected error content: application/json: schema: $ref: &quot;#/components/schemas/Error&quot; /estimates/price: get: summary: Price Estimates description: The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.&lt;br&gt;&lt;br&gt;The response also includes low and high estimates, and the [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code for situations requiring currency conversion. When surge is active for a particular product, its surge_multiplier will be greater than 1, but the price estimate already factors in this multiplier. parameters: - name: start_latitude in: query description: Latitude component of start location. required: true schema: type: number format: double - name: start_longitude in: query description: Longitude component of start location. required: true schema: type: number format: double - name: end_latitude in: query description: Latitude component of end location. required: true schema: type: number format: double - name: end_longitude in: query description: Longitude component of end location. required: true schema: type: number format: double tags: - Estimates responses: '200': description: An array of price estimates by product content: application/json: schema: type: array items: $ref: &quot;#/components/schemas/PriceEstimate&quot; default: description: Unexpected error content: application/json: schema: $ref: &quot;#/components/schemas/Error&quot; /estimates/time: get: summary: Time Estimates description: The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs. parameters: - name: start_latitude in: query description: Latitude component of start location. required: true schema: type: number format: double - name: start_longitude in: query description: Longitude component of start location. required: true schema: type: number format: double - name: customer_uuid in: query schema: type: string format: uuid description: Unique customer identifier to be used for experience customization. - name: product_id in: query schema: type: string description: Unique identifier representing a specific product for a given latitude &amp; longitude. tags: - Estimates responses: '200': description: An array of products content: application/json: schema: type: array items: $ref: &quot;#/components/schemas/Product&quot; default: description: Unexpected error content: application/json: schema: $ref: &quot;#/components/schemas/Error&quot; /me: get: summary: User Profile description: The User Profile endpoint returns information about the Uber user that has authorized with the application. tags: - User responses: '200': description: Profile information for a user content: application/json: schema: $ref: &quot;#/components/schemas/Profile&quot; default: description: Unexpected error content: application/json: schema: $ref: &quot;#/components/schemas/Error&quot; /history: get: summary: User Activity description: The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.&lt;br&gt;&lt;br&gt;The history array in the response will have a maximum length based on the limit parameter. The response value count may exceed limit, therefore subsequent API requests may be necessary. parameters: - name: offset in: query schema: type: integer format: int32 description: Offset the list of returned results by this amount. Default is zero. - name: limit in: query schema: type: integer format: int32 description: Number of items to retrieve. Default is 5, maximum is 100. tags: - User responses: '200': description: History information for the given user content: application/json: schema: $ref: &quot;#/components/schemas/Activities&quot; default: description: Unexpected error content: application/json: schema: $ref: &quot;#/components/schemas/Error&quot; components: securitySchemes: apikey: type: apiKey name: server_token in: query schemas: Product: properties: product_id: type: string description: Unique identifier representing a specific product for a given latitude &amp; longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles. description: type: string description: Description of product. display_name: type: string description: Display name of product. capacity: type: integer description: Capacity of product. For example, 4 people. image: type: string description: Image URL representing the product. ProductList: properties: products: description: Contains the list of products type: array items: $ref: &quot;#/components/schemas/Product&quot; PriceEstimate: properties: product_id: type: string description: Unique identifier representing a specific product for a given latitude &amp; longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles currency_code: type: string description: &quot;[ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code.&quot; display_name: type: string description: Display name of product. estimate: type: string description: Formatted string of estimate in local currency of the start location. Estimate could be a range, a single number (flat rate) or &quot;Metered&quot; for TAXI. low_estimate: type: number description: Lower bound of the estimated price. high_estimate: type: number description: Upper bound of the estimated price. surge_multiplier: type: number description: Expected surge multiplier. Surge is active if surge_multiplier is greater than 1. Price estimate already factors in the surge multiplier. Profile: properties: first_name: type: string description: First name of the Uber user. last_name: type: string description: Last name of the Uber user. email: type: string description: Email address of the Uber user picture: type: string description: Image URL of the Uber user. promo_code: type: string description: Promo code of the Uber user. Activity: properties: uuid: type: string description: Unique identifier for the activity Activities: properties: offset: type: integer format: int32 description: Position in pagination. limit: type: integer format: int32 description: Number of items to retrieve (100 max). count: type: integer format: int32 description: Total number of items available. history: type: array items: $ref: &quot;#/components/schemas/Activity&quot; Error: properties: code: type: string message: type: string fields: type: string 这里将 OpenAPI 3.0 规范中把重点使用的 api 整理了一张思维导图（还不完善，会持续更新） Swagger Swagger 实际上包含了一系列的工具 Editor Codegen UI ... Editor 用于使用 OpenAPI 编辑 yaml Codegen 用于生成不同的 language library 的代码 UI 用于生成文档 下面介绍一下 Codegen 的使用： 首先下载 swagger-codegen-cli.jar 确保装好了 maven 准备 swagger.yaml 编写 config.json 配置文件 因为之前提到 Swagger 可以生成各种 lang lib 的代码，所以这里便是进行此类配置: 查看配置 help java -jar swagger-codegen-cli.jar config-help -l java CONFIG OPTIONS sortParamsByRequiredFlag Sort method arguments to place required parameters before optional parameters. (Default: true) ensureUniqueParams Whether to ensure parameter names are unique in an operation (rename parameters that are not). (Default: true) allowUnicodeIdentifiers boolean, toggles whether unicode identifiers are allowed in names or not, default is false (Default: false) modelPackage package for generated models apiPackage package for generated api classes invokerPackage root package for generated code groupId groupId in generated pom.xml artifactId artifactId in generated pom.xml artifactVersion artifact version in generated pom.xml artifactUrl artifact URL in generated pom.xml artifactDescription artifact description in generated pom.xml scmConnection SCM connection in generated pom.xml scmDeveloperConnection SCM developer connection in generated pom.xml scmUrl SCM URL in generated pom.xml developerName developer name in generated pom.xml developerEmail developer email in generated pom.xml developerOrganization developer organization in generated pom.xml developerOrganizationUrl developer organization URL in generated pom.xml licenseName The name of the license licenseUrl The URL of the license sourceFolder source folder for generated code localVariablePrefix prefix for generated code members and local variables serializableModel boolean - toggle &quot;implements Serializable&quot; for generated models (Default: false) bigDecimalAsString Treat BigDecimal values as Strings to avoid precision loss. (Default: false) fullJavaUtil whether to use fully qualified name for classes under java.util. This option only works for Java API client (Default: false) hideGenerationTimestamp hides the timestamp when files were generated withXml whether to include support for application/xml content type. This option only works for Java API client (resttemplate) (Default: false) dateLibrary Option. Date library to use joda - Joda (for legacy app only) legacy - Legacy java.util.Date (if you really have a good reason not to use threetenbp java8-localdatetime - Java 8 using LocalDateTime (for legacy app only) java8 - Java 8 native JSR310 (preferred for jdk 1.8+) - note: this also sets &quot;java8&quot; to true threetenbp - Backport of JSR310 (preferred for jdk &lt; 1.8) java8 Option. Use Java8 classes instead of third party equivalents true - Use Java 8 classes such as Base64 false - Various third party libraries as needed useRxJava Whether to use the RxJava adapter with the retrofit2 library. (Default: false) useRxJava2 Whether to use the RxJava2 adapter with the retrofit2 library. (Default: false) parcelableModel Whether to generate models for Android that implement Parcelable with the okhttp-gson library. (Default: false) usePlay24WS Use Play! 2.4 Async HTTP client (Play WS API) (Default: false) supportJava6 Whether to support Java6 with the Jersey1 library. (Default: false) useBeanValidation Use BeanValidation API annotations (Default: false) performBeanValidation Perform BeanValidation (Default: false) useGzipFeature Send gzip-encoded requests (Default: false) useRuntimeException Use RuntimeException instead of Exception (Default: false) library library template (sub-template) to use (Default: okhttp-gson) jersey1 - HTTP client: Jersey client 1.19.4. JSON processing: Jackson 2.8.9. Enable Java6 support using '-DsupportJava6=true'. Enable gzip request encoding using '-DuseGzipFeature=true'. feign - HTTP client: OpenFeign 9.4.0. JSON processing: Jackson 2.8.9 jersey2 - HTTP client: Jersey client 2.25.1. JSON processing: Jackson 2.8.9 okhttp-gson - HTTP client: OkHttp 2.7.5. JSON processing: Gson 2.8.1. Enable Parcelable models on Android using '-DparcelableModel=true'. Enable gzip request encoding using '-DuseGzipFeature=true'. retrofit - HTTP client: OkHttp 2.7.5. JSON processing: Gson 2.3.1 (Retrofit 1.9.0). IMPORTANT NOTE: retrofit1.x is no longer actively maintained so please upgrade to 'retrofit2' instead. retrofit2 - HTTP client: OkHttp 3.8.0. JSON processing: Gson 2.6.1 (Retrofit 2.3.0). Enable the RxJava adapter using '-DuseRxJava[2]=true'. (RxJava 1.x or 2.x) resttemplate - HTTP client: Spring RestTemplate 4.3.9-RELEASE. JSON processing: Jackson 2.8.9 resteasy - HTTP client: Resteasy client 3.1.3.Final. JSON processing: Jackson 2.8.9 几个主要的配置参数： library，生成的代码支付的类，有jersey1、jersey2、okhttp-gson、resttemplate、resteasy、feign、retrofit、retrofit2等几种类型，我们选择的retrofit2 developerName，开发者名字，会出现在代码文件里 developerEmail，开发者邮箱，会出现在代码文件里 developrOrganization，开发者组织，会出现在代码里 invokerPackage，项目的包名 apiPackage，生成的***Api.java文件的包名 modelPackage，生成的数据模型java文件包名 dateLibrary，时间使用的类开 useRxJava，是否使用rxjava生成api接口 useRxJava2，是否使用rxjava2的方式调用接口 generate 生成代码 首先打印参数信息 java -jar swagger-codegen-cli.jar generate help NAME swagger-codegen-cli generate - Generate code with chosen lang SYNOPSIS swagger-codegen-cli generate [(-a &lt;authorization&gt; | --auth &lt;authorization&gt;)] [--additional-properties &lt;additional properties&gt;...] [--api-package &lt;api package&gt;] [--artifact-id &lt;artifact id&gt;] [--artifact-version &lt;artifact version&gt;] [(-c &lt;configuration file&gt; | --config &lt;configuration file&gt;)] [-D &lt;system properties&gt;...] [--git-repo-id &lt;git repo id&gt;] [--git-user-id &lt;git user id&gt;] [--group-id &lt;group id&gt;] [--http-user-agent &lt;http user agent&gt;] (-i &lt;spec file&gt; | --input-spec &lt;spec file&gt;) [--ignore-file-override &lt;ignore file override location&gt;] [--import-mappings &lt;import mappings&gt;...] [--instantiation-types &lt;instantiation types&gt;...] [--invoker-package &lt;invoker package&gt;] (-l &lt;language&gt; | --lang &lt;language&gt;) [--language-specific-primitives &lt;language specific primitives&gt;...] [--library &lt;library&gt;] [--model-name-prefix &lt;model name prefix&gt;] [--model-name-suffix &lt;model name suffix&gt;] [--model-package &lt;model package&gt;] [(-o &lt;output directory&gt; | --output &lt;output directory&gt;)] [--release-note &lt;release note&gt;] [--remove-operation-id-prefix] [--reserved-words-mappings &lt;reserved word mappings&gt;...] [(-s | --skip-overwrite)] [(-t &lt;template directory&gt; | --template-dir &lt;template directory&gt;)] [--type-mappings &lt;type mappings&gt;...] [(-v | --verbose)] OPTIONS -a &lt;authorization&gt;, --auth &lt;authorization&gt; adds authorization headers when fetching the swagger definitions remotely. Pass in a URL-encoded string of name:header with a comma separating multiple values --additional-properties &lt;additional properties&gt; sets additional properties that can be referenced by the mustache templates in the format of name=value,name=value. You can also have multiple occurrences of this option. --api-package &lt;api package&gt; package for generated api classes --artifact-id &lt;artifact id&gt; artifactId in generated pom.xml --artifact-version &lt;artifact version&gt; artifact version in generated pom.xml -c &lt;configuration file&gt;, --config &lt;configuration file&gt; Path to json configuration file. File content should be in a json format {&quot;optionKey&quot;:&quot;optionValue&quot;, &quot;optionKey1&quot;:&quot;optionValue1&quot;...} Supported options can be different for each language. Run config-help -l {lang} command for language specific config options. -D &lt;system properties&gt; sets specified system properties in the format of name=value,name=value (or multiple options, each with name=value) --git-repo-id &lt;git repo id&gt; Git repo ID, e.g. swagger-codegen. --git-user-id &lt;git user id&gt; Git user ID, e.g. swagger-api. --group-id &lt;group id&gt; groupId in generated pom.xml --http-user-agent &lt;http user agent&gt; HTTP user agent, e.g. codegen_csharp_api_client, default to 'Swagger-Codegen/{packageVersion}}/{language}' -i &lt;spec file&gt;, --input-spec &lt;spec file&gt; location of the swagger spec, as URL or file (required) --ignore-file-override &lt;ignore file override location&gt; Specifies an override location for the .swagger-codegen-ignore file. Most useful on initial generation. --import-mappings &lt;import mappings&gt; specifies mappings between a given class and the import that should be used for that class in the format of type=import,type=import. You can also have multiple occurrences of this option. --instantiation-types &lt;instantiation types&gt; sets instantiation type mappings in the format of type=instantiatedType,type=instantiatedType.For example (in Java): array=ArrayList,map=HashMap. In other words array types will get instantiated as ArrayList in generated code. You can also have multiple occurrences of this option. --invoker-package &lt;invoker package&gt; root package for generated code -l &lt;language&gt;, --lang &lt;language&gt; client language to generate (maybe class name in classpath, required) --language-specific-primitives &lt;language specific primitives&gt; specifies additional language specific primitive types in the format of type1,type2,type3,type3. For example: String,boolean,Boolean,Double. You can also have multiple occurrences of this option. --library &lt;library&gt; library template (sub-template) --model-name-prefix &lt;model name prefix&gt; Prefix that will be prepended to all model names. Default is the empty string. --model-name-suffix &lt;model name suffix&gt; Suffix that will be appended to all model names. Default is the empty string. --model-package &lt;model package&gt; package for generated models -o &lt;output directory&gt;, --output &lt;output directory&gt; where to write the generated files (current dir by default) --release-note &lt;release note&gt; Release note, default to 'Minor update'. --remove-operation-id-prefix Remove prefix of operationId, e.g. config_getId =&gt; getId --reserved-words-mappings &lt;reserved word mappings&gt; specifies how a reserved name should be escaped to. Otherwise, the default _&lt;name&gt; is used. For example id=identifier. You can also have multiple occurrences of this option. -s, --skip-overwrite specifies if the existing files should be overwritten during the generation. -t &lt;template directory&gt;, --template-dir &lt;template directory&gt; folder containing the template files --type-mappings &lt;type mappings&gt; sets mappings between swagger spec types and generated code types in the format of swaggerType=generatedType,swaggerType=generatedType. For example: array=List,map=Map,string=String. You can also have multiple occurrences of this option. -v, --verbose verbose mode 几个主要参数： -i 表示输入的文件，editor生成的设计文件路径，如：-i ~/Desktop/swagger.yaml -o 代码生成目录，swagger codegen 把代码生成到什么地方，如：-o ~/Desktop -l 生成代码语言，我们是生成java，如：-l java -c 配置文件，配制文件路径，如：-c ~/Desktop/config.json 最后生成代码 java -jar swagger-codegen-cli.jar generate -i swagger.yaml -o client -l java -c config.json 成功在 ~/Desktop 下生成了相应的 code 和 doc 参考资料以及推荐阅读的资料 http://docs.ansible.com/ansible/latest/YAMLSyntax.html https://swagger.io/docs/specification/about/ http://www.jianshu.com/p/c178c18aaf43 https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md https://github.com/swagger-api https://www.gitbook.com/book/huangwenchao/swagger/details ","link":"https://xiejinpeng007.github.io/post/swagger-yaml-openapi-cong-fang-qi-dao-ru-men/"},{"title":"Google 新提出的 App Architecture 分析","content":"App Architecture 为什么提出新架构： 比如，当你要在自己最喜欢的社交网络app中分享一张照片的时候，你可以想象一下会发生什么。app触发一个camera intent，然后Android OS启动一个camera app来处理这一动作。此时用户已经离开了社交网络的app，但是用户的操作体验却是无缝对接的。而 camera app反过来也可能触发另一个intent，比如启动一个文件选择器，这可能会再次打开另一个app。最后用户回到社交网络app并分享照片。在这期间的任意时刻用户都可被电话打断，打完电话之后继续回来分享照片。 总的来说就是，你的app组件可能是单独启动并且是无序的，而且在任何时候都有可能被系统或者用户销毁。因为app组件生命的短暂性以及生命周期的不可控制性，任何数据都不应该把存放在app组件中，同时app组件之间也不应该相互依赖。 =&gt; 任何数据都不应该存放在app组件中： 通用的架构准则 最重要的一个原则就是尽量在app中做到separation of concerns（关注点分离）。常见的错误就是把所有代码都写在Activity或者Fragment中。任何跟UI和系统交互无关的事情都不应该放在这些类当中。尽可能让它们保持简单轻量可以避免很多生命周期方面的问题。别忘了能并不拥有这些类，它们只是连接app和操作系统的桥梁。根据用户的操作和其它因素，比如低内存，Android OS可能在任何时候销毁它们。为了提供可靠的用户体验，最好把对它们的依赖最小化。 ==&gt; 通过MVVM来分层 第二个很重要的准则是用model驱动UI，最好是持久化的model。之所以要持久化是基于两个原因：如果OS销毁app释放资源，用户数据不会丢失；当网络很差或者断网的时候app可以继续工作。Model是负责app数据处理的组件。它们不依赖于View或者app 组件（Activity，Fragment等），因此它们不会受那些组件的生命周期的影响。保持UI代码的简单，于业务逻辑分离可以让它更易管理。 其中比较重要的一点就是为每个层级加入和绑定了生命周期这一个关系。 为了实现这个新的架构，Google提供了几种组件。 Lifecycle Lifecycle 是一个持有组件（比如 activity 或者 fragment）生命周期状态信息的类，并且允许其它对象观察这个状态。 Lifecycle 主要使用两个枚举来跟踪相关组件的生命周期状态。 Event: {ON_ANY,ON_CREATE,ON_DESTROY,ON_PAUSE,ON_RESUME,ON_START,ON_STOP} State: {CREATED,DESTROYED,INITIALIZED,RESUMED,STARTED} LifecycleOwner 需要被观察的组件（比如 activity）实现这个接口 =&gt; 被观察者 LifecycleObserver 需要观察其它组件生命周期的类 =&gt; 观察者 设想这样的情景： //activity 启动的时候开始位置获取的服务 // 结束的时候暂停位置获取的服务 class MyActivity extends AppCompatActivity { private MyLocationListener myLocationListener; public void onCreate(...) { myLocationListener = new MyLocationListener(this, location -&gt; { // update UI }); } public void onStart() { super.onStart(); Util.checkUserStatus(result -&gt; { //在启动的时候又需要检查一些配置（例如其它的资源准备好没有） //如果检查完毕后，activity.stop()，NPE。 // what if this callback is invoked AFTER activity is stopped? if (result) { myLocationListener.start(); } }); } public void onStop() { super.onStop(); myLocationListener.stop(); } } 如何使用 Lifecycle 解决 在 fragment / activity 这样实现了LifecycleRegistryOwner的类，则可以直接注册观察者（也可以自定义） fragment.getLifecycle().addObserver(new MyLocationListener()); 如果使用了Lifecycle，则可以让 MyLocationListener 在内部获取组件的生命周期和响应生命周期变化的回调： class MyLocationListener implements LifecycleObserver { private boolean enabled = false; public MyLocationListener(Context context, Lifecycle lifecycle, Callback callback) { ... } @OnLifecycleEvent(Lifecycle.Event.ON_START) void start() { if (enabled) { // connect } } public void enable() { enabled = true; if (lifecycle.getState().isAtLeast(STARTED)) { // connect if not connected } } @OnLifecycleEvent(Lifecycle.Event.ON_STOP) void stop() { // disconnect if connected } } LiveData LiveData是一个可观察的数据持有者。 无需明确在它与app组件之间创建依赖就可以观察LiveData对象的变化。LiveData还考虑了app组件(activities, fragments, services)的生命周期状态，做了防止对象泄漏的事情。 =&gt; 过去是一个普通的POJO类，需要手动管理，现在绑定上了生命周期以及数据变化可以被观察。 =&gt; 有点类似带有生命周期的Rxjava。 一个普通的LiveData ViewModel public class UserProfileViewModel extends ViewModel { ... private User user; private LiveData&lt;User&gt; user; public LiveData&lt;User&gt; getUser() { return user; } } Fragment // Update when the data changes. @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); viewModel.getUser().observe(this, user -&gt; { // update UI }); } 包装后的LiveData //现在需要一个可以获取Location数据的类 //并且需要被多处使用 public class LocationLiveData extends LiveData&lt;Location&gt; { private static LocationLiveData sInstance; private LocationManager locationManager; @MainThread public static LocationLiveData get(Context context) { if (sInstance == null) { sInstance = new LocationLiveData(context.getApplicationContext()); } return sInstance; } private SimpleLocationListener listener = new SimpleLocationListener() { @Override public void onLocationChanged(Location location) { setValue(location); } }; private LocationLiveData(Context context) { locationManager = (LocationManager) context.getSystemService( Context.LOCATION_SERVICE); } @Override protected void onActive() { locationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 0, 0, listener); } @Override protected void onInactive() { locationManager.removeUpdates(listener); } } 在fragment中如下使用： public class MyFragment extends LifecycleFragment { public void onActivityCreated (Bundle savedInstanceState) { Util.checkUserStatus(result -&gt; { if (result) { LocationLiveData.get(getActivity()).observe(this, location -&gt; { // update UI }); } }); } } 有三个方法值得注意 onActive():在LiveData有活跃的观察者的时候调用 =&gt; 在上面这个例子中，有观察者激活了需要获取Location数据的时候。 onInactive():没有活跃的观察者的时候调用 =&gt; 在这里可以暂停位置服务的更新 setValue(): 调用此方法通知外部观察者数据改变 这样，在多个fragment中都需要使用位置信息的时候，不仅可以共享资源，LiveData可以自行妥善管理好生命周期。 优点： 没有内存泄露 不会因为某个activity结束了后,还在使用activity的引用而引起崩溃 因为类似屏幕旋转的操作而导致fragment重建或重新进入生命周期，fragment会立即接受到最近的数据。 可以共享资源 无需手动管理生命周期 在fragment.onDestroy()时，就会自动移除观察者 Observer 在fragment处于非活动状态时，callback不会触发。 ViewModel 一个ViewModel为特定的UI组件提供数据，比如fragment 或者 activity，并负责和数据处理的业务逻辑部分通信，比如调用其它组件加载数据或者转发用户的修改。ViewModel并不依赖于activity fragment view，也不会被configuration change影响。 public abstract class ViewModel { /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(&quot;WeakerAccess&quot;) protected void onCleared() { } } /** * Application context aware {@link ViewModel}. * &lt;p&gt; * Subclasses must have a constructor which accepts {@link Application} as the only parameter. * &lt;p&gt; */ public class AndroidViewModel extends ViewModel { private Application mApplication; public AndroidViewModel(Application application) { mApplication = application; } /** * Return the application. */ public &lt;T extends Application&gt; T getApplication() { return (T) mApplication; } } 在fragment中设置 UID，通过fragtment arguments传递，因为ViewModel游离在View的生命周期之外，所以当类似 configuration changed (比如屏幕旋转)的时候会自动将数据保存下来，新的fragment进入生命周期的时候，会收到相同的ViewModel。 public class UserProfileFragment extends LifecycleFragment { private static final String UID_KEY = &quot;uid&quot;; private UserProfileViewModel viewModel; @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) { super.onActivityCreated(savedInstanceState); String userId = getArguments().getString(UID_KEY); viewModel = ViewModelProviders.of(this).get(UserProfileViewModel.class); viewModel.init(userId); } @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { return inflater.inflate(R.layout.user_profile, container, false); } } 避免了需要重复获取数据从而浪费资源、内存泄露的问题。 Repository 类似之前使用的Presenter层，从不同的数据源（内存、网络、硬盘）提供数据，并不需要ViewModel层关心具体操作。 另外，Google希望在这一层对于数据进行缓存和持久化。 public class UserRepository { private Webservice webservice; // ... public LiveData&lt;User&gt; getUser(int userId) { // This is not an optimal implementation, we'll fix it below final MutableLiveData&lt;User&gt; data = new MutableLiveData&lt;&gt;(); webservice.getUser(userId).enqueue(new Callback&lt;User&gt;() { @Override public void onResponse(Call&lt;User&gt; call, Response&lt;User&gt; response) { // error case is left out for brevity data.setValue(response.body()); } }); return data; } } 管理不同组件间的依赖： 现在 Google 推荐Dagger2 Room 一个ORM库 参考资料： https://developer.android.com/topic/libraries/architecture/index.html https://developer.android.google.cn/topic/libraries/architecture/guide.html https://developer.android.google.cn/topic/libraries/architecture/lifecycle.html https://developer.android.google.cn/topic/libraries/architecture/viewmodel.html https://developer.android.google.cn/topic/libraries/architecture/livedata.html http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0523/7963.html http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0524/7969.html ","link":"https://xiejinpeng007.github.io/post/google-xin-ti-chu-de-app-architecture-fen-xi/"},{"title":"[精华翻译] Rxjava 2.x : What's different in 2.0","content":" 读完了 RxJava 2.x ：What's different in 2.0 后，将值得重点注意的变化进行了翻译和归纳。 Maven仓库依赖地址和包名的变更 ： Maven 仓库地址在 io.reactivex.rxjava2:rxjava:2.x.y 下 类在包名为 io.reactivex 下 JavaDoc 在 http://reactivex.io/RxJava/2.x/javadoc/ Nulls Rxjava 2.x 不再接受 null，下面的情况会立即抛出 NullPointerException Observable.just(null); Single.just(null); Observable.fromCallable(() -&gt; null) .subscribe(System.out::println, Throwable::printStackTrace); Observable.just(1).map(v -&gt; null) .subscribe(System.out::println, Throwable::printStackTrace); 也就是说 Observable&lt;Null&gt; 也不被允许，作为代替，我们可以定义一个Observable&lt;Object&gt;传入一个不相关的值，如下： enum Irrelevant { INSTANCE; } Observable&lt;Object&gt; source = Observable.create((ObservableEmitter&lt;Object&gt; emitter) -&gt; { System.out.println(&quot;Side-effect 1&quot;); emitter.onNext(Irrelevant.INSTANCE); System.out.println(&quot;Side-effect 2&quot;); emitter.onNext(Irrelevant.INSTANCE); System.out.println(&quot;Side-effect 3&quot;); emitter.onNext(Irrelevant.INSTANCE); }); source.subscribe(e -&gt; { /* Ignored. */ }, Throwable::printStackTrace); Observable and Flowable Rxjava 2.x 一个大的改进就是解决了 1.x 中不支持 backpressure 问题 解决方案是将过去的 Observable 重新设计为： 不支持 backpressure 的 io.reactivex.Observable : 现在 Observable会将没有消费的数据保存在内存中直到OutOfMemoryError而不会抛出MissBackpressureException 支持 backpressure 的 io.reactivex.Flowable 在 Flowable.create()创建时指定背压策略 : 如BackpressureStrategy.DROP 两种类型的使用场景 Observable: 流需要处理的元素不超过1K 或者不会产生 OOME 响应 Mouse Touch 相关GUI操作的事件 Flowable: 流的超过10K个元素的流 一系列可能阻塞消费的操作（解析文件、网络请求、数据库操作...） Single Completable Maybe 2.x 整个架构都按照 Reactive-Streams 规范设计, 所以现在的基本消费者类型改为了接口 Single: 只关心调用成功后对数据的处理 onSubscribe (onSuccess | onError)? Completable：只关心是否调用成功 onSubscribe (onComplete | onError)?. Maybe：可能出现无数据或只有一个数据的情况，所以onSuccess()和onComplete()只会调用其中一个 onSubscribe (onSuccess | onError | onComplete)? Base reactive interfaces 与 Reactive-Streams 中 Flowable extends Publisher&lt;T&gt; 风格一样，其他基本响应类也有类似的基础接口 interface ObservableSource&lt;T&gt; { void subscribe(Observer&lt;? super T&gt; observer); } interface SingleSource&lt;T&gt; { void subscribe(SingleObserver&lt;? super T&gt; observer); } interface CompletableSource { void subscribe(CompletableObserver observer); } interface MaybeSource&lt;T&gt; { void subscribe(MaybeObserver&lt;? super T&gt; observer); } 所以现在的操作符也接受 Publisher 和 XSource: Flowable&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper); Observable&lt;R&gt; flatMap(Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper); Subjects and Processors 同样是为了解决 backpressure 问题把 Subjects 分为了 Subjects 和 Processors io.reactivex.subjects.AsyncSubject io.reactivex.subjects.BehaviorSubject io.reactivex.subjects.PublishSubject io.reactivex.subjects.ReplaySubject io.reactivex.subjects.UnicastSubject 不支持 backpressure , 属于 Observable 系列 io.reactivex.processors.AsyncProcessor io.reactivex.processors.BehaviorProcessor io.reactivex.processors.PublishProcessor io.reactivex.processors.ReplayProcessor io.reactivex.processors.UnicastProcessor 支持 backpressure ，属于 Flowable 系列 TestSubject 1.x 的 TestSubject 已被丢弃，现在通过 TestScheduler , PublishProcessor/PublishSubject 和 observeOn(TestScheduler)代替 SerializedSubject SerializedSubject 由 Subject.toSerialized() 和 FlowableProcessor.toSerialized() 代替 Other classes rx.observables.GroupedObservable 由io.reactivex.observables.GroupedObservable&lt;T&gt; 和io.reactivex.flowables.GroupedFlowable&lt;T&gt;代替 Functional interfaces functional 接口 默认定义了 throws Exception 不需要再内部try-catch Actions Functions 符合 java8 命名规范 Func -&gt; Function , Action0/Action1/Action2 -&gt; Action/Consumer/BiConsumer 删除了 Action3-9/Func3-9 由 Action&lt;Object[]&gt;/Function&lt;Object[],R&gt;代替 Subscriber Subscription Reactive-Streams 规范中已经定义了 Subscriber 接口 所以以前的 Subscriber 类的职能现在由 Subscriber 接口的实现类代替: DefaultSubscriber, ResourceSubscriber,DisposableSubscriber（以及它们的XObserver 变体） 因为以上继承了Disposable 所以也支持通过 dispose() 来断开对信号的监听 ResourceSubscriber&lt;Integer&gt; subscriber = new ResourceSubscriber&lt;Integer&gt;() { @Override public void onStart() { request(Long.MAX_VALUE); } @Override public void onNext(Integer t) { System.out.println(t); } @Override public void onError(Throwable t) { t.printStackTrace(); } @Override public void onComplete() { System.out.println(&quot;Done&quot;); } }; Flowable.range(1, 10).delay(1, TimeUnit.SECONDS).subscribe(subscriber); subscriber.dispose(); CompositeSubscription -&gt; CompositeDisposable subscribe() 不返回值 subscribWith() 返回 CompositeDisposable onCompleted() -&gt; onComplete() request() 决定 subscriber最大接受多少个事件 Schedulers 默认不变的线程:computation io newThread trampoline 移除:immediate -&gt; tranmpoline 移除: test() -&gt; new TestScheduler() 启动 Scheduler 无需再 createWorker new() 现在接受 TimeUnit 参数 Entering the reactive world 现在调用 Observalble.create() 更安全 Leaving the reactive world 从响应式流中离开的方式： List&lt;Integer&gt; list = Flowable.range(1, 100).toList().blockingGet(); // toList() returns Single Integer i = Flowable.range(100, 100).blockingLast(); 另一个关于 rx.Subscriber 和 org.reactivestreams.Subscriber的重大变化是 Subscribers 和 Observers 内部不在允许 throws 任何东西除了致命异常（参见 Exceptions.throwIfFatal()）,所以下面的代码现在不合法： Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt;() { @Override public void onSubscribe(Subscription s) { s.request(Long.MAX_VALUE); } public void onNext(Integer t) { if (t == 1) { throw new IllegalArgumentException(); } } public void onError(Throwable e) { if (e instanceof IllegalArgumentException) { throw new UnsupportedOperationException(); } } public void onComplete() { throw new NoSuchElementException(); } }; Flowable.just(1).subscribe(subscriber); (Observer, SingleObserver, MaybeObserver and CompletableObserver 同理) 如果必须要这样 throws 可以选择使用 safeSubscribe()或 subscribe(Consumer&lt;T&gt;, Consumer&lt;Throwable&gt;, Action)的相关 Consumer 重载 Operator differences 关于操作符的调整主要是为了适配以上的变化，调整命名/参数/返回值 详见官方 Wiki 表格 总结 总的来说，我认为RxJava 2.x 主要做了三点更新 对 backpressure 问题进行了修正（产生了大量关联的修正） 按照 Reactive-Streams 规范对整个架构进行了重新设计 一些的其它零散更新 所以说虽然基本思想没有变化但还是需要重新理解学习的 ","link":"https://xiejinpeng007.github.io/post/jing-hua-fan-yi-rxjava-2x-whats-different-in-20/"},{"title":"Firebase Notification配置","content":"Firebase Notification配置 前言： 以前项目中用过GCM，现在Google收购了FireBase之后现在需要用到推送,看了下文档发现GCM并入了FCM,相关API和用法基本一致，趁此机会整理一下基本配置方法。 基本配置 官方Doc 官方Sample 运行要求：android2.3以上及google play service 9.6.1版本以上的设备 1. 在firebase中创建项目后创建android子项目填写相关信息 包括：package id 2. 复制生成的文件放到module目录下 3. 在project目录的build.gradle下添加依赖 dependencies { classpath 'com.google.gms:google-services:3.0.0' } 4. 在module目录的build.gradle下添加依赖 dependencies { compile 'com.google.firebase:firebase-messaging:9.6.1' compile 'com.google.android.gms:play-services:9.6.1' } //底部添加plugin apply plugin: 'com.google.gms.google-services' 5. 在BaseAvtivity中检查GoogleService是否可用： @Override protected void onResume() { super.onResume(); isGooglePlayServicesAvailable(); handleFcmDataExtras(); } public void isGooglePlayServicesAvailable() { int state = GoogleApiAvailability.getInstance().isGooglePlayServicesAvailable(this); if (state != SUCCESS) GoogleApiAvailability.getInstance().getErrorDialog(this, state, 0).show(); } 6. 继承FirebaseInstanceIdservice注册token @Override public void onTokenRefresh() { // 获取 InstanceID String refreshedToken = FirebaseInstanceId.getInstance().getToken(); Log.d(TAG, &quot;Refreshed token: &quot; + refreshedToken); sendRegistrationToServer(refreshedToken); } private void sendRegistrationToServer(String refreshedToken) { // 在此方法中将InstanceID发送给app的服务器，用于定向发送推送消息。 } 7.继承FirebaseMessagingService以及在Luncher Activity进行接收消息/数据的配置。 FireBaseMessagingService中 private final String TAG = &quot;MyFirebaseMsgService&quot;; @Override public void onMessageReceived(RemoteMessage remoteMessage) { //用于处理主题消息 //并不是所有的消息都在这里处理，如果APP处在后台接收带数据的通知，那么数据会放在启动activity的Intent中 if ((remoteMessage.getFrom().startsWith(&quot;/topics/&quot;))) { String topic = remoteMessage.getFrom().replace(&quot;/topics/&quot;, &quot;&quot;); Log.d(TAG, &quot;From: &quot; + remoteMessage.getFrom()); Log.d(TAG, &quot;From: &quot; + topic); } // 检查是否包含数据 if (remoteMessage.getData().size() &gt; 0) { Log.d(TAG, &quot;Message data payload: &quot; + remoteMessage.getData()); } // 检查是否包含通知 if (remoteMessage.getNotification() != null) { Log.d(TAG, &quot;Message Notification Body: &quot; + remoteMessage.getNotification().getBody()); sendNotification(remoteMessage.getNotification().getTitle(), remoteMessage.getNotification().getBody()); } //如果有其它相关自定义操作，在这里完成 } /** * 创建Notification发送给 */ private void sendNotification(String title, String messageBody) { Intent intent = new Intent(this, MainActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0 /* Request code */, intent, PendingIntent.FLAG_ONE_SHOT); Uri defaultSoundUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION); NotificationCompat.Builder notificationBuilder = new NotificationCompat.Builder(this) .setSmallIcon(R.drawable.ic_media_play) .setContentTitle(&quot;FCM Message&quot;) .setContentTitle(title) .setContentText(messageBody) .setAutoCancel(true) .setSound(defaultSoundUri) .setContentIntent(pendingIntent); NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); notificationManager.notify(0 /* ID of notification */, notificationBuilder.build()); } 在Launcher Activity中 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 当Notification的类型是message+data时，data在此处理 if (getIntent().getExtras() != null) { for (String key : getIntent().getExtras().keySet()) { Object value = getIntent().getExtras().get(key); Log.d(TAG, &quot;Key: &quot; + key + &quot; Value: &quot; + value); } }} 官方Doc 推送方式 根据app id推送 根据设备的fcm Id推送 根据用户订阅的topic推送 消息类型 通知 数据 通知+数据 app接收消息时的行为 根据app在前台/后台、消息类型的不同分别作出不同的行为。 应用状态 通知 数据 两者 前台 onMessageReceived onMessageReceived onMessageReceived 后台 系统托盘 onMessageReceived 通知：系统托盘;数据：Intent的extra中 实测即使app处于后台未kill的状态，通知也会交由系统处理。 icon / color 相关设定 在5.0以后app的small_icon只能带有aplha图层，不支持rgb图层。 APP处于前台时：可以在onMessageReceived（）全权处理消息如自定义notification : large_icon , small_icon , color . APP处于后台时：由系统通知处理这部分显示，只可以在Manifest定义 : icon、color &lt;meta-data android:name=&quot;com.google.firebase.messaging.default_notification_icon&quot; android:resource=&quot;@drawable/ic_stat_ic_notification&quot; /&gt; &lt;meta-data android:name=&quot;com.google.firebase.messaging.default_notification_color&quot; android:resource=&quot;@color/colorAccent&quot; /&gt; ","link":"https://xiejinpeng007.github.io/post/firebase-notification-pei-zhi/"},{"title":"Kotlin 初印象和学习资源整理","content":"Cool： 很多好用的语法糖 减少模板代码的默认实现（数据类、代理...） 新特性（类型推断、空安全、lambdas、高阶函数、扩展函数、响应式、惰性计算、协程...） 对于函数式编程的良好支持但又不强制使用。 Language 和 IDE由 JetBrains 开发和支持 ，最近在AOSP中也出现了Kotlin。 Shit： 虽然可以和java混合编译，但是目前来说一些注解处理器还是用不了（Lombok、Butterknife...） 感受 相较于Scala ，Kotlin并没有走那么极端的路线，其最大的特点是【兼容性】 兼容Java old school style 之外解决痛点增加新特性。 如果你是守旧派：完全可以按照Java面向对象编程思维习惯来使用Kotlin 如果你是激进派：Kotlin良好支持了函数式编程。 to be continue... Kotlin基本文档 http://kotlinlang.org/docs/reference/ https://hltj.gitbooks.io/kotlin-reference-chinese/content/ Kotlin 与 Java 基本语法的比较 https://fabiomsr.github.io/from-java-to-kotlin/index.html Kotlin中文站 https://kotlin-zhcn.github.io/ Kotlin 优秀资源整合 https://kotlin.link/ Kotlin for Android Developers https://www.gitbook.com/book/wangjiegulu/kotlin-for-android-developers-zh/details 《Kotlin in Action》 https://panxl6.gitbooks.io/kotlin-in-action-in-chinese/content/ ","link":"https://xiejinpeng007.github.io/post/kotlin-chu-yin-xiang-he-xue-xi-zi-yuan-zheng-li/"},{"title":"仿饿了么动画","content":"仿饿了么动画 最近项目Release完毕，闲暇之余给公司内部的小卖部app升下级(一个人撸完了design+code)，添加了一个商城功能，因为每天都用饿了么点外卖，比较喜欢饿了么点餐落入购物车的动画，所以说自己实现了一个，做一点微小的笔记。 整个界面相关元素有RecyclerView + FloatActionButton，动画是点击item出现一个图标以抛物线落入购物车。 整体的思路是： 点击itemView获取到相关location[]、height、width、position参数 在View层中拿到的参数初始化动画View、ViewGroup 初始化动画、开始动画 Step1: RecyclerView.Adapter类 /** * 在RecyclerView.Adapter中的itemView添加点击事件，用于获取这个itemView在窗口（Window）中的位置信息(location[])。 * 这里传递的参数还包括itemView的宽高和position，用于更细致的调整动画的初始位置和更新相关数据。 * 这里发送点击事件没有使用接口而是用了RxBus调用startAddToCartAnim()，效果和平时使用的接口一致。 */ holder.itemView.setOnClickListener(v -&gt; { int height = holder.itemView.getHeight(); int width = holder.itemView.getWidth(); int[] startLocation = new int[2]; holder.itemView.getLocationInWindow(startLocation); String name = list.get(holder.getLayoutPosition()).getName(); RxBus.getInstance().send(new F01_01_ShopFragment.OnRecyclerItemClickEvent(startLocation, height, width, holder.getLayoutPosition(), name)); }); Step2: Activity/Fragment类 private void startAddToCartAnim(int[] startLocation, int height, int width) { //初始化startLocation、endLocation坐标 int[] endLocation = new int[2]; orderFloatingactionbutton.getLocationInWindow(endLocation); //初始化动画以及parentLayout的参数 ImageView animView = new ImageView(getContext()); animView.setImageResource(R.drawable.ic_card_giftcard_red_400_36dp); LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); params.leftMargin = startLocation[0] + width / 2; params.topMargin = startLocation[1]; //获取parentLayout以及添加动画view到parentLayout getAnimLayout().addView(animView, params); //设定动画类型（使用简单的TranslateAnimation，通过不同的Interpolator来达到抛物线效果） TranslateAnimation animationX = new TranslateAnimation(0, endLocation[0] - startLocation[0] - width / 2, 0, 0); animationX.setInterpolator(new LinearInterpolator()); animationX.setFillAfter(true); TranslateAnimation animationY = new TranslateAnimation(0, 0, 0, endLocation[1] - startLocation[1]); animationY.setInterpolator(new AccelerateInterpolator()); animationY.setFillAfter(true); AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0.5f); AnimationSet set = new AnimationSet(false); set.addAnimation(animationX); set.addAnimation(animationY); set.addAnimation(alphaAnimation); set.setDuration(500); //执行动画 animView.startAnimation(set); set.setAnimationListener(new Animation.AnimationListener() { @Override public void onAnimationStart(Animation animation) { } @Override public void onAnimationEnd(Animation animation) { animView.setVisibility(View.GONE); } @Override public void onAnimationRepeat(Animation animation) { } }); } /** * 获取点击动画所在的parentLayout(因为动画的坐标用的getLocationInWindow获取，所以这里也以DecorView的区域为parentLayout) * 这里的animLayout和animView的实例不能复用 */ private ViewGroup getAnimLayout() { ViewGroup rootView = (ViewGroup) getActivity().getWindow().getDecorView(); LinearLayout animLayout = new LinearLayout(getContext()); LinearLayout.LayoutParams lp = new LinearLayout.LayoutParams( LinearLayout.LayoutParams.MATCH_PARENT, LinearLayout.LayoutParams.MATCH_PARENT); animLayout.setLayoutParams(lp); animLayout.setId(Integer.MAX_VALUE - 1); animLayout.setBackgroundResource(android.R.color.transparent); rootView.addView(animLayout); return animLayout; } 补充： 这里以item中间为坐标开始动画，以最精简的代码实现了基本动画，开发者可以以此为基础实现更复杂更精细的动画。 比如：还可以根据location[]、height、width调整动画位置或是重写OnTouchListener根据触摸位置设定开始动画。 ","link":"https://xiejinpeng007.github.io/post/fang-e-liao-me-dong-hua/"}]}